import { array, ArrayTimeSeries, compareTypesDeep, copyPropsShallow, copyTimeSeries, DGRAPH_SUB, dgraphReviver, GRANULARITY, IDCompound, Link, LinkArray, LinkQuery, LinkTypeArray, Location, LocationArray, LocationQuery, Node, NodeArray, NodePair, NodePairArray, NodePairQuery, NodeQuery, NodeTypeArray, Ordering, ScalarTimeSeries, sortNumber, Time, TimeArray, TimeQuery } from "./dynamicgraph";
import { Selection } from "./datamanager";
import * as moment from "moment";
import { isValidIndex } from "./datamanager";
export class DynamicGraph {
    constructor() {
        // BOOKMARK_COLORS: string[] = colorSchemes.schema5;
        this.BOOKMARK_COLORS = this.default_colors;
        this.selectionColor_pointer = 0;
        //data: DataSet;
        this.name = ""; // INIT??
        // data meta data
        this.gran_min = 0; // INIT?
        this.gran_max = Number.MAX_VALUE; // INIT?
        this.minWeight = 10000000;
        this.maxWeight = -10000000;
        this._nodes = [];
        this._links = [];
        this.directed = false;
        this._nodePairs = [];
        this._locations = [];
        // Contains all time objects for this dynamic graph
        this._times = [];
        // linkTypes: LinkType[] = [];
        this.timeObjects = [];
        this.nodeOrders = []; // INIT?
        // Matrix for fast access to node pairs (link)
        this.matrix = []; // fast access to node pairs.
        this.selections = [];
        // node attributes
        this.nodeArrays = new NodeArray();
        // link attributes
        this.linkArrays = new LinkArray();
        // node pair attributes
        this.nodePairArrays = new NodePairArray();
        // time attributes
        this.timeArrays = new TimeArray();
        // array for relation types
        this.linkTypeArrays = new LinkTypeArray();
        // array for node types
        this.nodeTypeArrays = new NodeTypeArray();
        // array for locations
        this.locationArrays = new LocationArray();
        // points to all object arrays. For convenience
        this.attributeArrays = {
            node: this.nodeArrays,
            link: this.linkArrays,
            time: this.timeArrays,
            nodePair: this.nodePairArrays,
            linkType: this.linkTypeArrays,
            nodeType: this.nodeTypeArrays,
            location: this.locationArrays,
        };
        // highlighted objects
        this.highlightArrays = new IDCompound();
        this.currentSelection_id = 0;
        /* INIT OK?? */
        this.defaultLinkSelection = this.createSelection("link");
        this.defaultNodeSelection = this.createSelection("node");
        // storage keys /////////////////////////////////
        //
        this.gran_min_NAME = "gran_min";
        this.gran_max_NAME = "gran_max_NAME";
        this.directed_NAME = "directed_NAME";
        this.minWeight_NAME = "minWeight_NAME";
        this.maxWeight_NAME = "maxWeight_NAME";
        this.matrix_NAME = "matrix_NAME";
        this.nodeArrays_NAME = "nodeArrays_NAME";
        this.linkArrays_NAME = "linkArrays_NAME";
        this.nodePairArrays_NAME = "nodePairArrays_NAME";
        this.timeArrays_NAME = "timeArrays_NAME";
        this.linkTypeArrays_NAME = "linkTypeArrays_NAME";
        this.nodeTypeArrays_NAME = "nodeTypeArrays_NAME";
        this.locationArrays_NAME = "locationArrays_NAME";
    }
    default_colors(i) {
        const colors = [
            "#3366cc",
            "#dc3912",
            "#ff9900",
            "#109618",
            "#990099",
            "#0099c6",
            "#dd4477",
            "#66aa00",
            "#b82e2e",
            "#316395",
            "#994499",
            "#22aa99",
            "#aaaa11",
            "#6633cc",
            "#e67300",
            "#8b0707",
            "#651067",
            "#329262",
            "#5574a6",
            "#3b3eac",
        ];
        return colors[i % colors.length];
    }
    // ACCESSOR FUNCTIONS
    // universal accesor
    attr(field, id, type) {
        let r;
        try {
            r = this.attributeArrays[type][field][id];
        }
        catch (e) {
            r = undefined;
        }
        return r;
    }
    //
    // end storage keys //////////////////////////////
    // FUNCTIONS
    standardArrayReplacer(key, value) {
        // don't write out graph, as this would cause cycles
        if (value instanceof DynamicGraph) {
            console.log("standardReplacer found a DynamicGraph property", key);
            return DGRAPH_SUB;
        }
        // don't write out selection, because we must preserve it independently
        // from the graph
        else if (key == "selections")
            return undefined;
        return value;
    }
    static timeReviver(k, v, s) {
        if (k == "") {
            return copyPropsShallow(v, new Time(v.id, s));
        }
        else {
            return dgraphReviver(s, k, v);
        }
    }
    static nodeArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new NodeArray());
            // case 'nodeType':
            // return copyTimeSeries(v, function() { return new ScalarTimeSeries<string>(); });
            case "outLinks":
            case "inLinks":
            case "links":
                return copyTimeSeries(v, function () {
                    return new ArrayTimeSeries();
                });
            case "outNeighbors":
            case "inNeighbors":
            case "neighbors":
                return copyTimeSeries(v, function () {
                    return new ArrayTimeSeries();
                });
            case "locations":
                return copyTimeSeries(v, function () {
                    return new ScalarTimeSeries();
                });
            default:
                return v;
        }
    }
    static linkArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new LinkArray());
            case "weights":
                return copyTimeSeries(v, function () {
                    return new ScalarTimeSeries();
                });
            default:
                return v;
        }
    }
    static nodePairArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new NodePairArray());
            default:
                return v;
        }
    }
    static timeArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new TimeArray());
            case "time":
                return v.map(function (s, i) {
                    return moment.utc(s);
                });
            default:
                return v;
        }
    }
    static linkTypeArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new LinkTypeArray());
            default:
                return v;
        }
    }
    static nodeTypeArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new NodeTypeArray());
            default:
                return v;
        }
    }
    static locationArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new LocationArray());
            default:
                return v;
        }
    }
    loadDynamicGraph(dataMgr, dataSetName) {
        this.clearSelections();
        this.name = dataSetName;
        // CACHEGRAPH : load from storage the entire state of the graph
        const gran_min_storage = dataMgr.getFromStorage(this.name, this.gran_min_NAME);
        if (gran_min_storage != undefined)
            this.gran_min = gran_min_storage;
        const gran_max_storage = dataMgr.getFromStorage(this.name, this.gran_max_NAME);
        if (gran_max_storage != undefined)
            this.gran_max = gran_max_storage;
        const directed_storage = dataMgr.getFromStorage(this.name, this.directed_NAME);
        if (directed_storage != undefined)
            this.directed = directed_storage;
        const minWeight_storage = dataMgr.getFromStorage(this.name, this.minWeight_NAME);
        if (minWeight_storage != undefined)
            this.minWeight = minWeight_storage;
        const maxWeight_storage = dataMgr.getFromStorage(this.name, this.maxWeight_NAME);
        if (maxWeight_storage != undefined)
            this.maxWeight = maxWeight_storage;
        const matrix_storage = dataMgr.getFromStorage(this.name, this.matrix_NAME);
        if (matrix_storage != undefined)
            this.matrix = matrix_storage;
        const nodeArrays_storage = dataMgr.getFromStorage(this.name, this.nodeArrays_NAME, DynamicGraph.nodeArrayReviver);
        if (nodeArrays_storage != undefined)
            this.nodeArrays = nodeArrays_storage;
        const linkArrays_storage = dataMgr.getFromStorage(this.name, this.linkArrays_NAME, DynamicGraph.linkArrayReviver);
        if (linkArrays_storage != undefined)
            this.linkArrays = linkArrays_storage;
        const nodePairArrays_storage = dataMgr.getFromStorage(this.name, this.nodePairArrays_NAME, DynamicGraph.nodePairArrayReviver);
        if (nodePairArrays_storage != undefined)
            this.nodePairArrays = nodePairArrays_storage;
        const timeArrays_storage = dataMgr.getFromStorage(this.name, this.timeArrays_NAME, DynamicGraph.timeArrayReviver);
        if (timeArrays_storage != undefined)
            this.timeArrays = timeArrays_storage;
        if (!("timeArrays" in this) || !this.timeArrays) {
            console.log("No timeArrays");
            this.timeArrays = new TimeArray();
        }
        else if ("momentTime" in this.timeArrays &&
            "unixTime" in this.timeArrays) {
            const ta = this.timeArrays["momentTime"];
            for (let i = 0; i < ta.length; i++) {
                ta[i] = moment.utc(this.timeArrays["unixTime"][i]);
            }
        }
        else if ("unixTime" in this.timeArrays) {
            /* I DON'T KNOW WHY timeArrays IS never */
            console.log("No time in timeArrays");
            this.timeArrays["momentTime"] = this.timeArrays["unixTime"].map(moment.utc());
        }
        else {
            console.log("No time or unixTime in timeArrays");
            this.timeArrays["momentTime"] = [];
        }
        const linkTypeArrays_storage = dataMgr.getFromStorage(this.name, this.linkTypeArrays_NAME, DynamicGraph.linkTypeArrayReviver);
        if (linkTypeArrays_storage != undefined)
            this.linkTypeArrays = linkTypeArrays_storage;
        const nodeTypeArrays_storage = dataMgr.getFromStorage(this.name, this.nodeTypeArrays_NAME, DynamicGraph.nodeTypeArrayReviver);
        if (nodeTypeArrays_storage != undefined)
            this.nodeTypeArrays = nodeTypeArrays_storage;
        const locationArrays_storage = dataMgr.getFromStorage(this.name, this.locationArrays_NAME, DynamicGraph.locationArrayReviver);
        if (locationArrays_storage != undefined)
            this.locationArrays = locationArrays_storage;
        // points to all object arrays. For convenience
        this.attributeArrays = {
            node: this.nodeArrays,
            link: this.linkArrays,
            time: this.timeArrays,
            nodePair: this.nodePairArrays,
            linkType: this.linkTypeArrays,
            nodeType: this.nodeTypeArrays,
            location: this.locationArrays,
        };
        // rather than persist all of the state of windowGraph
        // as well, we simply reinitialize from our persisted state.
        // perhaps we need to serialize this as well.
        // inits the WindowGraph for this dynamic graph, i.e.
        // the all-aggregated graph.
        this.createGraphObjects(true, true);
        // init the selections which are currently null
        // this.nodeArrays.selections=[];
        // this.nodeArrays.selections.push([]);
        // this.timeArrays.selections=[];
        // this.timeArrays.selections.push([]);
        // this.linkArrays.selections=[];
        // this.linkArrays.selections.push([]);
        // this.nodePairArrays.selections=[];
        // this.nodePairArrays.selections.push([]);
        this.createSelections(true);
    }
    saveDynamicGraph(dataMgr) {
        // CACHEGRAPH : persist the entire state of the dynamic graph
        dataMgr.saveToStorage(this.name, this.gran_min_NAME, this.gran_min);
        dataMgr.saveToStorage(this.name, this.gran_max_NAME, this.gran_max);
        dataMgr.saveToStorage(this.name, this.directed_NAME, this.directed);
        dataMgr.saveToStorage(this.name, this.minWeight_NAME, this.minWeight);
        dataMgr.saveToStorage(this.name, this.maxWeight_NAME, this.maxWeight);
        dataMgr.saveToStorage(this.name, this.matrix_NAME, this.matrix);
        dataMgr.saveToStorage(this.name, this.nodeArrays_NAME, this.nodeArrays, this.standardArrayReplacer);
        // when we tried to persist the entire linkArrays, javascript threw an
        // exception, so for now we will simply try to save out the parts.
        dataMgr.saveToStorage(this.name, this.linkArrays_NAME, this.linkArrays, this.standardArrayReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"source", this.linkArrays.source, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"target", this.linkArrays.target, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"linkType", this.linkArrays.linkType, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"directed", this.linkArrays.directed, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"nodePair", this.linkArrays.nodePair, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"presence", this.linkArrays.presence, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"weights", this.linkArrays.weights, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"filter", this.linkArrays.filter, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"attributes", this.linkArrays.attributes, this.standardReplacer);
        dataMgr.saveToStorage(this.name, this.nodePairArrays_NAME, this.nodePairArrays, this.standardArrayReplacer);
        dataMgr.saveToStorage(this.name, this.timeArrays_NAME, this.timeArrays, this.standardArrayReplacer);
        dataMgr.saveToStorage(this.name, this.linkTypeArrays_NAME, this.linkTypeArrays, this.standardArrayReplacer);
        dataMgr.saveToStorage(this.name, this.nodeTypeArrays_NAME, this.nodeTypeArrays, this.standardArrayReplacer);
        dataMgr.saveToStorage(this.name, this.locationArrays_NAME, this.locationArrays, this.standardArrayReplacer);
    }
    // Removes this graph from the cache.
    delete(dataMgr) {
        dataMgr.removeFromStorage(this.name, this.gran_min_NAME);
        dataMgr.removeFromStorage(this.name, this.gran_max_NAME);
        dataMgr.removeFromStorage(this.name, this.directed_NAME);
        dataMgr.removeFromStorage(this.name, this.minWeight_NAME);
        dataMgr.removeFromStorage(this.name, this.maxWeight_NAME);
        dataMgr.removeFromStorage(this.name, this.matrix_NAME);
        dataMgr.removeFromStorage(this.name, this.nodeArrays_NAME);
        // when we tried to persist the entire linkArrays, javascript threw an
        // exception, so for now we will simply try to save out the parts.
        dataMgr.removeFromStorage(this.name, this.linkArrays_NAME);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"source", this.linkArrays.source, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"target", this.linkArrays.target, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"linkType", this.linkArrays.linkType, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"directed", this.linkArrays.directed, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"nodePair", this.linkArrays.nodePair, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"presence", this.linkArrays.presence, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"weights", this.linkArrays.weights, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"filter", this.linkArrays.filter, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"attributes", this.linkArrays.attributes, this.standardReplacer);
        dataMgr.removeFromStorage(this.name, this.nodePairArrays_NAME);
        dataMgr.removeFromStorage(this.name, this.timeArrays_NAME);
        dataMgr.removeFromStorage(this.name, this.linkTypeArrays_NAME);
        dataMgr.removeFromStorage(this.name, this.nodeTypeArrays_NAME);
        dataMgr.removeFromStorage(this.name, this.locationArrays_NAME);
    }
    debugCompareTo(other) {
        let result = true;
        if (this.name != other.name) {
            console.log("name different");
            result = false;
        }
        // CACHEGRAPH compare every aspect of this one to the other one
        if (this.gran_min != other.gran_min) {
            console.log("gran_min different", this.gran_min, other.gran_min);
            result = false;
        }
        if (this.gran_max != other.gran_max) {
            console.log("gran_max different", this.gran_max, other.gran_max);
            result = false;
        }
        if (this.directed != other.directed) {
            console.log("directed different", this.directed, other.directed);
            result = false;
        }
        if (this._nodes.length != other._nodes.length ||
            !compareTypesDeep(this._nodes, other._nodes, 2)) {
            console.log("nodes different");
            result = false;
        }
        if (this._links.length != other._links.length ||
            !compareTypesDeep(this._links, other._links, 2)) {
            console.log("links different");
            result = false;
        }
        if (this._nodePairs.length != other._nodePairs.length ||
            !compareTypesDeep(this._nodePairs, other._nodePairs, 2)) {
            console.log("nodePairs different");
            result = false;
        }
        if (this._locations.length != other._locations.length ||
            !compareTypesDeep(this._locations, other._locations, 2)) {
            console.log("locations different");
            result = false;
        }
        if (this._times.length != other._times.length ||
            !compareTypesDeep(this._times, other._times, 2)) {
            console.log("times different");
            result = false;
        }
        if ((this.nodeOrders && this.nodeOrders.length != other.nodeOrders.length) ||
            !compareTypesDeep(this.nodeOrders, other.nodeOrders, 2)) {
            console.log("nodeOrders different", this.nodeOrders, other.nodeOrders);
            result = false;
        }
        if (this.matrix.length != other.matrix.length ||
            !compareTypesDeep(this.matrix, other.matrix, 2)) {
            console.log("matrix different", this.matrix, other.matrix);
            result = false;
        }
        if (this.nodeArrays.length != other.nodeArrays.length ||
            !compareTypesDeep(this.nodeArrays, other.nodeArrays, 2)) {
            console.log("nodeArrays different", this.nodeArrays, other.nodeArrays);
            result = false;
        }
        if (this.linkArrays.length != other.linkArrays.length ||
            !compareTypesDeep(this.linkArrays, other.linkArrays, 2)) {
            console.log("linkArrays different", this.linkArrays, other.linkArrays);
            result = false;
        }
        if (this.nodePairArrays.length != other.nodePairArrays.length ||
            !compareTypesDeep(this.nodePairArrays, other.nodePairArrays, 2)) {
            console.log("nodePairArrays different", this.nodePairArrays, other.nodePairArrays);
            result = false;
        }
        if (this.timeArrays.length != other.timeArrays.length ||
            !compareTypesDeep(this.timeArrays, other.timeArrays, 2)) {
            console.log("timeArrays different", this.timeArrays, other.timeArrays);
            result = false;
        }
        if (this.linkTypeArrays.length != other.linkTypeArrays.length ||
            !compareTypesDeep(this.linkTypeArrays, other.linkTypeArrays, 2)) {
            console.log("linkTypeArrays different", this.linkTypeArrays, other.linkTypeArrays);
            result = false;
        }
        if (this.nodeTypeArrays.length != other.nodeTypeArrays.length ||
            !compareTypesDeep(this.nodeTypeArrays, other.nodeTypeArrays, 2)) {
            console.log("nodeTypeArrays different", this.nodeTypeArrays, other.nodeTypeArrays);
            result = false;
        }
        if (this.locationArrays.length != other.locationArrays.length ||
            !compareTypesDeep(this.locationArrays, other.locationArrays, 2)) {
            console.log("locationArrays different", this.locationArrays, other.locationArrays);
            result = false;
        }
        if (this.defaultLinkSelection.elementIds.length !=
            other.defaultLinkSelection.elementIds.length ||
            !compareTypesDeep(this.defaultLinkSelection, other.defaultLinkSelection, 2)) {
            console.log("defaultLinkSelection different", this.defaultLinkSelection, other.defaultLinkSelection);
            result = false;
        }
        if (this.defaultNodeSelection.elementIds.length !=
            other.defaultNodeSelection.elementIds.length ||
            !compareTypesDeep(this.defaultNodeSelection, other.defaultNodeSelection, 2)) {
            console.log("defaultNodeSelection different", this.defaultNodeSelection, other.defaultNodeSelection);
            result = false;
        }
        if (this.selections.length != other.selections.length ||
            !compareTypesDeep(this.selections, other.selections, 2)) {
            console.log("selections different", this.selections, other.selections);
            result = false;
        }
        return result;
    }
    // creates this graph and fills node, link and time arrays from
    // data tables.
    initDynamicGraph(data) {
        // must agree with version in main.ts
        const TIME_FORMAT = "YYYY-MM-DD hh:mm:ss";
        this.clearSelections();
        console.log("[dynamicgraph.ts] Create dynamic graph for ", data.name, data);
        //this.data = data;s
        this.name = data.name;
        this.directed = data.directed;
        // fill node, link arrays and time
        // CREATE TIME OBJECT for all events
        this.gran_min = 0;
        this.gran_max = 0;
        let timeLabel;
        const unixTimes = [];
        let unixTime;
        if (isValidIndex(data.linkSchema.time)) {
            // get unix times for all times
            console.log("GEtting unix times for all times - linktable");
            console.log(data.linkTable);
            for (let i = 0; i < data.linkTable.length; i++) {
                timeLabel = data.linkTable[i][data.linkSchema.time];
                console.log(data.linkTable[i]);
                unixTime = parseInt(moment.utc(timeLabel, TIME_FORMAT).format("x"));
                if (unixTime == undefined)
                    continue;
                if (unixTimes.indexOf(unixTime) == -1) {
                    unixTimes.push(unixTime);
                }
            }
            // obtain granularity
            unixTimes.sort(sortNumber);
            let diff = 99999999999999;
            for (let i = 0; i < unixTimes.length - 2; i++) {
                diff = Math.min(diff, unixTimes[i + 1] - unixTimes[i]);
            }
            const diff_min = diff;
            if (diff >= 1000)
                this.gran_min = 1;
            if (diff >= 1000 * 60)
                this.gran_min = 2;
            if (diff >= 1000 * 60 * 60)
                this.gran_min = 3;
            if (diff >= 1000 * 60 * 60 * 24)
                this.gran_min = 4;
            if (diff >= 1000 * 60 * 60 * 24 * 7)
                this.gran_min = 5;
            if (diff >= 1000 * 60 * 60 * 24 * 30)
                this.gran_min = 6;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12)
                this.gran_min = 7;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 10)
                this.gran_min = 8;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 100)
                this.gran_min = 9;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 1000)
                this.gran_min = 10;
            diff = unixTimes[unixTimes.length - 1] - unixTimes[0];
            this.gran_max = 0;
            if (diff >= 1000)
                this.gran_max = 1;
            if (diff >= 1000 * 60)
                this.gran_max = 2;
            if (diff >= 1000 * 60 * 60)
                this.gran_max = 3;
            if (diff >= 1000 * 60 * 60 * 24)
                this.gran_max = 4;
            if (diff >= 1000 * 60 * 60 * 24 * 7)
                this.gran_max = 5;
            if (diff >= 1000 * 60 * 60 * 24 * 30)
                this.gran_max = 6;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12)
                this.gran_max = 7;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 10)
                this.gran_max = 8;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 100)
                this.gran_max = 9;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 1000)
                this.gran_max = 10;
            console.log("[Dynamic Graph] Minimal granularity", GRANULARITY[this.gran_min]);
            console.log("[Dynamic Graph] Maximal granularity", GRANULARITY[this.gran_max]);
            // create one time object for every time point of gran_min, between start and end time.
            // [bb] deprecated
            // var start = moment(unixTimes[0] + '', 'x').startOf(GRANULARITY[this.gran_min]);
            // var end = moment(unixTimes[unixTimes.length - 1] + '', 'x').startOf(GRANULARITY[this.gran_min]);
            // var numTimes = Math.ceil(Math.abs(start.diff(end, GRANULARITY[this.gran_min] + 's')));
            // var curr_t = start;
            // this._times = [];
            for (let i = 0; i < unixTimes.length; i++) {
                this.timeArrays.id.push(i);
                this.timeArrays.momentTime.push(moment.utc(unixTimes[i]));
                this.timeArrays.label.push(this.timeArrays.momentTime[i].format(TIME_FORMAT));
                this.timeArrays.unixTime.push(unixTimes[i]);
                this.timeArrays.selections.push([]);
                this.timeArrays.filter.push(false);
                this.timeArrays.links.push([]);
                // create time objects
                this._times.push(new Time(i, this));
                // curr_t = start.add(1, GRANULARITY[this.gran_min] + 's');
            }
            // Now, all existing times with events and potentially
            // attributes associated, have been created.
            // Below, we create a simple array of moment.moments
            // for any possible time unit for every aggregation level.
            // In fact, those structures are created on-demand, i.e.
            // the first time they are needed.
            // Here, we only create the meta-structure
            for (let g = 0; g <= GRANULARITY.length; g++) {
                this.timeObjects.push([]); // AQUIIIII
            }
        }
        // if no valid have been found:
        if (this.timeArrays.length == 0) {
            // null time object that represents one time step for the entire graph, i.e. a static graph
            this.timeArrays.id.push(0);
            this.timeArrays.momentTime.push(moment.utc(0));
            this.timeArrays.unixTime.push(0);
            this.timeArrays.selections.push([]);
            this.timeArrays.filter.push(false);
            this.timeArrays.links.push([]);
            this._times.push(new Time(0, this));
        }
        // from here on, there is at least one time object present.
        // CREATE LOCATIONS
        let id_loc;
        let location;
        // if there is a location table, then there needs to be locationSchema
        console.assert(!data.locationTable || isValidIndex(data.locationSchema.id));
        if (data.locationTable) {
            for (let i = 0; i < data.locationTable.length; i++) {
                this.locationArrays.id.push(data.locationTable[i][data.locationSchema.id]);
                this.locationArrays.label.push(data.locationTable[i][data.locationSchema.label]);
                this.locationArrays.longitude.push(data.locationTable[i][data.locationSchema.longitude]);
                this.locationArrays.latitude.push(data.locationTable[i][data.locationSchema.latitude]);
                this.locationArrays.x.push(data.locationTable[i][data.locationSchema.x]);
                this.locationArrays.y.push(data.locationTable[i][data.locationSchema.y]);
                this.locationArrays.z.push(data.locationTable[i][data.locationSchema.z]);
                this.locationArrays.radius.push(data.locationTable[i][data.locationSchema.radius]);
            }
        }
        if ("id" in this.locationArrays)
            console.log("locations", this.locationArrays.id.length);
        // CREATE NODES
        let row;
        let nodeId_data; // node id in data set
        let nodeId_table; // node id in table
        let attribute;
        let time;
        console.assert(data.nodeTable.length == 0 || isValidIndex(data.nodeSchema.id), "either there is no nodeTable data, or we have a schema for the nodetable");
        let typeName;
        let typeId;
        const nodeUserProperties = [];
        // Get user-properties on links, if exist
        for (const prop in data.nodeSchema) {
            if (Object.prototype.hasOwnProperty.call(data.nodeSchema, prop) &&
                prop != "id" &&
                prop != "label" &&
                prop != "time" &&
                prop != "name" &&
                prop != "nodeType" &&
                prop != "location" &&
                prop != "constructor") {
                nodeUserProperties.push(prop);
                // create property
                this.nodeArrays[prop] = [];
            }
        }
        for (let i = 0; i < data.nodeTable.length; i++) {
            row = data.nodeTable[i];
            // check if id already exists
            nodeId_data = row[data.nodeSchema.id];
            nodeId_table = this.nodeArrays.id.indexOf(nodeId_data);
            if (nodeId_table == -1) {
                nodeId_table = this.nodeArrays.id.length;
                this.nodeArrays.id.push(nodeId_data);
                this.nodeArrays.nodeType.push("");
                this.nodeArrays.outLinks.push(new ArrayTimeSeries());
                this.nodeArrays.inLinks.push(new ArrayTimeSeries());
                this.nodeArrays.links.push(new ArrayTimeSeries()); // both, in and out
                this.nodeArrays.outNeighbors.push(new ArrayTimeSeries());
                this.nodeArrays.inNeighbors.push(new ArrayTimeSeries());
                this.nodeArrays.neighbors.push(new ArrayTimeSeries());
                this.nodeArrays.selections.push([]);
                this.nodeArrays.filter.push(false);
                this.nodeArrays.locations.push(new ScalarTimeSeries());
                this.nodeArrays.attributes.push(new Object());
                this.nodeArrays.color.push("");
                this.nodeArrays.shape.push("");
                if (isValidIndex(data.nodeSchema.label)) {
                    this.nodeArrays.label.push(row[data.nodeSchema.label]);
                }
                else {
                    this.nodeArrays.label.push(row[data.nodeSchema.id]);
                }
            }
            // get time
            // if (isValidIndex(data.nodeSchema.time)) {
            if (isValidIndex(data.nodeSchema.time)) {
                timeLabel = row[data.nodeSchema.time];
                console.log("params");
                console.log(timeLabel);
                console.log(TIME_FORMAT);
                console.log(moment.utc(timeLabel, TIME_FORMAT));
                console.log(moment.utc(timeLabel, TIME_FORMAT).format("x"));
                const timeIdForUnixTime = this.getTimeIdForUnixTime(parseInt(moment.utc(timeLabel, TIME_FORMAT).format("x")));
                if (timeLabel == undefined || timeIdForUnixTime == undefined) {
                    //} || timeStamp.indexOf('null')) {
                    time = this._times[0];
                }
                else {
                    time = this._times[timeIdForUnixTime];
                }
            }
            else {
                time = this._times[0];
            }
            if (time == undefined)
                time = this._times[0];
            // check locations
            if (isValidIndex(data.nodeSchema.location)) {
                const locId = row[data.nodeSchema.location];
                if (locId == null || locId == undefined)
                    continue;
                this.nodeArrays.locations[nodeId_data].set(time, locId);
            }
            // check shapes
            if (isValidIndex(data.nodeSchema.shape)) {
                const shape = row[data.nodeSchema.shape];
                this.nodeArrays.shape.push(shape);
            }
            // gather node type
            if (isValidIndex(data.nodeSchema.nodeType)) {
                typeName = data.nodeTable[i][data.nodeSchema.nodeType];
                typeId = this.nodeTypeArrays.name.indexOf(typeName);
                if (typeId < 0) {
                    typeId = this.nodeTypeArrays.length;
                    this.nodeTypeArrays.id.push(typeId);
                    this.nodeTypeArrays.name.push(typeName);
                }
                this.nodeArrays.nodeType[nodeId_table] = typeName;
                data.nodeTable[i][data.nodeSchema.nodeType] = typeId;
            }
            // gather user-properties:
            for (let p = 0; p < nodeUserProperties.length; p++) {
                const prop = nodeUserProperties[p];
                this.nodeArrays[prop].push(row[data.nodeSchema[prop]]);
            }
            // see if temporal information is available
            // if(data.nodeSchema.time && data.nodeSchema.time > -1){
            //     for(var field in data.nodeSchema){
            //         if (field != undefined
            //             && data.nodeSchema.hasOwnProperty(field)
            //             && data.Â©nodeSchema[field] > -1
            //             && field != 'label'
            //             && field != 'time'
            //             && field != 'locations'
            //             && field != 'id'
            //             ){
            //                 if(this.nodeArrays.attributes[nodeId_table][field] == undefined){
            //                     this.nodeArrays.attributes[nodeId_table][field] = new ScalarTimeSeries();
            //                 }
            //                 timeLabel = data.nodeTable[i][data.nodeSchema.time];
            //                 if(timeLabel == undefined)
            //                     continue;
            //                 timeStamp = parseInt(moment(timeLabel, networkcube.TIME_FORMAT).format('x'));
            //                 time = this.times[this.getTimeIdForTimeStamp(timeStamp)];
            //                 this.nodeArrays[field][nodeId_table].set(time, row[data.nodeSchema[field]]);
            //             // //in case of locations:
            //             // if(field == 'location'){
            //             //     if(typeof row[data.nodeSchema[field]] == 'number'){
            //             //         id_loc = row[data.nodeSchema[field]];
            //             //     }
            //             // }
            //          }
            //     }
            // }else{
            //     // no time information available on nodes
            //     for(var field in data.nodeSchema){
            //         if (field != undefined
            //             && data.nodeSchema.hasOwnProperty(field)
            //             && data.nodeSchema[field] > -1
            //             && field != 'label'
            //             && field != 'time'
            //             && field != 'id'
            //             && field != 'locations'
            //             )
            //         {
            //             // check for non temporal information
            //             if(this.nodeArrays.attributes[nodeId_table][field] == undefined){
            //                 this.nodeArrays.attributes[nodeId_table][field] = new ScalarTimeSeries();
            //             }
            //             // eternal attributes are assigned no time.
            //             this.nodeArrays[field][nodeId_table].set(undefined, row[data.nodeSchema[field]]);
            //         }
            //     }
            // }
        }
        // create matrix and initialize with -1, i.e. nodes are not connected.
        if ("id" in this.nodeArrays) {
            for (let i = 0; i < this.nodeArrays.id.length; i++) {
                this.matrix.push(array(undefined, this.nodeArrays.id.length));
            }
        }
        // CREATE LINKS
        let s, t;
        let id;
        let timeId;
        let nodePairId;
        let linkId;
        const linkUserProperties = [];
        // Get user-properties on links, if exist
        for (const prop in data.linkSchema) {
            if (Object.prototype.hasOwnProperty.call(data.linkSchema, prop) &&
                prop != "id" &&
                prop != "linkType" &&
                prop != "time" &&
                prop != "name" &&
                prop != "source" &&
                prop != "target" &&
                prop != "weight" &&
                prop != "directed") {
                linkUserProperties.push(prop);
                // create property
                this.linkArrays[prop] = [];
            }
        }
        console.log("linkUserProperties", linkUserProperties);
        console.assert(data.linkTable.length == 0 ||
            (isValidIndex(data.linkSchema.id) &&
                isValidIndex(data.linkSchema.source) &&
                isValidIndex(data.linkSchema.target)), "either there are no links, or the linkschema is defined");
        for (let i = 0; i < data.linkTable.length; i++) {
            row = data.linkTable[i];
            linkId = row[data.linkSchema.id];
            this.linkArrays.directed.push(false); // this is default and can be overwritten in the following.
            // check if linkId, i.e. link exists
            if (this.linkArrays.id.indexOf(linkId) == -1) {
                // init new link
                this.linkArrays.id[linkId] = linkId;
                this.linkArrays.source[linkId] = row[data.linkSchema.source];
                this.linkArrays.target[linkId] = row[data.linkSchema.target];
                this.linkArrays.linkType[linkId] = row[data.linkSchema.linkType];
                this.linkArrays.directed[linkId] = row[data.linkSchema.directed];
                this.linkArrays.weights[linkId] = new ScalarTimeSeries();
                this.linkArrays.presence[linkId] = [];
                this.linkArrays.selections.push([]);
                this.linkArrays.nodePair.push(undefined);
                this.linkArrays.filter.push(false);
            }
            // set time information
            if (isValidIndex(data.linkSchema.time)) {
                timeLabel = data.linkTable[i][data.linkSchema.time];
                unixTime = parseInt(moment.utc(timeLabel, TIME_FORMAT).format("x"));
                const timeIdForUnixTime = this.getTimeIdForUnixTime(unixTime);
                if (timeIdForUnixTime != undefined) {
                    timeId = timeIdForUnixTime;
                }
                else {
                    timeId = 0;
                }
            }
            else {
                timeId = 0;
            }
            time = this._times[timeId];
            this.linkArrays.presence[linkId].push(timeId);
            // set weight if applies
            if (isValidIndex(data.linkSchema.weight) &&
                data.linkTable[i][data.linkSchema.weight] != undefined) {
                this.linkArrays.weights[linkId].set(time, data.linkTable[i][data.linkSchema.weight]);
                this.minWeight = Math.min(this.minWeight, data.linkTable[i][data.linkSchema.weight]);
                this.maxWeight = Math.max(this.maxWeight, data.linkTable[i][data.linkSchema.weight]);
            }
            else {
                // set one = presence
                this.minWeight = 0;
                this.maxWeight = 1;
                this.linkArrays.weights[linkId].set(time, 1);
            }
            // add graph specific information
            s = this.nodeArrays.id.indexOf(row[data.linkSchema.source]);
            t = this.nodeArrays.id.indexOf(row[data.linkSchema.target]);
            this.nodeArrays.neighbors[s].add(time, t);
            this.nodeArrays.neighbors[t].add(time, s);
            this.nodeArrays.links[s].add(time, linkId);
            this.nodeArrays.links[t].add(time, linkId);
            // for directed links, fill the in/out arrays
            if (this.linkArrays.directed[i]) {
                this.nodeArrays.outNeighbors[s].add(time, t);
                this.nodeArrays.inNeighbors[t].add(time, s);
                this.nodeArrays.outLinks[s].add(time, linkId);
                this.nodeArrays.inLinks[t].add(time, linkId);
            }
            //link pairs
            // a node pair is stored in a matrix structure for easy access.
            // For every direction (s,t) and (t,s), an individual link pair
            // exists. If an underlying link is undirected, it is referenced
            // in both node pairs.
            nodePairId = this.matrix[s][t];
            if (!isValidIndex(nodePairId)) {
                nodePairId = this.nodePairArrays.length;
                this.matrix[s][t] = nodePairId;
                this.nodePairArrays.id.push(nodePairId);
                this.nodePairArrays.source.push(s);
                this.nodePairArrays.target.push(t);
                this.nodePairArrays.links.push([]);
                this.nodePairArrays.selections.push([]);
                this.nodePairArrays.filter.push(false);
            }
            // add link only, if not already exist
            if (this.nodePairArrays.links[nodePairId].indexOf(linkId) == -1) {
                this.nodePairArrays.links[nodePairId].push(linkId);
                this.linkArrays.nodePair[linkId] = nodePairId;
            }
            //May affect matrix view, but breaks nodelink directionality
            // if (this.linkArrays.directed[i]) {
            //     nodePairId = this.matrix[t][s];
            //     if (!nodePairId) {
            //         nodePairId = this.nodePairArrays.id.length;
            //         this.matrix[t][s] = nodePairId;
            //         this.nodePairArrays.id.push(nodePairId);
            //         this.nodePairArrays.source.push(t);
            //         this.nodePairArrays.target.push(s);
            //         this.nodePairArrays.links.push(doubleArray(this._times.length));
            //     }
            //     // add link only, if not already exist
            //     if (this.nodePairArrays.links[nodePairId].indexOf(linkId) == -1) {
            //         this.nodePairArrays.links[nodePairId].push(linkId);
            //         this.linkArrays.nodePair[linkId] = nodePairId;
            //     }
            // }
            // gather link types
            if (isValidIndex(data.linkSchema.linkType)) {
                typeName = data.linkTable[i][data.linkSchema.linkType];
                typeId = this.linkTypeArrays.name.indexOf(typeName);
                if (typeId < 0) {
                    typeId = this.linkTypeArrays.length;
                    this.linkTypeArrays.id.push(typeId);
                    this.linkTypeArrays.name.push(typeName);
                }
                data.linkTable[i][data.linkSchema.linkType] = typeId;
            }
            // gather user-properties:
            for (let p = 0; p < linkUserProperties.length; p++) {
                const prop = linkUserProperties[p];
                this.linkArrays[prop].push(row[data.linkSchema[prop]]);
            }
        }
        // For every time, store a pointer to all its links:
        // var allLinks = links().toArray();
        // var allTimes = this.g.times().toArray();
        for (let i = 0; i < this.linkArrays.length; i++) {
            for (let j = 0; j < this.timeArrays.length; j++) {
                if (this.linkArrays.weights[i]) {
                    if (Object.prototype.hasOwnProperty.call(this.linkArrays.weights[i].toArray(), this.timeArrays.id[j].toString())) {
                        this.timeArrays.links[j].push(this.linkArrays.id[i]);
                    }
                }
            }
        }
        //Build a color mapping
        const colorSet = new Set([
            "#e4549b",
            "#a33a36",
            "#bd6221",
            "#dfba47",
            "#b5b867",
            "#479b7f",
            "#335b8e",
            "#78387d",
        ]);
        const colorMappings = {};
        this.nodeArrays.color.forEach(function (color) {
            if (!colorMappings[color]) {
                const colorSetAsArray = Array.from(colorSet);
                const generatedColor = colorSetAsArray[Math.floor(Math.random() * colorSetAsArray.length)];
                colorMappings[color] = generatedColor;
                colorSet.delete(generatedColor);
            }
        });
        //Add color values to nodeArray colors
        /*
            for(let i=0; i<this.nodeArrays.color.length; i++) {
                this.nodeArrays.color[i] = this.nodeArrays.color[i], colorMappings[this.nodeArrays.color[i]];
            }
            */
        //Build a shape mapping
        const shapeSet = new Set(["cross", "diamond", "square", "triangle"]);
        const shapeMappings = {};
        this.nodeArrays.shape.forEach(function (shape) {
            if (!shapeMappings[shape]) {
                const shapeSetAsArray = Array.from(shapeSet);
                const generatedShape = shapeSetAsArray[Math.floor(Math.random() * shapeSetAsArray.length)];
                shapeMappings[shape] = generatedShape;
                shapeSet.delete(generatedShape);
            }
        });
        //Add shapes to nodeArray shapes
        /*
            for(let i=0; i<this.nodeArrays.shape.length; i++) {
                this.nodeArrays.shape[i] = this.nodeArrays.shape[i], shapeMappings[this.nodeArrays.shape[i]];
            }
            */
        // create color map for link types
        const linkTypeCount = this.linkTypeArrays.length;
        console.log("[Dynamic Graph] Dynamic Graph created: ", this.nodeArrays.length);
        console.log("[Dynamic Graph]    - Nodes: ", this.nodeArrays.length);
        console.log("[Dynamic Graph]    - Edges: ", this.linkArrays.length);
        console.log("[Dynamic Graph]    - Times: ", this.timeArrays.length);
        console.log("[Dynamic Graph]    - Link types: ", this.linkTypeArrays.length);
        console.log("[Dynamic Graph]    - Node Pairs: ", this.nodePairArrays.length);
        console.log('>>>this.nodeArrays["neighbors"][0]', this.nodeArrays["neighbors"][0]);
        // inits the WindowGraph for this dynamic graph, i.e.
        // the all-aggregated graph.
        this.createGraphObjects(true, true); //false, false);
        this.createSelections(false);
    }
    createSelections(shouldCreateArrays) {
        // CREATE SELECTIONS
        if (shouldCreateArrays) {
            if (!("nodeArrays" in this && this.nodeArrays)) {
                this.nodeArrays = new NodeArray();
                this.linkArrays = new LinkArray();
                this.timeArrays = new TimeArray();
                this.nodePairArrays = new NodePairArray();
            }
            this.nodeArrays.selections = new Array(this.nodeArrays.length);
            for (let i = 0; i < this.nodeArrays.selections.length; i++) {
                this.nodeArrays.selections[i] = [];
            }
            this.linkArrays.selections = new Array(this.linkArrays.length);
            for (let i = 0; i < this.linkArrays.selections.length; i++) {
                this.linkArrays.selections[i] = [];
            }
            this.timeArrays.selections = new Array(this.timeArrays.length);
            for (let i = 0; i < this.timeArrays.selections.length; i++) {
                this.timeArrays.selections[i] = [];
            }
            this.nodePairArrays.selections = new Array(this.nodePairArrays.length);
            for (let i = 0; i < this.nodePairArrays.selections.length; i++) {
                this.nodePairArrays.selections[i] = [];
            }
        }
        // create default selections for each type
        this.defaultNodeSelection = this.createSelection("node");
        this.defaultNodeSelection.name = "Unselected";
        for (let i = 0; i < this._nodes.length; i++) {
            this.defaultNodeSelection.elementIds.push(i);
            this.addToAttributeArraysSelection(this.defaultNodeSelection, "node", this._nodes[i].id());
        }
        this.defaultNodeSelection.color = "#000000";
        this.defaultNodeSelection.showColor = false;
        this.defaultNodeSelection.priority = 10000;
        this.selectionColor_pointer--;
        this.defaultLinkSelection = this.createSelection("link");
        this.defaultLinkSelection.name = "Unselected";
        for (let i = 0; i < this._links.length; i++) {
            this.defaultLinkSelection.elementIds.push(i);
            this.addToAttributeArraysSelection(this.defaultLinkSelection, "link", this._links[i].id());
        }
        this.defaultLinkSelection.color = "#000000";
        this.defaultLinkSelection.showColor = false;
        this.defaultLinkSelection.priority = 10000;
        this.selectionColor_pointer--;
        // create selections for node types
        let types = [];
        let type, index;
        let selection;
        const nodeSelections = [];
        for (let i = 0; i < this.nodeArrays.nodeType.length; i++) {
            type = this.nodeArrays.nodeType[i];
            if (type == undefined || type.length == 0 || type == "undefined")
                continue;
            index = types.indexOf(type);
            if (index == -1) {
                selection = this.createSelection("node");
                selection.name = type;
                nodeSelections.push(selection);
                types.push(type);
            }
            else {
                selection = nodeSelections[index];
            }
            this.addElementToSelection(selection, this._nodes[i]);
            // this.addToSelection(selection, this._nodes[i].id(), 'node');
        }
        if (nodeSelections.length == 1) {
            console.log("nodeSelections[0]:", nodeSelections[0]);
            nodeSelections[0].color = "#444";
        }
        // create selections for link type
        types = [];
        const linkSelections = [];
        for (let i = 0; i < this.linkArrays.linkType.length; i++) {
            type = this.linkArrays.linkType[i];
            if (!type || type == "undefined")
                continue;
            index = types.indexOf(type);
            if (index == -1) {
                selection = this.createSelection("link");
                selection.name = type;
                linkSelections.push(selection);
                types.push(type);
            }
            else {
                selection = linkSelections[index];
            }
            this.addElementToSelection(selection, this._links[i]);
            // this.addToSelection(selection, this._links[i].id(), 'link');
        }
        if (linkSelections.length == 1)
            linkSelections[0].color = "#444";
        // create selections for node type
        // types = [];
        // var nodeSelections: Selection[] = [];
        // for (var i = 0; i < this.nodeArrays.nodeType.length; i++) {
        //     type = this.nodeArrays.nodeType[i];
        //     if (!type || type == 'undefined')
        //         continue;
        //     index = types.indexOf(type);
        //     if (index == -1) {
        //         selection = this.createSelection('node');
        //         selection.name = type;
        //         nodeSelections.push(selection)
        //         types.push(type);
        //     } else {
        //         selection = nodeSelections[index];
        //     }
        //     this.addElementToSelection(selection, this._nodes[i]);
        //     // this.addToSelection(selection, this._links[i].id(), 'link');
        // }
        this.currentSelection_id = 0;
    }
    // GRAPH API //////////////////
    /**
     *
     * Returns a window graph for the passed time point
     * or period
     * @param  {any}    start First time point of this graph
     * @param  {any}    end   Last time point of this graph.
     * @return {[type]}       [description]
     */
    // getGraph(start: Time, end?: Time): WindowGraph {
    //     var g: WindowGraph = new WindowGraph();
    //     return this.createGraph(g, start, end);
    // }
    // Creates a new graph with all nodes and edges from start to end.
    // CACHEGRAPH : this code needs to be leveraged to initialize all of the fields from
    // windowGraph that are now part of this class
    createGraphObjects(shouldCreateTimes, shouldCreateLinkTypes) {
        // measure time:
        console.log("[DynamicNetwork:createGraph()] >>> ");
        const d = Date.now();
        // POPULATE WINDOW GRAPH
        // populate locations
        if (this.locationArrays && "id" in this.locationArrays) {
            for (let i = 0; i < this.locationArrays.id.length; i++) {
                this._locations.push(new Location(this.locationArrays.id[i], this));
            }
        }
        else {
            this.locationArrays = new LocationArray();
        }
        // Populate nodes
        const nodes = [];
        let locations;
        if ("nodeArrays" in this && this.nodeArrays) {
            for (let i = 0; i < this.nodeArrays.id.length; i++) {
                nodes.push(new Node(i, this));
            }
        }
        // Populate links
        const links = [];
        let link;
        let source, target;
        if ("linkArrays" in this && this.linkArrays) {
            for (let i = 0; i < this.linkArrays.source.length; i++) {
                link = new Link(i, this);
                links.push(link);
            }
        }
        // Populate node pairs
        let s, t;
        let pairLinks;
        let pair;
        let pairLinkId;
        const thisGraphNodePairIds = [];
        if ("nodePairArrays" in this && this.nodePairArrays) {
            for (let i = 0; i < this.nodePairArrays.length; i++) {
                pairLinks = this.nodePairArrays.links[i];
                this._nodePairs.push(new NodePair(i, this));
                // for (var j = 0; j < pairLinks.length; j++) {
                //     pairLinkId = pairLinks[j];
                //     pair = undefined;
                //     for (var k = 0; k < nodePairs.length; k++) {
                //         if (nodePairs[k].id == i) {
                //             pair = nodePairs[k];
                //             break;
                //         }
                //     }
                //     if (!pair) {
                //         pair = new NodePair(i, this);
                //         nodePairs.push(pair)
                //         thisGraphNodePairIds.push(i)
                //         pair.source = nodes[this.pairAttr('source', i)];
                //         pair.target = nodes[this.pairAttr('target', i)];
                //     }
                //     for (var k = 0; k < links.length; k++) {
                //         if (links[k].id == pairLinkId) {
                //             link = links[k];
                //             break;
                //         }
                //     }
                //     pair.links.push(link);
                //     link.nodePair = pair;
                // }
            }
        }
        this._nodes = nodes;
        this._links = links;
        // this.nodePairs = nodePairs;
        if (shouldCreateTimes) {
            // && 'timesArrays' in this && this.timeArrays) {
            this._times = [];
            for (let i = 0; i < this.timeArrays.length; i++)
                this._times.push(new Time(i, this));
        }
        // if (shouldCreateLinkTypes) {
        //     var linkTypeCount: number = this.linkTypeArrays.length;
        //     var colorScale;
        //     if (linkTypeCount <= 10) {
        //         colorScale = d3.scale.category10();
        //     } else {
        //         colorScale = d3.scale.category20();
        //     }
        //     for (var i = 0; i < this.linkTypeArrays.name.length; i++) {
        //         this.linkTypes.push(new LinkType(
        //             this.linkTypeArrays.id[i],
        //             this.linkTypeArrays.name[i],
        //             this.linkTypeArrays.color[i]
        //         ));
        //     }
        // }
        console.log("[DynamicNetwork:getGraph()] <<< ", Date.now() - d, "msec");
    }
    // all attribute accessor method
    nodeAttr(attr, id) {
        return this.attr(attr, id, "node");
    }
    linkAttr(attr, id) {
        return this.attr(attr, id, "link");
    }
    pairAttr(attr, id) {
        return this.attr(attr, id, "nodePair");
    }
    timeAttr(attr, id) {
        return this.attr(attr, id, "time");
    }
    get startTime() {
        return this._times[0];
    }
    get endTime() {
        return this._times[this._times.length - 1];
    }
    // /// SELECTIONS
    // // selections store ids of objects only.
    highlight(action, idCompound) {
        if (action == "reset") {
            // reset all
            this.highlightArrays.nodeIds = [];
            this.highlightArrays.linkIds = [];
            this.highlightArrays.nodePairIds = [];
            this.highlightArrays.timeIds = [];
            return;
        }
        if (!idCompound) {
            console.error("[DynamicGraph] highlight: idCompound not set!");
            return;
        }
        if (action == "set") {
            this.highlight("reset");
            this.highlight("add", idCompound);
            return;
        }
        // if(action == 'add'){
        //     for(var i=0 ; i<elementIds.length ; i++){
        //         if(this.highlightArrays[type].indexOf(elementIds[i]) == -1)
        //             this.highlightArrays[type].push(elementIds[i]);
        //     }
        // }else
        // if(action == 'remove'){
        //     for(var i=0 ; i<elementIds.length ; i++){
        //         if(this.highlightArrays[type].indexOf(elementIds[i]) > -1)
        //              this.highlightArrays[type].splice(this.highlightArrays[type].indexOf(elementIds[i]),1)
        //     }
        // }
        if (action == "add") {
            for (const type in idCompound) {
                for (let i = 0; i < idCompound[type].length; i++) {
                    this.highlightArrays[type].push(idCompound[type][i]);
                }
            }
        }
        else if (action == "remove") {
            let index;
            for (const type in idCompound) {
                for (let i = 0; i < idCompound[type].length; i++) {
                    index = this.highlightArrays[type].indexOf(idCompound[type][i]);
                    if (index >= 0)
                        this.highlightArrays[type].splice(index, 1);
                }
            }
        }
    }
    // SELECT
    selection(action, idCompound, selectionId) {
        if (selectionId == undefined)
            selectionId = this.currentSelection_id;
        const selection = this.getSelection(selectionId);
        if (!selection) {
            console.error("[DynamicGraph] Selection with ", selectionId, "not found in ", this.selections);
            return; // WITH RETURN ?
        }
        if (action == "set") {
            const c = new IDCompound();
            c[selection.acceptedType] = selection.elementIds;
            this.selection("remove", c, selectionId);
            this.selection("add", idCompound, selectionId);
        }
        else if (action == "add") {
            idCompound.linkIds.forEach((v, i, arr) => this.addToSelectionByTypeAndId(selection, "link", v));
            idCompound.nodeIds.forEach((v, i, arr) => this.addToSelectionByTypeAndId(selection, "node", v));
            idCompound.timeIds.forEach((v, i, arr) => this.addToSelectionByTypeAndId(selection, "time", v));
            idCompound.nodePairIds.forEach((v, i, arr) => this.addToSelectionByTypeAndId(selection, "nodePair", v));
        }
        else if (action == "remove") {
            idCompound.linkIds.forEach((v, i, arr) => this.removeFromSelectionByTypeAndId(selection, "link", v));
            idCompound.nodeIds.forEach((v, i, arr) => this.removeFromSelectionByTypeAndId(selection, "node", v));
            idCompound.timeIds.forEach((v, i, arr) => this.removeFromSelectionByTypeAndId(selection, "time", v));
            idCompound.nodePairIds.forEach((v, i, arr) => this.removeFromSelectionByTypeAndId(selection, "nodePair", v));
        }
    }
    // SELFIX : delegate to dgraph
    addToAttributeArraysSelection(selection, type, id) {
        // check for priority of selections, then add where appropriate
        const elementSelections = this.attributeArrays[type].selections[id];
        for (let i = 0; i < elementSelections.length; i++) {
            if (elementSelections[i].priority > selection.priority) {
                this.attributeArrays[type].selections[id].splice(i, 0, selection);
                return;
            }
        }
        // if not already selected and if not higher priority than any other
        // selection, append to the end.
        this.attributeArrays[type].selections[id].push(selection);
    }
    // SELFIX : delegate to dgraph
    removeFromAttributeArraysSelection(selection, type, id) {
        const arr = this.attributeArrays[type].selections[id];
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] == selection)
                this.attributeArrays[type].selections[id].splice(i, 1);
        }
    }
    addElementToSelection(selection, e) {
        this.addToSelectionByTypeAndId(selection, e.type, e.id());
    }
    addToSelectionByTypeAndId(selection, type, id) {
        if (type != selection.acceptedType) {
            console.log("attempting to put object of the wrong type into a selection");
            return; // don't proceed with selection;
        }
        selection.elementIds.push(id);
        this.addToAttributeArraysSelection(selection, type, id);
        // =======
        //                 this.selection('add', idCompound, selectionId);
        //             } else {
        //                 if (action == 'add') {
        //                     for (var field in idCompound) {
        //                         for (var i = 0; i < idCompound[field].length; i++) {
        //                             this.addToSelection(selection, idCompound[field][i], field)
        //                         }
        //                     }
        //                 } else {
        //                     if (action == 'remove') {
        //                         for (var field in idCompound) {
        //                             for (var i = 0; i < idCompound[field].length; i++) {
        //                                 for (var j = 0; j < selection.elementIds.length; j++) {
        //                                     if (selection.elementIds[j] == idCompound[field][i].id) {
        //                                         this.removeFromSelection(selection, idCompound[field][i], field);
        //                                     }
        //                                 }
        //                             }
        //                         }
        //                     }
        //                 }
        //             }
        //         }
        //         addToSelection(selection: Selection, id:number, elementType:string) {
        //             selection.elementIds.push(id);
        //             var e:BasicElement = this.get(elementType, id);
        //             e.addToSelection(selection);
        // >>>>>>> api
        // remove from default selection
        let i;
        if (type == "node") {
            i = this.defaultNodeSelection.elementIds.indexOf(id);
            if (i > -1) {
                this.removeFromAttributeArraysSelection(this.defaultNodeSelection, type, id);
                this.defaultNodeSelection.elementIds.splice(i, 1);
            }
        }
        else if (type == "link") {
            i = this.defaultLinkSelection.elementIds.indexOf(id);
            if (i > -1) {
                this.removeFromAttributeArraysSelection(this.defaultLinkSelection, type, id);
                this.defaultLinkSelection.elementIds.splice(i, 1);
            }
        }
    }
    // <<<<<<< HEAD
    removeElementFromSelection(selection, e) {
        this.removeFromSelectionByTypeAndId(selection, e.type, e.id());
    }
    removeFromSelectionByTypeAndId(selection, type, id) {
        // selection.elements.push(compound[field][i])
        // e.addToSelection(selection);
        // =======
        //         removeFromSelection(selection: Selection, id:number, elementType:string) {
        // >>>>>>> api
        const i = selection.elementIds.indexOf(id);
        if (i == -1)
            return;
        selection.elementIds.splice(i, 1);
        // <<<<<<< HEAD
        this.removeFromAttributeArraysSelection(selection, type, id);
        // =======
        //             var e:BasicElement = this.get(elementType, id);
        //             e.removeFromSelection(selection);
        // >>>>>>> api
        // add to default selection
        if (this.getSelectionsByTypeAndId(type, id).length == 0) {
            if (type == "node") {
                this.defaultNodeSelection.elementIds.push(id);
                this.addToAttributeArraysSelection(this.defaultNodeSelection, type, id);
            }
            else if (type == "link") {
                this.defaultLinkSelection.elementIds.push(id);
                this.addToAttributeArraysSelection(this.defaultLinkSelection, type, id);
            }
        }
    }
    getSelectionsByTypeAndId(type, id) {
        return this.attributeArrays[type].selections[id];
    }
    filterSelection(selectionId, filter) {
        const selection = this.getSelection(selectionId);
        if (selection != undefined) {
            selection.filter = filter;
        }
    }
    isFiltered(id, type) {
        return this.attributeArrays[type + "s"].filter;
    }
    isHighlighted(id, type) {
        return this.highlightArrays[type + "Ids"].indexOf(id) > -1;
    }
    getHighlightedIds(type) {
        return this.highlightArrays[type + "Ids"];
    }
    setCurrentSelection(id) {
        // [bbach] why should we ignore them?
        // if (id < 2) // i.e. either default node or link selection..
        //     return;  // ignore
        console.log("[DynamicGraph] setCurrentSelectionId ", id);
        this.currentSelection_id = id;
    }
    getCurrentSelection() {
        // before onoly Selection!
        return this.getSelection(this.currentSelection_id);
    }
    addSelection(id, color, acceptedType, priority) {
        const s = this.createSelection(acceptedType);
        s.id = id;
        s.color = color;
        s.priority = priority;
    }
    // creates a selection for the passed type.
    createSelection(type) {
        const s = new Selection(this.selections.length, type);
        s.color = this.BOOKMARK_COLORS(this.selectionColor_pointer % 10);
        this.selectionColor_pointer++;
        this.selections.push(s);
        return s;
    }
    deleteSelection(selectionId) {
        const s = this.getSelection(selectionId);
        // remove all elements from this selection
        // <<<<<<< HEAD
        //             var compound: ElementCompound = new ElementCompound();
        //             compound[s.acceptedType + 'Ids'] = s.elementIds.slice(0);
        //             this.selection('remove', compound, s.id)
        // =======
        // remove
        if (s != undefined) {
            const idCompound = new IDCompound();
            idCompound[s.acceptedType + "Ids"] = s.elementIds.slice(0);
            console.log("Delete selection->remove elemeents", s.elementIds.slice(0));
            this.selection("remove", idCompound, s.id);
            // >>>>>>> api
            // delete selection
            this.selections.splice(this.selections.indexOf(s), 1);
        }
    }
    setSelectionColor(id, color) {
        const s = this.getSelection(id);
        if (!s) {
            return;
        }
        s.color = color;
    }
    getSelections(type) {
        const selections = [];
        if (type) {
            for (let i = 0; i < this.selections.length; i++) {
                if (this.selections[i].acceptsType(type))
                    selections.push(this.selections[i]);
            }
            return selections;
        }
        else {
            return this.selections;
        }
    }
    getSelection(id) {
        // before only Selection return
        for (let i = 0; i < this.selections.length; i++) {
            if (id == this.selections[i].id)
                return this.selections[i];
        }
        console.error("[DynamicGraph] No selection with id ", id, "found!");
        /* If not found ?? */
        return undefined;
    }
    clearSelections() {
        this.selections = [];
    }
    // internal utils
    getTimeIdForUnixTime(unixTime) {
        // before only number
        let timeId;
        console.log("unixTime: ");
        console.log(unixTime);
        for (timeId = 0; timeId < this.timeArrays.length; timeId++) {
            if (unixTime == this.timeArrays.unixTime[timeId]) {
                timeId;
                return timeId;
            }
        }
        console.error("Time object for unix time", unixTime, "not found!");
        return undefined;
    }
    // ORDERING
    /* adds an specific node order (e.g. alphabetical) */
    // go into dynamicgraph
    addNodeOrdering(name, order) {
        for (let i = 0; i < this.nodeOrders.length; i++) {
            if (this.nodeOrders[i].name == name) {
                console.error("Ordering", name, "already exists");
                return;
            }
        }
        const o = new Ordering(name, order);
        this.nodeOrders.push(o);
    }
    setNodeOrdering(name, order) {
        for (let i = 0; i < this.nodeOrders.length; i++) {
            if (this.nodeOrders[i].name == name) {
                this.nodeOrders[i].order = order;
                return;
            }
        }
        console.error("Ordering", name, "does not exist");
    }
    removeNodeOrdering(name, order) {
        for (let i = 0; i < this.nodeOrders.length; i++) {
            if (this.nodeOrders[i].name == name) {
                this.nodeOrders.splice(i, 1);
            }
        }
    }
    getNodeOrder(name) {
        for (let i = 0; i < this.nodeOrders.length; i++) {
            if (this.nodeOrders[i].name == name) {
                return this.nodeOrders[i];
            }
        }
        console.error("Ordering", name, "not found!");
        return;
    }
    // returns elements
    nodes() {
        return new NodeQuery(this.nodeArrays.id, this);
    }
    links() {
        return new LinkQuery(this.linkArrays.id, this);
    }
    times() {
        return new TimeQuery(this.timeArrays.id, this);
    }
    locations() {
        return new LocationQuery(this.locationArrays.id, this);
    }
    nodePairs() {
        return new NodePairQuery(this.nodePairArrays.id, this);
    }
    linksBetween(n1, n2) {
        let nodePairId = this.matrix[n1.id()][n2.id()];
        if (nodePairId == undefined)
            nodePairId = this.matrix[n2.id()][n1.id()];
        if (nodePairId == undefined)
            return new LinkQuery([], this);
        /* UNDEFINED? */
        const node_pair = this.nodePair(nodePairId);
        if (node_pair != undefined)
            return new LinkQuery(node_pair.links().toArray(), this);
        else
            return new LinkQuery([], this);
    }
    // generic accessor method. should not be used externally
    get(type, id) {
        if (type.indexOf("nodePair") > -1)
            return this.nodePair(id);
        if (type.indexOf("node") > -1)
            return this.node(id);
        if (type.indexOf("link") > -1)
            return this.link(id);
        if (type.indexOf("time") > -1)
            return this.time(id);
        if (type.indexOf("locations") > -1)
            return this.location(id);
    }
    getAll(type) {
        if (type == "nodes")
            return this.nodes();
        if (type == "links")
            return this.links();
        if (type == "times")
            return this.times();
        if (type == "nodePairs")
            return this.nodePairs();
        // if (type == 'locations')
        return this.locations();
    }
    // returns the node with ID
    node(id) {
        for (let i = 0; i < this._nodes.length; i++) {
            if (this._nodes[i].id() == id)
                return this._nodes[i];
        }
    }
    link(id) {
        for (let i = 0; i < this._links.length; i++) {
            if (this._links[i].id() == id)
                return this._links[i];
        }
    }
    time(id) {
        for (let i = 0; i < this._times.length; i++) {
            if (this._times[i].id() == id)
                return this._times[i];
        }
    }
    location(id) {
        for (let i = 0; i < this._locations.length; i++) {
            if (this._locations[i].id() == id)
                return this._locations[i];
        }
    }
    nodePair(id) {
        for (let i = 0; i < this._nodePairs.length; i++) {
            if (this._nodePairs[i].id() == id)
                return this._nodePairs[i];
        }
    }
    getMinGranularity() {
        return this.gran_min;
    }
    getMaxGranularity() {
        return this.gran_max;
    }
}
//# sourceMappingURL=dynamicGraph.js.map
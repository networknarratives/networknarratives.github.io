import { BasicElement, DynamicGraph, Link, Location, Node, NodePair, Time } from "./dynamicgraph";
export declare function attributeSort(a: BasicElement, b: BasicElement, attributeName: string, asc?: boolean): number;
export declare class Query {
    _elements: number[];
    constructor(elements?: number[]);
    addUnique(element: number): void;
    add(element: number): void;
    addAll(elements: number[]): void;
    addAllUnique(elements: number[]): void;
    /** @returns numbr of elements in this query. Same as size(). */
    get length(): number;
    /** @returns numbr of elements in this query. Same as length getter. */
    size(): number;
    /** @returns all ids in this query. */
    ids(): number[];
    removeDuplicates(): Query;
    generic_intersection(q: Query): Query;
}
export declare class GraphElementQuery extends Query {
    g: DynamicGraph;
    elementType: string;
    constructor(elements: any[], g: DynamicGraph, elementType: string);
    /** @returns a query that contains only the elements matching
     * the filter critera;
     * @param attribute - name of attribute that is used on filter
     * @param filter - function evaluating if the attribute's value is valid.
     */
    generic_filter(filter: (d: any) => boolean): any[];
    /** @returns a query with selected elements, i.e. elements that are in at least
     * one selection.
     */
    generic_selected(): any[];
    /** @returns a query with visible elements.
     */
    generic_visible(): any[];
    /** @returns a query with highighted elements.
     */
    generic_highlighted(): any[];
    /** @returns a query with only the elements present in the specified time step
     * or period.
     */
    generic_presentIn(start: Time, end?: Time): any[];
    /** @returns this query with elements sorted */
    generic_sort(attrName: string, asc?: boolean): GraphElementQuery;
    generic_removeDuplicates(): GraphElementQuery;
}
export declare class TimeQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(t: Time): boolean;
    highlighted(): TimeQuery;
    visible(): TimeQuery;
    selected(): TimeQuery;
    filter(filter: (d: any) => boolean): TimeQuery;
    presentIn(t1: Time, t2: Time): TimeQuery;
    sort(attributeName: string): TimeQuery;
    links(): LinkQuery;
    get(i: number): Time;
    last(): Time;
    toArray(): Time[];
    createAttribute(attrName: string, f: (t: Time) => void): TimeQuery;
    unixTimes(): number[];
    intersection(q: TimeQuery): TimeQuery;
    forEach(f: (t: Time | undefined, i: number) => void): TimeQuery;
}
export declare class LocationQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(l: Location): boolean;
    highlighted(): LocationQuery;
    visible(): LocationQuery;
    selected(): LocationQuery;
    filter(filter: (d: any) => boolean): LocationQuery;
    presentIn(t1: Time, t2: Time): LocationQuery;
    sort(attributeName: string): LocationQuery;
    get(i: number): Location;
    last(): Location;
    toArray(): Location[];
    createAttribute(attrName: string, f: (l: Location) => void): LocationQuery;
    intersection(q: LocationQuery): LocationQuery;
    removeDuplicates(): LocationQuery;
    forEach(f: (l: Location | undefined, i: number) => any): LocationQuery;
}
export declare class NodePairQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(n: NodePair): boolean;
    highlighted(): NodePairQuery;
    visible(): NodePairQuery;
    selected(): NodePairQuery;
    filter(filter: (d: any) => boolean): NodePairQuery;
    presentIn(t1: Time, t2: Time): NodePairQuery;
    sort(attributeName: string): NodePairQuery;
    get(i: number): NodePair;
    last(): Link;
    toArray(): NodePair[];
    createAttribute(attrName: string, f: (np: NodePair) => void): NodePairQuery;
    intersection(q: NodePairQuery): NodePairQuery;
    removeDuplicates(): NodePairQuery;
    forEach(f: (np: NodePair | undefined, i: number) => any): NodePairQuery;
}
/**
 * Represents a simple array of numbers that can be used to calculate
 * max, mean, min values etc..
 */
export declare class NumberQuery extends Query {
    clone(): number[];
    min(): number;
    max(): number;
    mean(): number;
    sum(): number;
    toArray(): number[];
    get(index: number): number;
    forEach(f: (n: number, i: number) => any): NumberQuery;
    makeNumbers(elements: number[]): number[];
}
export declare class StringQuery {
    _elements: string[];
    constructor(elements?: string[]);
    contains(element: string): boolean;
    addUnique(element: string): void;
    add(element: string): void;
    addAll(elements: string[]): void;
    addAllUnique(elements: string[]): void;
    get length(): number;
    size(): number;
    toArray(): string[];
    forEach(f: (s: string, i: number) => void): StringQuery;
}
export declare class NodeQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(n: Node): boolean;
    highlighted(): NodeQuery;
    visible(): NodeQuery;
    selected(): NodeQuery;
    filter(filter: (d: any) => boolean): NodeQuery;
    presentIn(t1: Time, t2: Time): NodeQuery;
    sort(attributeName: string, asc?: boolean): NodeQuery;
    label(): StringQuery;
    neighbors(t1?: Time, t2?: Time): NodeQuery;
    links(t1?: Time, t2?: Time): LinkQuery;
    locations(t1?: Time, t2?: Time): LocationQuery;
    nodeTypes(): StringQuery;
    get(i: number): Node;
    last(): Node;
    toArray(): Node[];
    createAttribute(attrName: string, f: (n: Node) => any): NodeQuery;
    intersection(q: NodeQuery): NodeQuery;
    removeDuplicates(): NodeQuery;
    forEach(f: (n: Node | undefined, i: number) => void): NodeQuery;
}
export declare class LinkQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(l: Link): boolean;
    highlighted(): LinkQuery;
    visible(): LinkQuery;
    selected(): LinkQuery;
    filter(filter: (d: any) => boolean): LinkQuery;
    presentIn(t1: Time, t2?: Time): LinkQuery;
    sort(attributeName: string): LinkQuery;
    get(i: number): Link;
    last(): Link;
    toArray(): Link[];
    weights(start?: Time, end?: Time): NumberQuery;
    createAttribute(attrName: string, f: (link: Link) => any): LinkQuery;
    linkTypes(): string[];
    sources(): NodeQuery;
    targets(): NodeQuery;
    intersection(q: LinkQuery): LinkQuery;
    removeDuplicates(): LinkQuery;
    forEach(f: (link: Link | undefined, i: number) => void): LinkQuery;
}

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment'), require('lz-string'), require('reorder.js'), require('netclustering'), require('three'), require('jquery')) :
    typeof define === 'function' && define.amd ? define(['exports', 'moment', 'lz-string', 'reorder.js', 'netclustering', 'three', 'jquery'], factory) :
    (global = global || self, factory(global.vc = {}, global.moment, global.LZString, global.reorder, global.netClustering, global.three, global.$));
}(this, (function (exports, moment, LZString, reorder, netClustering, THREE, $$1) { 'use strict';

    netClustering = netClustering && Object.prototype.hasOwnProperty.call(netClustering, 'default') ? netClustering['default'] : netClustering;
    $$1 = $$1 && Object.prototype.hasOwnProperty.call($$1, 'default') ? $$1['default'] : $$1;

    // namespace networkcube {
    /* moved from utils to datamanager */
    function isValidIndex(v) {
        return v != undefined && v > -1;
    }
    /* moved from dynamicgraph to datamanager */
    class Selection {
        constructor(id, acceptedType) {
            this.color = "#3366cc"; // INIT??
            this.showColor = true;
            this.filter = false;
            this.priority = 0;
            this.id = id;
            this.name = 'Selection-' + this.id;
            this.elementIds = [];
            this.acceptedType = acceptedType;
            this.priority = id;
        }
        acceptsType(type) {
            return this.acceptedType == type;
        }
    }
    // data set / graph with name
    class DataSet {
        // constructor(name:string, nodeTable:any[], linkTable:any[], nodeSchema:NodeSchema, linkSchema:LinkSchema, locationTable?:any, locationSchema?:LocationSchema){
        constructor(params) {
            this.locationTable = [];
            this.selections = []; //predefined selections (not link type)
            this.timeFormat = ''; // INIT?????????????
            this.name = params.name;
            this.nodeTable = params.nodeTable;
            this.linkTable = params.linkTable;
            this.directed = params.directed;
            if (params.nodeSchema == undefined)
                this.nodeSchema = getDefaultNodeSchema();
            else
                this.nodeSchema = params.nodeSchema;
            if (params.linkSchema == undefined)
                this.linkSchema = getDefaultLinkSchema();
            else
                this.linkSchema = params.linkSchema;
            if (params.locationTable != undefined)
                this.locationTable = params.locationTable;
            if (params.locationSchema == undefined)
                this.locationSchema = getDefaultLocationSchema();
            else
                this.locationSchema = params.locationSchema;
            console.log('[n3] data set created', this);
        }
    }
    function getDefaultNodeSchema() {
        return new NodeSchema(0);
    }
    function getDefaultLinkSchema() {
        return new LinkSchema(0, 1, 2);
    }
    function getDefaultLocationSchema() {
        return new LocationSchema(0, 1, 2, 3, 4, 5, 6, 7, 8);
    }
    class TableSchema {
        constructor(name) {
            this.name = name;
        }
    }
    // default node schema for node table
    class NodeSchema extends TableSchema {
        constructor(id) {
            super('nodeSchema');
            /* INIT ?????????????????? */
            this.label = -1;
            this.time = -1;
            this.location = -1;
            this.nodeType = -1;
            this.shape = -1;
            this.color = -1;
            this.id = id;
        }
    }
    // default node schema for link table
    class LinkSchema extends TableSchema {
        constructor(id, source, target) {
            super('linkSchema');
            this.weight = -1; // INIT????????
            this.linkType = -1;
            this.directed = -1;
            this.time = -1;
            this.source = source;
            this.target = target;
            this.id = id;
        }
    }
    class LocationSchema extends TableSchema {
        constructor(id, label, geoname, longitude, latitude, x, y, z, radius) {
            super('locationSchema');
            this.geoname = -1; // actual geo name (english)
            this.longitude = -1;
            this.latitude = -1;
            this.x = -1;
            this.y = -1;
            this.z = -1;
            this.radius = -1;
            this.id = id;
            this.label = label;
            if (isValidIndex(geoname))
                this.geoname = geoname != undefined ? geoname : -1; // geoname never will be undefined at this point
            if (isValidIndex(longitude))
                this.longitude = longitude != undefined ? longitude : -1;
            if (isValidIndex(latitude))
                this.latitude = latitude != undefined ? latitude : -1;
            if (isValidIndex(x))
                this.x = x != undefined ? x : -1;
            if (isValidIndex(y))
                this.y = y != undefined ? y : -1;
            if (isValidIndex(z))
                this.z = z != undefined ? z : -1;
            if (isValidIndex(radius))
                this.radius = radius != undefined ? radius : -1;
        }
    }
    //}

    var datamanager = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isValidIndex: isValidIndex,
        Selection: Selection,
        DataSet: DataSet,
        getDefaultNodeSchema: getDefaultNodeSchema,
        getDefaultLinkSchema: getDefaultLinkSchema,
        getDefaultLocationSchema: getDefaultLocationSchema,
        TableSchema: TableSchema,
        NodeSchema: NodeSchema,
        LinkSchema: LinkSchema,
        LocationSchema: LocationSchema
    });

    var GRANULARITY = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'year']; //, 'decade', 'century', 'millenium'];
    var DGRAPH_SUB = "[*dgraph*]";
    var DGRAPH_SER_VERBOSE_LOGGING = false;
    function dgraphReviver(dgraph, key, value) {
        if (value == DGRAPH_SUB)
            return dgraph;
        else
            return value;
    }
    function dgraphReplacer(key, value) {
        if (value instanceof DynamicGraph) {
            console.log("dgraphReplacer found a DynamicGraph property", key);
            return DGRAPH_SUB;
        }
        return value;
    }
    class DynamicGraph {
        constructor() {
            // BOOKMARK_COLORS: string[] = colorSchemes.schema5;
            this.BOOKMARK_COLORS = this.default_colors;
            this.selectionColor_pointer = 0;
            //data: DataSet;
            this.name = ''; // INIT??
            // data meta data
            this.gran_min = 0; // INIT?
            this.gran_max = Number.MAX_VALUE; // INIT?
            this.minWeight = 10000000;
            this.maxWeight = -10000000;
            this._nodes = [];
            this._links = [];
            this.directed = false;
            this._nodePairs = [];
            this._locations = [];
            // Contains all time objects for this dynamic graph
            this._times = [];
            // linkTypes: LinkType[] = [];
            this.timeObjects = [];
            this.nodeOrders = []; // INIT?
            // Matrix for fast access to node pairs (link)
            this.matrix = []; // fast access to node pairs.
            this.selections = [];
            // node attributes
            this.nodeArrays = new NodeArray();
            // link attributes
            this.linkArrays = new LinkArray();
            // node pair attributes
            this.nodePairArrays = new NodePairArray();
            // time attributes
            this.timeArrays = new TimeArray();
            // array for relation types
            this.linkTypeArrays = new LinkTypeArray();
            // array for node types
            this.nodeTypeArrays = new NodeTypeArray();
            // array for locations
            this.locationArrays = new LocationArray();
            // points to all object arrays. For convenience
            this.attributeArrays = {
                node: this.nodeArrays,
                link: this.linkArrays,
                time: this.timeArrays,
                nodePair: this.nodePairArrays,
                linkType: this.linkTypeArrays,
                nodeType: this.nodeTypeArrays,
                location: this.locationArrays
            };
            // highlighted objects
            this.highlightArrays = new IDCompound();
            this.currentSelection_id = 0;
            /* INIT OK?? */
            this.defaultLinkSelection = this.createSelection('link');
            this.defaultNodeSelection = this.createSelection('node');
            // storage keys /////////////////////////////////
            //
            this.gran_min_NAME = "gran_min";
            this.gran_max_NAME = "gran_max_NAME";
            this.directed_NAME = "directed_NAME";
            this.minWeight_NAME = "minWeight_NAME";
            this.maxWeight_NAME = "maxWeight_NAME";
            this.matrix_NAME = "matrix_NAME";
            this.nodeArrays_NAME = "nodeArrays_NAME";
            this.linkArrays_NAME = "linkArrays_NAME";
            this.nodePairArrays_NAME = "nodePairArrays_NAME";
            this.timeArrays_NAME = "timeArrays_NAME";
            this.linkTypeArrays_NAME = "linkTypeArrays_NAME";
            this.nodeTypeArrays_NAME = "nodeTypeArrays_NAME";
            this.locationArrays_NAME = "locationArrays_NAME";
        }
        default_colors(i) {
            var colors = ["#3366cc", "#dc3912", "#ff9900", "#109618", "#990099", "#0099c6", "#dd4477", "#66aa00", "#b82e2e", "#316395", "#994499", "#22aa99", "#aaaa11", "#6633cc", "#e67300", "#8b0707", "#651067", "#329262", "#5574a6", "#3b3eac"];
            return colors[i % colors.length];
        }
        // ACCESSOR FUNCTIONS
        // universal accesor
        attr(field, id, type) {
            var r;
            try {
                r = this.attributeArrays[type][field][id];
            }
            catch (e) {
                r = undefined;
            }
            return r;
        }
        //
        // end storage keys //////////////////////////////
        // FUNCTIONS
        standardArrayReplacer(key, value) {
            // don't write out graph, as this would cause cycles
            if (value instanceof DynamicGraph) {
                console.log("standardReplacer found a DynamicGraph property", key);
                return DGRAPH_SUB;
            }
            // don't write out selection, because we must preserve it independently
            // from the graph
            else if (key == 'selections')
                return undefined;
            return value;
        }
        static timeReviver(k, v, s) {
            if (k == '') {
                return copyPropsShallow(v, new Time(v.id, s));
            }
            else {
                return dgraphReviver(s, k, v);
            }
        }
        static nodeArrayReviver(k, v, s) {
            switch (k) {
                case '':
                    return copyPropsShallow(v, new NodeArray());
                // case 'nodeType':
                // return copyTimeSeries(v, function() { return new ScalarTimeSeries<string>(); });
                case 'outLinks':
                case 'inLinks':
                case 'links':
                    return copyTimeSeries(v, function () { return new ArrayTimeSeries(); });
                case 'outNeighbors':
                case 'inNeighbors':
                case 'neighbors':
                    return copyTimeSeries(v, function () { return new ArrayTimeSeries(); });
                case 'locations':
                    return copyTimeSeries(v, function () { return new ScalarTimeSeries(); });
                default:
                    return v;
            }
        }
        static linkArrayReviver(k, v, s) {
            switch (k) {
                case '':
                    return copyPropsShallow(v, new LinkArray());
                case 'weights':
                    return copyTimeSeries(v, function () { return new ScalarTimeSeries(); });
                default:
                    return v;
            }
        }
        static nodePairArrayReviver(k, v, s) {
            switch (k) {
                case '':
                    return copyPropsShallow(v, new NodePairArray());
                default:
                    return v;
            }
        }
        static timeArrayReviver(k, v, s) {
            switch (k) {
                case '':
                    return copyPropsShallow(v, new TimeArray());
                case 'time':
                    var vAsArray = v;
                    return vAsArray.map(function (s, i) { return moment.utc(s); });
                default:
                    return v;
            }
        }
        static linkTypeArrayReviver(k, v, s) {
            switch (k) {
                case '':
                    return copyPropsShallow(v, new LinkTypeArray());
                default:
                    return v;
            }
        }
        static nodeTypeArrayReviver(k, v, s) {
            switch (k) {
                case '':
                    return copyPropsShallow(v, new NodeTypeArray());
                default:
                    return v;
            }
        }
        static locationArrayReviver(k, v, s) {
            switch (k) {
                case '':
                    return copyPropsShallow(v, new LocationArray());
                default:
                    return v;
            }
        }
        loadDynamicGraph(dataMgr, dataSetName) {
            this.clearSelections();
            this.name = dataSetName;
            // CACHEGRAPH : load from storage the entire state of the graph
            var gran_min_storage = dataMgr.getFromStorage(this.name, this.gran_min_NAME);
            if (gran_min_storage != undefined)
                this.gran_min = gran_min_storage;
            var gran_max_storage = dataMgr.getFromStorage(this.name, this.gran_max_NAME);
            if (gran_max_storage != undefined)
                this.gran_max = gran_max_storage;
            var directed_storage = dataMgr.getFromStorage(this.name, this.directed_NAME);
            if (directed_storage != undefined)
                this.directed = directed_storage;
            var minWeight_storage = dataMgr.getFromStorage(this.name, this.minWeight_NAME);
            if (minWeight_storage != undefined)
                this.minWeight = minWeight_storage;
            var maxWeight_storage = dataMgr.getFromStorage(this.name, this.maxWeight_NAME);
            if (maxWeight_storage != undefined)
                this.maxWeight = maxWeight_storage;
            var matrix_storage = dataMgr.getFromStorage(this.name, this.matrix_NAME);
            if (matrix_storage != undefined)
                this.matrix = matrix_storage;
            var nodeArrays_storage = dataMgr.getFromStorage(this.name, this.nodeArrays_NAME, DynamicGraph.nodeArrayReviver);
            if (nodeArrays_storage != undefined)
                this.nodeArrays = nodeArrays_storage;
            var linkArrays_storage = dataMgr.getFromStorage(this.name, this.linkArrays_NAME, DynamicGraph.linkArrayReviver);
            if (linkArrays_storage != undefined)
                this.linkArrays = linkArrays_storage;
            var nodePairArrays_storage = dataMgr.getFromStorage(this.name, this.nodePairArrays_NAME, DynamicGraph.nodePairArrayReviver);
            if (nodePairArrays_storage != undefined)
                this.nodePairArrays = nodePairArrays_storage;
            var timeArrays_storage = dataMgr.getFromStorage(this.name, this.timeArrays_NAME, DynamicGraph.timeArrayReviver);
            if (timeArrays_storage != undefined)
                this.timeArrays = timeArrays_storage;
            if (!('timeArrays' in this) || !this.timeArrays) {
                console.log('No timeArrays');
                this.timeArrays = new TimeArray();
            }
            else if ('momentTime' in this.timeArrays && 'unixTime' in this.timeArrays) {
                var ta = this.timeArrays['momentTime'];
                for (var i = 0; i < ta.length; i++) {
                    ta[i] = moment.utc(this.timeArrays['unixTime'][i]);
                }
            }
            /* I DON'T KNOW WHY timeArrays IS never */
            else if ('unixTime' in this.timeArrays) {
                console.log('No time in timeArrays');
                this.timeArrays['momentTime'] = this.timeArrays['unixTime'].map(moment.utc());
            }
            else {
                console.log('No time or unixTime in timeArrays');
                this.timeArrays['momentTime'] = [];
            }
            var linkTypeArrays_storage = dataMgr.getFromStorage(this.name, this.linkTypeArrays_NAME, DynamicGraph.linkTypeArrayReviver);
            if (linkTypeArrays_storage != undefined)
                this.linkTypeArrays = linkTypeArrays_storage;
            var nodeTypeArrays_storage = dataMgr.getFromStorage(this.name, this.nodeTypeArrays_NAME, DynamicGraph.nodeTypeArrayReviver);
            if (nodeTypeArrays_storage != undefined)
                this.nodeTypeArrays = nodeTypeArrays_storage;
            var locationArrays_storage = dataMgr.getFromStorage(this.name, this.locationArrays_NAME, DynamicGraph.locationArrayReviver);
            if (locationArrays_storage != undefined)
                this.locationArrays = locationArrays_storage;
            // points to all object arrays. For convenience
            this.attributeArrays = {
                node: this.nodeArrays,
                link: this.linkArrays,
                time: this.timeArrays,
                nodePair: this.nodePairArrays,
                linkType: this.linkTypeArrays,
                nodeType: this.nodeTypeArrays,
                location: this.locationArrays
            };
            // rather than persist all of the state of windowGraph
            // as well, we simply reinitialize from our persisted state.
            // perhaps we need to serialize this as well.
            // inits the WindowGraph for this dynamic graph, i.e.
            // the all-aggregated graph.
            this.createGraphObjects(true, true);
            // init the selections which are currently null
            // this.nodeArrays.selections=[];
            // this.nodeArrays.selections.push([]);
            // this.timeArrays.selections=[];
            // this.timeArrays.selections.push([]);
            // this.linkArrays.selections=[];
            // this.linkArrays.selections.push([]);
            // this.nodePairArrays.selections=[];
            // this.nodePairArrays.selections.push([]);
            this.createSelections(true);
        }
        saveDynamicGraph(dataMgr) {
            // CACHEGRAPH : persist the entire state of the dynamic graph
            dataMgr.saveToStorage(this.name, this.gran_min_NAME, this.gran_min);
            dataMgr.saveToStorage(this.name, this.gran_max_NAME, this.gran_max);
            dataMgr.saveToStorage(this.name, this.directed_NAME, this.directed);
            dataMgr.saveToStorage(this.name, this.minWeight_NAME, this.minWeight);
            dataMgr.saveToStorage(this.name, this.maxWeight_NAME, this.maxWeight);
            dataMgr.saveToStorage(this.name, this.matrix_NAME, this.matrix);
            dataMgr.saveToStorage(this.name, this.nodeArrays_NAME, this.nodeArrays, this.standardArrayReplacer);
            // when we tried to persist the entire linkArrays, javascript threw an
            // exception, so for now we will simply try to save out the parts.
            dataMgr.saveToStorage(this.name, this.linkArrays_NAME, this.linkArrays, this.standardArrayReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"source", this.linkArrays.source, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"target", this.linkArrays.target, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"linkType", this.linkArrays.linkType, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"directed", this.linkArrays.directed, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"nodePair", this.linkArrays.nodePair, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"presence", this.linkArrays.presence, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"weights", this.linkArrays.weights, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"filter", this.linkArrays.filter, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"attributes", this.linkArrays.attributes, this.standardReplacer);
            dataMgr.saveToStorage(this.name, this.nodePairArrays_NAME, this.nodePairArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.timeArrays_NAME, this.timeArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.linkTypeArrays_NAME, this.linkTypeArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.nodeTypeArrays_NAME, this.nodeTypeArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.locationArrays_NAME, this.locationArrays, this.standardArrayReplacer);
        }
        // Removes this graph from the cache.
        delete(dataMgr) {
            dataMgr.removeFromStorage(this.name, this.gran_min_NAME);
            dataMgr.removeFromStorage(this.name, this.gran_max_NAME);
            dataMgr.removeFromStorage(this.name, this.directed_NAME);
            dataMgr.removeFromStorage(this.name, this.minWeight_NAME);
            dataMgr.removeFromStorage(this.name, this.maxWeight_NAME);
            dataMgr.removeFromStorage(this.name, this.matrix_NAME);
            dataMgr.removeFromStorage(this.name, this.nodeArrays_NAME);
            // when we tried to persist the entire linkArrays, javascript threw an
            // exception, so for now we will simply try to save out the parts.
            dataMgr.removeFromStorage(this.name, this.linkArrays_NAME);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"source", this.linkArrays.source, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"target", this.linkArrays.target, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"linkType", this.linkArrays.linkType, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"directed", this.linkArrays.directed, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"nodePair", this.linkArrays.nodePair, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"presence", this.linkArrays.presence, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"weights", this.linkArrays.weights, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"filter", this.linkArrays.filter, this.standardReplacer);
            // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"attributes", this.linkArrays.attributes, this.standardReplacer);
            dataMgr.removeFromStorage(this.name, this.nodePairArrays_NAME);
            dataMgr.removeFromStorage(this.name, this.timeArrays_NAME);
            dataMgr.removeFromStorage(this.name, this.linkTypeArrays_NAME);
            dataMgr.removeFromStorage(this.name, this.nodeTypeArrays_NAME);
            dataMgr.removeFromStorage(this.name, this.locationArrays_NAME);
        }
        debugCompareTo(other) {
            var result = true;
            if (this.name != other.name) {
                console.log("name different");
                result = false;
            }
            // CACHEGRAPH compare every aspect of this one to the other one
            if (this.gran_min != other.gran_min) {
                console.log("gran_min different", this.gran_min, other.gran_min);
                result = false;
            }
            if (this.gran_max != other.gran_max) {
                console.log("gran_max different", this.gran_max, other.gran_max);
                result = false;
            }
            if (this.directed != other.directed) {
                console.log("directed different", this.directed, other.directed);
                result = false;
            }
            if (this._nodes.length != other._nodes.length
                || !compareTypesDeep(this._nodes, other._nodes, 2)) {
                console.log("nodes different");
                result = false;
            }
            if (this._links.length != other._links.length
                || !compareTypesDeep(this._links, other._links, 2)) {
                console.log("links different");
                result = false;
            }
            if (this._nodePairs.length != other._nodePairs.length
                || !compareTypesDeep(this._nodePairs, other._nodePairs, 2)) {
                console.log("nodePairs different");
                result = false;
            }
            if (this._locations.length != other._locations.length
                || !compareTypesDeep(this._locations, other._locations, 2)) {
                console.log("locations different");
                result = false;
            }
            if (this._times.length != other._times.length
                || !compareTypesDeep(this._times, other._times, 2)) {
                console.log("times different");
                result = false;
            }
            if ((this.nodeOrders && this.nodeOrders.length != other.nodeOrders.length)
                || !compareTypesDeep(this.nodeOrders, other.nodeOrders, 2)) {
                console.log("nodeOrders different", this.nodeOrders, other.nodeOrders);
                result = false;
            }
            if (this.matrix.length != other.matrix.length
                || !compareTypesDeep(this.matrix, other.matrix, 2)) {
                console.log("matrix different", this.matrix, other.matrix);
                result = false;
            }
            if (this.nodeArrays.length != other.nodeArrays.length
                || !compareTypesDeep(this.nodeArrays, other.nodeArrays, 2)) {
                console.log("nodeArrays different", this.nodeArrays, other.nodeArrays);
                result = false;
            }
            if (this.linkArrays.length != other.linkArrays.length
                || !compareTypesDeep(this.linkArrays, other.linkArrays, 2)) {
                console.log("linkArrays different", this.linkArrays, other.linkArrays);
                result = false;
            }
            if (this.nodePairArrays.length != other.nodePairArrays.length
                || !compareTypesDeep(this.nodePairArrays, other.nodePairArrays, 2)) {
                console.log("nodePairArrays different", this.nodePairArrays, other.nodePairArrays);
                result = false;
            }
            if (this.timeArrays.length != other.timeArrays.length
                || !compareTypesDeep(this.timeArrays, other.timeArrays, 2)) {
                console.log("timeArrays different", this.timeArrays, other.timeArrays);
                result = false;
            }
            if (this.linkTypeArrays.length != other.linkTypeArrays.length
                || !compareTypesDeep(this.linkTypeArrays, other.linkTypeArrays, 2)) {
                console.log("linkTypeArrays different", this.linkTypeArrays, other.linkTypeArrays);
                result = false;
            }
            if (this.nodeTypeArrays.length != other.nodeTypeArrays.length
                || !compareTypesDeep(this.nodeTypeArrays, other.nodeTypeArrays, 2)) {
                console.log("nodeTypeArrays different", this.nodeTypeArrays, other.nodeTypeArrays);
                result = false;
            }
            if (this.locationArrays.length != other.locationArrays.length
                || !compareTypesDeep(this.locationArrays, other.locationArrays, 2)) {
                console.log("locationArrays different", this.locationArrays, other.locationArrays);
                result = false;
            }
            if (this.defaultLinkSelection.elementIds.length != other.defaultLinkSelection.elementIds.length
                || !compareTypesDeep(this.defaultLinkSelection, other.defaultLinkSelection, 2)) {
                console.log("defaultLinkSelection different", this.defaultLinkSelection, other.defaultLinkSelection);
                result = false;
            }
            if (this.defaultNodeSelection.elementIds.length != other.defaultNodeSelection.elementIds.length
                || !compareTypesDeep(this.defaultNodeSelection, other.defaultNodeSelection, 2)) {
                console.log("defaultNodeSelection different", this.defaultNodeSelection, other.defaultNodeSelection);
                result = false;
            }
            if (this.selections.length != other.selections.length
                || !compareTypesDeep(this.selections, other.selections, 2)) {
                console.log("selections different", this.selections, other.selections);
                result = false;
            }
            return result;
        }
        // creates this graph and fills node, link and time arrays from
        // data tables.
        initDynamicGraph(data) {
            // must agree with version in main.ts
            var TIME_FORMAT = 'YYYY-MM-DD hh:mm:ss';
            this.clearSelections();
            console.log('[dynamicgraph.ts] Create dynamic graph for ', data.name, data);
            //this.data = data;s
            this.name = data.name;
            this.directed = data.directed;
            // fill node, link arrays and time
            // CREATE TIME OBJECT for all events
            this.gran_min = 0;
            this.gran_max = 0;
            if (isValidIndex(data.linkSchema.time)) {
                var timeLabel;
                var unixTimes = [];
                var unixTime;
                // get unix times for all times
                console.log("GEtting unix times for all times - linktable");
                console.log(data.linkTable);
                for (var i = 0; i < data.linkTable.length; i++) {
                    timeLabel = data.linkTable[i][data.linkSchema.time];
                    console.log(data.linkTable[i]);
                    unixTime = parseInt(moment.utc(timeLabel, TIME_FORMAT).format('x'));
                    if (unixTime == undefined)
                        continue;
                    if (unixTimes.indexOf(unixTime) == -1) {
                        unixTimes.push(unixTime);
                    }
                }
                // obtain granularity
                unixTimes.sort(sortNumber);
                var diff = 99999999999999;
                for (var i = 0; i < unixTimes.length - 2; i++) {
                    diff = Math.min(diff, unixTimes[i + 1] - unixTimes[i]);
                }
                if (diff >= 1000)
                    this.gran_min = 1;
                if (diff >= 1000 * 60)
                    this.gran_min = 2;
                if (diff >= 1000 * 60 * 60)
                    this.gran_min = 3;
                if (diff >= 1000 * 60 * 60 * 24)
                    this.gran_min = 4;
                if (diff >= 1000 * 60 * 60 * 24 * 7)
                    this.gran_min = 5;
                if (diff >= 1000 * 60 * 60 * 24 * 30)
                    this.gran_min = 6;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12)
                    this.gran_min = 7;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 10)
                    this.gran_min = 8;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 100)
                    this.gran_min = 9;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 1000)
                    this.gran_min = 10;
                diff = unixTimes[unixTimes.length - 1] - unixTimes[0];
                this.gran_max = 0;
                if (diff >= 1000)
                    this.gran_max = 1;
                if (diff >= 1000 * 60)
                    this.gran_max = 2;
                if (diff >= 1000 * 60 * 60)
                    this.gran_max = 3;
                if (diff >= 1000 * 60 * 60 * 24)
                    this.gran_max = 4;
                if (diff >= 1000 * 60 * 60 * 24 * 7)
                    this.gran_max = 5;
                if (diff >= 1000 * 60 * 60 * 24 * 30)
                    this.gran_max = 6;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12)
                    this.gran_max = 7;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 10)
                    this.gran_max = 8;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 100)
                    this.gran_max = 9;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 1000)
                    this.gran_max = 10;
                console.log('[Dynamic Graph] Minimal granularity', GRANULARITY[this.gran_min]);
                console.log('[Dynamic Graph] Maximal granularity', GRANULARITY[this.gran_max]);
                // create one time object for every time point of gran_min, between start and end time.
                // [bb] deprecated
                // var start = moment(unixTimes[0] + '', 'x').startOf(GRANULARITY[this.gran_min]);
                // var end = moment(unixTimes[unixTimes.length - 1] + '', 'x').startOf(GRANULARITY[this.gran_min]);
                // var numTimes = Math.ceil(Math.abs(start.diff(end, GRANULARITY[this.gran_min] + 's')));
                // var curr_t = start;
                // this._times = [];
                for (var i = 0; i < unixTimes.length; i++) {
                    this.timeArrays.id.push(i);
                    this.timeArrays.momentTime.push(moment.utc(unixTimes[i]));
                    this.timeArrays.label.push(this.timeArrays.momentTime[i].format(TIME_FORMAT));
                    this.timeArrays.unixTime.push(unixTimes[i]);
                    this.timeArrays.selections.push([]);
                    this.timeArrays.filter.push(false);
                    this.timeArrays.links.push([]);
                    // create time objects
                    this._times.push(new Time(i, this));
                    // curr_t = start.add(1, GRANULARITY[this.gran_min] + 's');
                }
                // Now, all existing times with events and potentially
                // attributes associated, have been created.
                // Below, we create a simple array of moment.moments
                // for any possible time unit for every aggregation level.
                // In fact, those structures are created on-demand, i.e.
                // the first time they are needed.
                // Here, we only create the meta-structure
                for (var g = 0; g <= GRANULARITY.length; g++) {
                    this.timeObjects.push([]); // AQUIIIII
                }
            }
            // if no valid have been found:
            if (this.timeArrays.length == 0) {
                // null time object that represents one time step for the entire graph, i.e. a static graph
                this.timeArrays.id.push(0);
                this.timeArrays.momentTime.push(moment.utc(0));
                this.timeArrays.unixTime.push(0);
                this.timeArrays.selections.push([]);
                this.timeArrays.filter.push(false);
                this.timeArrays.links.push([]);
                this._times.push(new Time(0, this));
            }
            // if there is a location table, then there needs to be locationSchema
            console.assert(!data.locationTable || isValidIndex(data.locationSchema.id));
            if (data.locationTable) {
                for (var i = 0; i < data.locationTable.length; i++) {
                    this.locationArrays.id.push(data.locationTable[i][data.locationSchema.id]);
                    this.locationArrays.label.push(data.locationTable[i][data.locationSchema.label]);
                    this.locationArrays.longitude.push(data.locationTable[i][data.locationSchema.longitude]);
                    this.locationArrays.latitude.push(data.locationTable[i][data.locationSchema.latitude]);
                    this.locationArrays.x.push(data.locationTable[i][data.locationSchema.x]);
                    this.locationArrays.y.push(data.locationTable[i][data.locationSchema.y]);
                    this.locationArrays.z.push(data.locationTable[i][data.locationSchema.z]);
                    this.locationArrays.radius.push(data.locationTable[i][data.locationSchema.radius]);
                }
            }
            if ('id' in this.locationArrays)
                console.log('locations', this.locationArrays.id.length);
            // CREATE NODES
            var row;
            var nodeId_data; // node id in data set
            var nodeId_table; // node id in table
            var time;
            console.assert(data.nodeTable.length == 0 || isValidIndex(data.nodeSchema.id), 'either there is no nodeTable data, or we have a schema for the nodetable');
            var nodeUserProperties = [];
            // Get user-properties on links, if exist
            for (var prop in data.nodeSchema) {
                if (data.nodeSchema.hasOwnProperty(prop)
                    && prop != 'id'
                    && prop != 'label'
                    && prop != 'time'
                    && prop != 'name'
                    && prop != 'nodeType'
                    && prop != 'location'
                    && prop != 'constructor') {
                    nodeUserProperties.push(prop);
                    // create property
                    this.nodeArrays[prop] = [];
                }
            }
            for (var i = 0; i < data.nodeTable.length; i++) {
                row = data.nodeTable[i];
                // check if id already exists
                nodeId_data = row[data.nodeSchema.id];
                nodeId_table = this.nodeArrays.id.indexOf(nodeId_data);
                if (nodeId_table == -1) {
                    nodeId_table = this.nodeArrays.id.length;
                    this.nodeArrays.id.push(nodeId_data);
                    this.nodeArrays.nodeType.push('');
                    this.nodeArrays.outLinks.push(new ArrayTimeSeries());
                    this.nodeArrays.inLinks.push(new ArrayTimeSeries());
                    this.nodeArrays.links.push(new ArrayTimeSeries()); // both, in and out
                    this.nodeArrays.outNeighbors.push(new ArrayTimeSeries());
                    this.nodeArrays.inNeighbors.push(new ArrayTimeSeries());
                    this.nodeArrays.neighbors.push(new ArrayTimeSeries());
                    this.nodeArrays.selections.push([]);
                    this.nodeArrays.filter.push(false);
                    this.nodeArrays.locations.push(new ScalarTimeSeries());
                    this.nodeArrays.attributes.push(new Object());
                    this.nodeArrays.color.push('');
                    this.nodeArrays.shape.push('');
                    if (isValidIndex(data.nodeSchema.label)) {
                        this.nodeArrays.label.push(row[data.nodeSchema.label]);
                    }
                    else {
                        this.nodeArrays.label.push(row[data.nodeSchema.id]);
                    }
                }
                // get time
                // if (isValidIndex(data.nodeSchema.time)) {
                if (isValidIndex(data.nodeSchema.time)) {
                    timeLabel = row[data.nodeSchema.time];
                    console.log("params");
                    console.log(timeLabel);
                    console.log(TIME_FORMAT);
                    console.log(moment.utc(timeLabel, TIME_FORMAT));
                    console.log(moment.utc(timeLabel, TIME_FORMAT).format('x'));
                    var timeIdForUnixTime = this.getTimeIdForUnixTime(parseInt(moment.utc(timeLabel, TIME_FORMAT).format('x')));
                    if (timeLabel == undefined || timeIdForUnixTime == undefined) { //} || timeStamp.indexOf('null')) {
                        time = this._times[0];
                    }
                    else {
                        time = this._times[timeIdForUnixTime];
                    }
                }
                else {
                    time = this._times[0];
                }
                if (time == undefined)
                    time = this._times[0];
                // check locations
                if (isValidIndex(data.nodeSchema.location)) {
                    var locId = row[data.nodeSchema.location];
                    if (locId == null || locId == undefined)
                        continue;
                    this.nodeArrays.locations[nodeId_data].set(time, locId);
                }
                // check shapes
                if (isValidIndex(data.nodeSchema.shape)) {
                    var shape = row[data.nodeSchema.shape];
                    this.nodeArrays.shape.push(shape);
                }
                // gather node type
                if (isValidIndex(data.nodeSchema.nodeType)) {
                    typeName = data.nodeTable[i][data.nodeSchema.nodeType];
                    typeId = this.nodeTypeArrays.name.indexOf(typeName);
                    if (typeId < 0) {
                        typeId = this.nodeTypeArrays.length;
                        this.nodeTypeArrays.id.push(typeId);
                        this.nodeTypeArrays.name.push(typeName);
                    }
                    this.nodeArrays.nodeType[nodeId_table] = typeName;
                    data.nodeTable[i][data.nodeSchema.nodeType] = typeId;
                }
                // gather user-properties:
                for (var p = 0; p < nodeUserProperties.length; p++) {
                    prop = nodeUserProperties[p];
                    this.nodeArrays[prop].push(row[data.nodeSchema[prop]]);
                }
                // see if temporal information is available
                // if(data.nodeSchema.time && data.nodeSchema.time > -1){
                //     for(var field in data.nodeSchema){
                //         if (field != undefined
                //             && data.nodeSchema.hasOwnProperty(field)
                //             && data.©nodeSchema[field] > -1
                //             && field != 'label'
                //             && field != 'time'
                //             && field != 'locations'
                //             && field != 'id'
                //             ){
                //                 if(this.nodeArrays.attributes[nodeId_table][field] == undefined){
                //                     this.nodeArrays.attributes[nodeId_table][field] = new ScalarTimeSeries();
                //                 }
                //                 timeLabel = data.nodeTable[i][data.nodeSchema.time];
                //                 if(timeLabel == undefined)
                //                     continue;
                //                 timeStamp = parseInt(moment(timeLabel, networkcube.TIME_FORMAT).format('x'));
                //                 time = this.times[this.getTimeIdForTimeStamp(timeStamp)];
                //                 this.nodeArrays[field][nodeId_table].set(time, row[data.nodeSchema[field]]);
                //             // //in case of locations:
                //             // if(field == 'location'){
                //             //     if(typeof row[data.nodeSchema[field]] == 'number'){
                //             //         id_loc = row[data.nodeSchema[field]];
                //             //     }
                //             // }
                //          }
                //     }
                // }else{
                //     // no time information available on nodes
                //     for(var field in data.nodeSchema){
                //         if (field != undefined
                //             && data.nodeSchema.hasOwnProperty(field)
                //             && data.nodeSchema[field] > -1
                //             && field != 'label'
                //             && field != 'time'
                //             && field != 'id'
                //             && field != 'locations'
                //             )
                //         {
                //             // check for non temporal information
                //             if(this.nodeArrays.attributes[nodeId_table][field] == undefined){
                //                 this.nodeArrays.attributes[nodeId_table][field] = new ScalarTimeSeries();
                //             }
                //             // eternal attributes are assigned no time.
                //             this.nodeArrays[field][nodeId_table].set(undefined, row[data.nodeSchema[field]]);
                //         }
                //     }
                // }
            }
            // create matrix and initialize with -1, i.e. nodes are not connected.
            if ('id' in this.nodeArrays) {
                for (var i = 0; i < this.nodeArrays.id.length; i++) {
                    this.matrix.push(array(undefined, this.nodeArrays.id.length));
                }
            }
            // CREATE LINKS
            var s, t;
            var timeId;
            var nodePairId;
            var linkId;
            var typeName;
            var typeId;
            var linkUserProperties = [];
            // Get user-properties on links, if exist
            for (var prop in data.linkSchema) {
                if (data.linkSchema.hasOwnProperty(prop)
                    && prop != 'id'
                    && prop != 'linkType'
                    && prop != 'time'
                    && prop != 'name'
                    && prop != 'source'
                    && prop != 'target'
                    && prop != 'weight'
                    && prop != 'directed') {
                    linkUserProperties.push(prop);
                    // create property
                    this.linkArrays[prop] = [];
                }
            }
            console.log('linkUserProperties', linkUserProperties);
            console.assert(data.linkTable.length == 0 || (isValidIndex(data.linkSchema.id)
                && isValidIndex(data.linkSchema.source)
                && isValidIndex(data.linkSchema.target)), 'either there are no links, or the linkschema is defined');
            for (var i = 0; i < data.linkTable.length; i++) {
                row = data.linkTable[i];
                linkId = row[data.linkSchema.id];
                this.linkArrays.directed.push(false); // this is default and can be overwritten in the following.
                // check if linkId, i.e. link exists
                if (this.linkArrays.id.indexOf(linkId) == -1) {
                    // init new link
                    this.linkArrays.id[linkId] = linkId;
                    this.linkArrays.source[linkId] = row[data.linkSchema.source];
                    this.linkArrays.target[linkId] = row[data.linkSchema.target];
                    this.linkArrays.linkType[linkId] = row[data.linkSchema.linkType];
                    this.linkArrays.directed[linkId] = row[data.linkSchema.directed];
                    this.linkArrays.weights[linkId] = new ScalarTimeSeries();
                    this.linkArrays.presence[linkId] = [];
                    this.linkArrays.selections.push([]);
                    this.linkArrays.nodePair.push(undefined);
                    this.linkArrays.filter.push(false);
                }
                // set time information
                if (isValidIndex(data.linkSchema.time)) {
                    timeLabel = data.linkTable[i][data.linkSchema.time];
                    unixTime = parseInt(moment.utc(timeLabel, TIME_FORMAT).format('x'));
                    var timeIdForUnixTime = this.getTimeIdForUnixTime(unixTime);
                    if (timeIdForUnixTime != undefined) {
                        timeId = timeIdForUnixTime;
                    }
                    else {
                        timeId = 0;
                    }
                }
                else {
                    timeId = 0;
                }
                time = this._times[timeId];
                this.linkArrays.presence[linkId].push(timeId);
                // set weight if applies
                if (isValidIndex(data.linkSchema.weight) && data.linkTable[i][data.linkSchema.weight] != undefined) {
                    this.linkArrays.weights[linkId].set(time, data.linkTable[i][data.linkSchema.weight]);
                    this.minWeight = Math.min(this.minWeight, data.linkTable[i][data.linkSchema.weight]);
                    this.maxWeight = Math.max(this.maxWeight, data.linkTable[i][data.linkSchema.weight]);
                }
                else {
                    // set one = presence
                    this.minWeight = 0;
                    this.maxWeight = 1;
                    this.linkArrays.weights[linkId].set(time, 1);
                }
                // add graph specific information
                s = this.nodeArrays.id.indexOf(row[data.linkSchema.source]);
                t = this.nodeArrays.id.indexOf(row[data.linkSchema.target]);
                this.nodeArrays.neighbors[s].add(time, t);
                this.nodeArrays.neighbors[t].add(time, s);
                this.nodeArrays.links[s].add(time, linkId);
                this.nodeArrays.links[t].add(time, linkId);
                // for directed links, fill the in/out arrays
                if (this.linkArrays.directed[i]) {
                    this.nodeArrays.outNeighbors[s].add(time, t);
                    this.nodeArrays.inNeighbors[t].add(time, s);
                    this.nodeArrays.outLinks[s].add(time, linkId);
                    this.nodeArrays.inLinks[t].add(time, linkId);
                }
                //link pairs
                // a node pair is stored in a matrix structure for easy access.
                // For every direction (s,t) and (t,s), an individual link pair
                // exists. If an underlying link is undirected, it is referenced
                // in both node pairs.
                nodePairId = this.matrix[s][t];
                if (!isValidIndex(nodePairId)) {
                    nodePairId = this.nodePairArrays.length;
                    this.matrix[s][t] = nodePairId;
                    this.nodePairArrays.id.push(nodePairId);
                    this.nodePairArrays.source.push(s);
                    this.nodePairArrays.target.push(t);
                    this.nodePairArrays.links.push([]);
                    this.nodePairArrays.selections.push([]);
                    this.nodePairArrays.filter.push(false);
                }
                // add link only, if not already exist
                if (this.nodePairArrays.links[nodePairId].indexOf(linkId) == -1) {
                    this.nodePairArrays.links[nodePairId].push(linkId);
                    this.linkArrays.nodePair[linkId] = nodePairId;
                }
                //May affect matrix view, but breaks nodelink directionality
                // if (this.linkArrays.directed[i]) {
                //     nodePairId = this.matrix[t][s];
                //     if (!nodePairId) {
                //         nodePairId = this.nodePairArrays.id.length;
                //         this.matrix[t][s] = nodePairId;
                //         this.nodePairArrays.id.push(nodePairId);
                //         this.nodePairArrays.source.push(t);
                //         this.nodePairArrays.target.push(s);
                //         this.nodePairArrays.links.push(doubleArray(this._times.length));
                //     }
                //     // add link only, if not already exist
                //     if (this.nodePairArrays.links[nodePairId].indexOf(linkId) == -1) {
                //         this.nodePairArrays.links[nodePairId].push(linkId);
                //         this.linkArrays.nodePair[linkId] = nodePairId;
                //     }
                // }
                // gather link types
                if (isValidIndex(data.linkSchema.linkType)) {
                    typeName = data.linkTable[i][data.linkSchema.linkType];
                    typeId = this.linkTypeArrays.name.indexOf(typeName);
                    if (typeId < 0) {
                        typeId = this.linkTypeArrays.length;
                        this.linkTypeArrays.id.push(typeId);
                        this.linkTypeArrays.name.push(typeName);
                    }
                    data.linkTable[i][data.linkSchema.linkType] = typeId;
                }
                // gather user-properties:
                for (var p = 0; p < linkUserProperties.length; p++) {
                    prop = linkUserProperties[p];
                    this.linkArrays[prop].push(row[data.linkSchema[prop]]);
                }
            }
            // For every time, store a pointer to all its links:
            // var allLinks = links().toArray();
            // var allTimes = this.g.times().toArray();
            for (var i = 0; i < this.linkArrays.length; i++) {
                for (var j = 0; j < this.timeArrays.length; j++) {
                    if (this.linkArrays.weights[i]) {
                        if (this.linkArrays.weights[i].toArray().hasOwnProperty(this.timeArrays.id[j].toString())) {
                            this.timeArrays.links[j].push(this.linkArrays.id[i]);
                        }
                    }
                }
            }
            //Build a color mapping
            const colorSet = new Set(['#e4549b', '#a33a36', '#bd6221', '#dfba47', '#b5b867', '#479b7f', '#335b8e', '#78387d']);
            var colorMappings = {};
            this.nodeArrays.color.forEach(function (color) {
                if (!colorMappings[color]) {
                    let colorSetAsArray = Array.from(colorSet);
                    var generatedColor = colorSetAsArray[Math.floor(Math.random() * colorSetAsArray.length)];
                    colorMappings[color] = generatedColor;
                    colorSet.delete(generatedColor);
                }
            });
            //Add color values to nodeArray colors
            for (var i = 0; i < this.nodeArrays.color.length; i++) {
                this.nodeArrays.color[i] = this.nodeArrays.color[i], colorMappings[this.nodeArrays.color[i]];
            }
            //Build a shape mapping
            const shapeSet = new Set(['cross', 'diamond', 'square', 'triangle-down', 'triangle-up']);
            var shapeMappings = {};
            this.nodeArrays.shape.forEach(function (shape) {
                if (!shapeMappings[shape]) {
                    let shapeSetAsArray = Array.from(shapeSet);
                    var generatedShape = shapeSetAsArray[Math.floor(Math.random() * shapeSetAsArray.length)];
                    shapeMappings[shape] = generatedShape;
                    shapeSet.delete(generatedShape);
                }
            });
            //Add shapes to nodeArray shapes
            for (var i = 0; i < this.nodeArrays.shape.length; i++) {
                this.nodeArrays.shape[i] = this.nodeArrays.shape[i], shapeMappings[this.nodeArrays.shape[i]];
            }
            console.log(" TEST ");
            console.log(this);
            // create color map for link types
            var linkTypeCount = this.linkTypeArrays.length;
            console.log('[Dynamic Graph] Dynamic Graph created: ', this.nodeArrays.length);
            console.log('[Dynamic Graph]    - Nodes: ', this.nodeArrays.length);
            console.log('[Dynamic Graph]    - Edges: ', this.linkArrays.length);
            console.log('[Dynamic Graph]    - Times: ', this.timeArrays.length);
            console.log('[Dynamic Graph]    - Link types: ', this.linkTypeArrays.length);
            console.log('[Dynamic Graph]    - Node Pairs: ', this.nodePairArrays.length);
            console.log('>>>this.nodeArrays["neighbors"][0]', this.nodeArrays['neighbors'][0]);
            // inits the WindowGraph for this dynamic graph, i.e.
            // the all-aggregated graph.
            this.createGraphObjects(true, true); //false, false);
            this.createSelections(false);
        }
        createSelections(shouldCreateArrays) {
            // CREATE SELECTIONS
            if (shouldCreateArrays) {
                if (!('nodeArrays' in this && this.nodeArrays)) {
                    this.nodeArrays = new NodeArray();
                    this.linkArrays = new LinkArray();
                    this.timeArrays = new TimeArray();
                    this.nodePairArrays = new NodePairArray();
                }
                this.nodeArrays.selections = new Array(this.nodeArrays.length);
                for (var i = 0; i < this.nodeArrays.selections.length; i++) {
                    this.nodeArrays.selections[i] = [];
                }
                this.linkArrays.selections = new Array(this.linkArrays.length);
                for (var i = 0; i < this.linkArrays.selections.length; i++) {
                    this.linkArrays.selections[i] = [];
                }
                this.timeArrays.selections = new Array(this.timeArrays.length);
                for (var i = 0; i < this.timeArrays.selections.length; i++) {
                    this.timeArrays.selections[i] = [];
                }
                this.nodePairArrays.selections = new Array(this.nodePairArrays.length);
                for (var i = 0; i < this.nodePairArrays.selections.length; i++) {
                    this.nodePairArrays.selections[i] = [];
                }
            }
            // create default selections for each type
            this.defaultNodeSelection = this.createSelection('node');
            this.defaultNodeSelection.name = 'Unselected';
            for (var i = 0; i < this._nodes.length; i++) {
                this.defaultNodeSelection.elementIds.push(i);
                this.addToAttributeArraysSelection(this.defaultNodeSelection, 'node', this._nodes[i].id());
            }
            this.defaultNodeSelection.color = '#000000';
            this.defaultNodeSelection.showColor = false;
            this.defaultNodeSelection.priority = 10000;
            this.selectionColor_pointer--;
            this.defaultLinkSelection = this.createSelection('link');
            this.defaultLinkSelection.name = 'Unselected';
            for (var i = 0; i < this._links.length; i++) {
                this.defaultLinkSelection.elementIds.push(i);
                this.addToAttributeArraysSelection(this.defaultLinkSelection, 'link', this._links[i].id());
            }
            this.defaultLinkSelection.color = '#000000';
            this.defaultLinkSelection.showColor = false;
            this.defaultLinkSelection.priority = 10000;
            this.selectionColor_pointer--;
            // create selections for node types
            var types = [];
            var type, index;
            var selection;
            var nodeSelections = [];
            for (var i = 0; i < this.nodeArrays.nodeType.length; i++) {
                type = this.nodeArrays.nodeType[i];
                if (type == undefined || type.length == 0 || type == 'undefined')
                    continue;
                index = types.indexOf(type);
                if (index == -1) {
                    selection = this.createSelection('node');
                    selection.name = type;
                    nodeSelections.push(selection);
                    types.push(type);
                }
                else {
                    selection = nodeSelections[index];
                }
                this.addElementToSelection(selection, this._nodes[i]);
                // this.addToSelection(selection, this._nodes[i].id(), 'node');
            }
            if (nodeSelections.length == 1) {
                console.log('nodeSelections[0]:', nodeSelections[0]);
                nodeSelections[0].color = '#444';
            }
            // create selections for link type
            types = [];
            var linkSelections = [];
            for (var i = 0; i < this.linkArrays.linkType.length; i++) {
                type = this.linkArrays.linkType[i];
                if (!type || type == 'undefined')
                    continue;
                index = types.indexOf(type);
                if (index == -1) {
                    selection = this.createSelection('link');
                    selection.name = type;
                    linkSelections.push(selection);
                    types.push(type);
                }
                else {
                    selection = linkSelections[index];
                }
                this.addElementToSelection(selection, this._links[i]);
                // this.addToSelection(selection, this._links[i].id(), 'link');
            }
            if (linkSelections.length == 1)
                linkSelections[0].color = '#444';
            // create selections for node type
            // types = [];
            // var nodeSelections: Selection[] = [];
            // for (var i = 0; i < this.nodeArrays.nodeType.length; i++) {
            //     type = this.nodeArrays.nodeType[i];
            //     if (!type || type == 'undefined')
            //         continue;
            //     index = types.indexOf(type);
            //     if (index == -1) {
            //         selection = this.createSelection('node');
            //         selection.name = type;
            //         nodeSelections.push(selection)
            //         types.push(type);
            //     } else {
            //         selection = nodeSelections[index];
            //     }
            //     this.addElementToSelection(selection, this._nodes[i]);
            //     // this.addToSelection(selection, this._links[i].id(), 'link');
            // }
            this.currentSelection_id = 0;
        }
        // GRAPH API //////////////////
        /**
         *
         * Returns a window graph for the passed time point
         * or period
         * @param  {any}    start First time point of this graph
         * @param  {any}    end   Last time point of this graph.
         * @return {[type]}       [description]
         */
        // getGraph(start: Time, end?: Time): WindowGraph {
        //     var g: WindowGraph = new WindowGraph();
        //     return this.createGraph(g, start, end);
        // }
        // Creates a new graph with all nodes and edges from start to end.
        // CACHEGRAPH : this code needs to be leveraged to initialize all of the fields from
        // windowGraph that are now part of this class
        createGraphObjects(shouldCreateTimes, shouldCreateLinkTypes) {
            // measure time:
            console.log('[DynamicNetwork:createGraph()] >>> ');
            var d = Date.now();
            // POPULATE WINDOW GRAPH
            // populate locations
            if (this.locationArrays && 'id' in this.locationArrays) {
                for (var i = 0; i < this.locationArrays.id.length; i++) {
                    this._locations.push(new Location(this.locationArrays.id[i], this));
                }
            }
            else {
                this.locationArrays = new LocationArray();
            }
            // Populate nodes
            var nodes = [];
            if ('nodeArrays' in this && this.nodeArrays) {
                for (var i = 0; i < this.nodeArrays.id.length; i++) {
                    nodes.push(new Node(i, this));
                }
            }
            // Populate links
            var links = [];
            var link;
            if ('linkArrays' in this && this.linkArrays) {
                for (var i = 0; i < this.linkArrays.source.length; i++) {
                    link = new Link(i, this);
                    links.push(link);
                }
            }
            var pairLinks;
            if ('nodePairArrays' in this && this.nodePairArrays) {
                for (var i = 0; i < this.nodePairArrays.length; i++) {
                    pairLinks = this.nodePairArrays.links[i];
                    this._nodePairs.push(new NodePair(i, this));
                    // for (var j = 0; j < pairLinks.length; j++) {
                    //     pairLinkId = pairLinks[j];
                    //     pair = undefined;
                    //     for (var k = 0; k < nodePairs.length; k++) {
                    //         if (nodePairs[k].id == i) {
                    //             pair = nodePairs[k];
                    //             break;
                    //         }
                    //     }
                    //     if (!pair) {
                    //         pair = new NodePair(i, this);
                    //         nodePairs.push(pair)
                    //         thisGraphNodePairIds.push(i)
                    //         pair.source = nodes[this.pairAttr('source', i)];
                    //         pair.target = nodes[this.pairAttr('target', i)];
                    //     }
                    //     for (var k = 0; k < links.length; k++) {
                    //         if (links[k].id == pairLinkId) {
                    //             link = links[k];
                    //             break;
                    //         }
                    //     }
                    //     pair.links.push(link);
                    //     link.nodePair = pair;
                    // }
                }
            }
            this._nodes = nodes;
            this._links = links;
            // this.nodePairs = nodePairs;
            if (shouldCreateTimes) { // && 'timesArrays' in this && this.timeArrays) {
                this._times = [];
                for (var i = 0; i < this.timeArrays.length; i++)
                    this._times.push(new Time(i, this));
            }
            // if (shouldCreateLinkTypes) {
            //     var linkTypeCount: number = this.linkTypeArrays.length;
            //     var colorScale;
            //     if (linkTypeCount <= 10) {
            //         colorScale = d3.scale.category10();
            //     } else {
            //         colorScale = d3.scale.category20();
            //     }
            //     for (var i = 0; i < this.linkTypeArrays.name.length; i++) {
            //         this.linkTypes.push(new LinkType(
            //             this.linkTypeArrays.id[i],
            //             this.linkTypeArrays.name[i],
            //             this.linkTypeArrays.color[i]
            //         ));
            //     }
            // }
            console.log('[DynamicNetwork:getGraph()] <<< ', Date.now() - d, 'msec');
        }
        // all attribute accessor method
        nodeAttr(attr, id) {
            return this.attr(attr, id, 'node');
        }
        linkAttr(attr, id) {
            return this.attr(attr, id, 'link');
        }
        pairAttr(attr, id) {
            return this.attr(attr, id, 'nodePair');
        }
        timeAttr(attr, id) {
            return this.attr(attr, id, 'time');
        }
        get startTime() { return this._times[0]; }
        get endTime() { return this._times[this._times.length - 1]; }
        // /// SELECTIONS
        // // selections store ids of objects only.
        highlight(action, idCompound) {
            if (action == 'reset') {
                // reset all
                this.highlightArrays.nodeIds = [];
                this.highlightArrays.linkIds = [];
                this.highlightArrays.nodePairIds = [];
                this.highlightArrays.timeIds = [];
                return;
            }
            if (!idCompound) {
                console.error('[DynamicGraph] highlight: idCompound not set!');
                return;
            }
            if (action == 'set') {
                this.highlight('reset');
                this.highlight('add', idCompound);
                return;
            }
            // if(action == 'add'){
            //     for(var i=0 ; i<elementIds.length ; i++){
            //         if(this.highlightArrays[type].indexOf(elementIds[i]) == -1)
            //             this.highlightArrays[type].push(elementIds[i]);
            //     }
            // }else
            // if(action == 'remove'){
            //     for(var i=0 ; i<elementIds.length ; i++){
            //         if(this.highlightArrays[type].indexOf(elementIds[i]) > -1)
            //              this.highlightArrays[type].splice(this.highlightArrays[type].indexOf(elementIds[i]),1)
            //     }
            // }
            if (action == 'add') {
                for (var type in idCompound) {
                    for (var i = 0; i < idCompound[type].length; i++) {
                        this.highlightArrays[type].push(idCompound[type][i]);
                    }
                }
            }
            else if (action == 'remove') {
                var index;
                for (var type in idCompound) {
                    for (var i = 0; i < idCompound[type].length; i++) {
                        index = this.highlightArrays[type].indexOf(idCompound[type][i]);
                        if (index >= 0)
                            this.highlightArrays[type].splice(index, 1);
                    }
                }
            }
        }
        // SELECT
        selection(action, idCompound, selectionId) {
            if (selectionId == undefined)
                selectionId = this.currentSelection_id;
            var selection = this.getSelection(selectionId);
            if (!selection) {
                console.error('[DynamicGraph] Selection with ', selectionId, 'not found in ', this.selections);
                return; // WITH RETURN ?
            }
            var self = this;
            if (action == 'set') {
                var c = new IDCompound();
                c[selection.acceptedType] = selection.elementIds;
                this.selection('remove', c, selectionId);
                this.selection('add', idCompound, selectionId);
            }
            else if (action == 'add') {
                idCompound.linkIds.forEach((v, i, arr) => self.addToSelectionByTypeAndId(selection, 'link', v));
                idCompound.nodeIds.forEach((v, i, arr) => self.addToSelectionByTypeAndId(selection, 'node', v));
                idCompound.timeIds.forEach((v, i, arr) => self.addToSelectionByTypeAndId(selection, 'time', v));
                idCompound.nodePairIds.forEach((v, i, arr) => self.addToSelectionByTypeAndId(selection, 'nodePair', v));
            }
            else if (action == 'remove') {
                idCompound.linkIds.forEach((v, i, arr) => self.removeFromSelectionByTypeAndId(selection, 'link', v));
                idCompound.nodeIds.forEach((v, i, arr) => self.removeFromSelectionByTypeAndId(selection, 'node', v));
                idCompound.timeIds.forEach((v, i, arr) => self.removeFromSelectionByTypeAndId(selection, 'time', v));
                idCompound.nodePairIds.forEach((v, i, arr) => self.removeFromSelectionByTypeAndId(selection, 'nodePair', v));
            }
        }
        // SELFIX : delegate to dgraph
        addToAttributeArraysSelection(selection, type, id) {
            // check for priority of selections, then add where appropriate
            var elementSelections = this.attributeArrays[type].selections[id];
            for (var i = 0; i < elementSelections.length; i++) {
                if (elementSelections[i].priority > selection.priority) {
                    this.attributeArrays[type].selections[id].splice(i, 0, selection);
                    return;
                }
            }
            // if not already selected and if not higher priority than any other
            // selection, append to the end.
            this.attributeArrays[type].selections[id].push(selection);
        }
        // SELFIX : delegate to dgraph
        removeFromAttributeArraysSelection(selection, type, id) {
            var arr = this.attributeArrays[type].selections[id];
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] == selection)
                    this.attributeArrays[type].selections[id].splice(i, 1);
            }
        }
        addElementToSelection(selection, e) {
            this.addToSelectionByTypeAndId(selection, e.type, e.id());
        }
        addToSelectionByTypeAndId(selection, type, id) {
            if (type != selection.acceptedType) {
                console.log('attempting to put object of the wrong type into a selection');
                return; // don't proceed with selection;
            }
            selection.elementIds.push(id);
            this.addToAttributeArraysSelection(selection, type, id);
            // =======
            //                 this.selection('add', idCompound, selectionId);
            //             } else {
            //                 if (action == 'add') {
            //                     for (var field in idCompound) {
            //                         for (var i = 0; i < idCompound[field].length; i++) {
            //                             this.addToSelection(selection, idCompound[field][i], field)
            //                         }
            //                     }
            //                 } else {
            //                     if (action == 'remove') {
            //                         for (var field in idCompound) {
            //                             for (var i = 0; i < idCompound[field].length; i++) {
            //                                 for (var j = 0; j < selection.elementIds.length; j++) {
            //                                     if (selection.elementIds[j] == idCompound[field][i].id) {
            //                                         this.removeFromSelection(selection, idCompound[field][i], field);
            //                                     }
            //                                 }
            //                             }
            //                         }
            //                     }
            //                 }
            //             }
            //         }
            //         addToSelection(selection: Selection, id:number, elementType:string) {
            //             selection.elementIds.push(id);
            //             var e:BasicElement = this.get(elementType, id);
            //             e.addToSelection(selection);
            // >>>>>>> api
            // remove from default selection
            var i;
            if (type == 'node') {
                i = this.defaultNodeSelection.elementIds.indexOf(id);
                if (i > -1) {
                    this.removeFromAttributeArraysSelection(this.defaultNodeSelection, type, id);
                    this.defaultNodeSelection.elementIds.splice(i, 1);
                }
            }
            else if (type == 'link') {
                i = this.defaultLinkSelection.elementIds.indexOf(id);
                if (i > -1) {
                    this.removeFromAttributeArraysSelection(this.defaultLinkSelection, type, id);
                    this.defaultLinkSelection.elementIds.splice(i, 1);
                }
            }
        }
        // <<<<<<< HEAD
        removeElementFromSelection(selection, e) {
            this.removeFromSelectionByTypeAndId(selection, e.type, e.id());
        }
        removeFromSelectionByTypeAndId(selection, type, id) {
            // selection.elements.push(compound[field][i])
            // e.addToSelection(selection);
            // =======
            //         removeFromSelection(selection: Selection, id:number, elementType:string) {
            // >>>>>>> api
            var i = selection.elementIds.indexOf(id);
            if (i == -1)
                return;
            selection.elementIds.splice(i, 1);
            // <<<<<<< HEAD
            this.removeFromAttributeArraysSelection(selection, type, id);
            // =======
            //             var e:BasicElement = this.get(elementType, id);
            //             e.removeFromSelection(selection);
            // >>>>>>> api
            // add to default selection
            if (this.getSelectionsByTypeAndId(type, id).length == 0) {
                if (type == 'node') {
                    this.defaultNodeSelection.elementIds.push(id);
                    this.addToAttributeArraysSelection(this.defaultNodeSelection, type, id);
                }
                else if (type == 'link') {
                    this.defaultLinkSelection.elementIds.push(id);
                    this.addToAttributeArraysSelection(this.defaultLinkSelection, type, id);
                }
            }
        }
        getSelectionsByTypeAndId(type, id) {
            return this.attributeArrays[type].selections[id];
        }
        filterSelection(selectionId, filter) {
            var selection = this.getSelection(selectionId);
            if (selection != undefined) {
                selection.filter = filter;
            }
        }
        isFiltered(id, type) {
            return this.attributeArrays[type + 's'].filter;
        }
        isHighlighted(id, type) {
            return this.highlightArrays[type + 'Ids'].indexOf(id) > -1;
        }
        getHighlightedIds(type) {
            return this.highlightArrays[type + 'Ids'];
        }
        setCurrentSelection(id) {
            // [bbach] why should we ignore them?
            // if (id < 2) // i.e. either default node or link selection..
            //     return;  // ignore
            console.log('[DynamicGraph] setCurrentSelectionId ', id);
            this.currentSelection_id = id;
        }
        getCurrentSelection() {
            return this.getSelection(this.currentSelection_id);
        }
        addSelection(id, color, acceptedType, priority) {
            var s = this.createSelection(acceptedType);
            s.id = id;
            s.color = color;
            s.priority = priority;
        }
        // creates a selection for the passed type.
        createSelection(type) {
            var s = new Selection(this.selections.length, type);
            s.color = this.BOOKMARK_COLORS(this.selectionColor_pointer % 10);
            this.selectionColor_pointer++;
            this.selections.push(s);
            return s;
        }
        deleteSelection(selectionId) {
            var s = this.getSelection(selectionId);
            // remove all elements from this selection
            // <<<<<<< HEAD
            //             var compound: ElementCompound = new ElementCompound();
            //             compound[s.acceptedType + 'Ids'] = s.elementIds.slice(0);
            //             this.selection('remove', compound, s.id)
            // =======
            // remove
            if (s != undefined) {
                var idCompound = new IDCompound();
                idCompound[s.acceptedType + 'Ids'] = s.elementIds.slice(0);
                console.log('Delete selection->remove elemeents', s.elementIds.slice(0));
                this.selection('remove', idCompound, s.id);
                // >>>>>>> api
                // delete selection
                this.selections.splice(this.selections.indexOf(s), 1);
            }
        }
        setSelectionColor(id, color) {
            var s = this.getSelection(id);
            if (!s) {
                return;
            }
            s.color = color;
        }
        getSelections(type) {
            var selections = [];
            if (type) {
                for (var i = 0; i < this.selections.length; i++) {
                    if (this.selections[i].acceptsType(type))
                        selections.push(this.selections[i]);
                }
                return selections;
            }
            else {
                return this.selections;
            }
        }
        getSelection(id) {
            for (var i = 0; i < this.selections.length; i++) {
                if (id == this.selections[i].id)
                    return this.selections[i];
            }
            console.error('[DynamicGraph] No selection with id ', id, 'found!');
            /* If not found ?? */
            return undefined;
        }
        clearSelections() {
            this.selections = [];
        }
        // internal utils
        getTimeIdForUnixTime(unixTime) {
            var timeId;
            console.log("unixTime: ");
            console.log(unixTime);
            for (timeId = 0; timeId < this.timeArrays.length; timeId++) {
                if (unixTime == this.timeArrays.unixTime[timeId]) {
                    return timeId;
                }
            }
            console.error('Time object for unix time', unixTime, 'not found!');
            return undefined;
        }
        // ORDERING
        /* adds an specific node order (e.g. alphabetical) */
        // go into dynamicgraph
        addNodeOrdering(name, order) {
            for (var i = 0; i < this.nodeOrders.length; i++) {
                if (this.nodeOrders[i].name == name) {
                    console.error('Ordering', name, 'already exists');
                    return;
                }
            }
            var o = new Ordering(name, order);
            this.nodeOrders.push(o);
        }
        setNodeOrdering(name, order) {
            for (var i = 0; i < this.nodeOrders.length; i++) {
                if (this.nodeOrders[i].name == name) {
                    this.nodeOrders[i].order = order;
                    return;
                }
            }
            console.error('Ordering', name, 'does not exist');
        }
        removeNodeOrdering(name, order) {
            for (var i = 0; i < this.nodeOrders.length; i++) {
                if (this.nodeOrders[i].name == name) {
                    this.nodeOrders.splice(i, 1);
                }
            }
        }
        getNodeOrder(name) {
            for (var i = 0; i < this.nodeOrders.length; i++) {
                if (this.nodeOrders[i].name == name) {
                    return this.nodeOrders[i];
                }
            }
            console.error('Ordering', name, 'not found!');
            return;
        }
        // returns elements
        nodes() {
            return new NodeQuery(this.nodeArrays.id, this);
        }
        links() {
            return new LinkQuery(this.linkArrays.id, this);
        }
        times() {
            return new TimeQuery(this.timeArrays.id, this);
        }
        locations() {
            return new LocationQuery(this.locationArrays.id, this);
        }
        nodePairs() {
            return new NodePairQuery(this.nodePairArrays.id, this);
        }
        linksBetween(n1, n2) {
            var nodePairId = this.matrix[n1.id()][n2.id()];
            if (nodePairId == undefined)
                nodePairId = this.matrix[n2.id()][n1.id()];
            if (nodePairId == undefined)
                return new LinkQuery([], this);
            /* UNDEFINED? */
            var node_pair = this.nodePair(nodePairId);
            if (node_pair != undefined)
                return new LinkQuery(node_pair.links().toArray(), this);
            else
                return new LinkQuery([], this);
        }
        // generic accessor method. should not be used externally
        get(type, id) {
            if (type.indexOf('nodePair') > -1)
                return this.nodePair(id);
            if (type.indexOf('node') > -1)
                return this.node(id);
            if (type.indexOf('link') > -1)
                return this.link(id);
            if (type.indexOf('time') > -1)
                return this.time(id);
            if (type.indexOf('locations') > -1)
                return this.location(id);
        }
        getAll(type) {
            if (type == 'nodes')
                return this.nodes();
            if (type == 'links')
                return this.links();
            if (type == 'times')
                return this.times();
            if (type == 'nodePairs')
                return this.nodePairs();
            // if (type == 'locations')
            return this.locations();
        }
        // returns the node with ID
        node(id) {
            for (var i = 0; i < this._nodes.length; i++) {
                if (this._nodes[i].id() == id)
                    return this._nodes[i];
            }
        }
        link(id) {
            for (var i = 0; i < this._links.length; i++) {
                if (this._links[i].id() == id)
                    return this._links[i];
            }
        }
        time(id) {
            for (var i = 0; i < this._times.length; i++) {
                if (this._times[i].id() == id)
                    return this._times[i];
            }
        }
        location(id) {
            for (var i = 0; i < this._locations.length; i++) {
                if (this._locations[i].id() == id)
                    return this._locations[i];
            }
        }
        nodePair(id) {
            for (var i = 0; i < this._nodePairs.length; i++) {
                if (this._nodePairs[i].id() == id)
                    return this._nodePairs[i];
            }
        }
        getMinGranularity() { return this.gran_min; }
        getMaxGranularity() { return this.gran_max; }
    }
    // A time series with one scalar value for every time point
    class AttributeArray {
        constructor() {
            this.id = [];
        }
        get length() {
            return this.id.length;
        }
    }
    class NodeArray extends AttributeArray {
        constructor() {
            super(...arguments);
            this.id = [];
            this.label = [];
            // nodeType: ScalarTimeSeries<string>[] = [];
            this.outLinks = []; // contains link ids only, since every GRAPH has its own EDGE object instance
            this.inLinks = []; // contains link ids only, since every GRAPH has its own EDGE object instance
            this.links = [];
            this.outNeighbors = []; // contains node ids only, since every GRAPH has its own NODE object instance
            this.inNeighbors = []; // contains node ids only, since every GRAPH has its own NODE object instance
            this.neighbors = [];
            this.selections = [];
            this.attributes = []; // arbitrary attributes (key -> value)
            this.locations = [];
            this.filter = [];
            this.nodeType = [];
            this.color = [];
            this.shape = [];
        }
    }
    class LinkArray extends AttributeArray {
        constructor() {
            super(...arguments);
            this.source = [];
            this.target = [];
            this.linkType = [];
            this.directed = [];
            this.nodePair = []; // before number but it don't accept undefined
            // array of all time ids (temporally ordered) when this link is present
            this.presence = [];
            // array of weights per time this link is present. This is a generic field
            // that can be used for weights, e.g.
            this.weights = [];
            this.selections = [];
            this.filter = [];
            this.attributes = new Object; // arbitrary attributes (key -> value)
        }
    }
    class NodePairArray extends AttributeArray {
        constructor() {
            super(...arguments);
            this.source = [];
            this.target = [];
            this.links = [];
            this.selections = [];
            this.filter = [];
        }
    }
    class TimeArray extends AttributeArray {
        constructor() {
            super(...arguments);
            this.id = [];
            this.momentTime = []; // moment object
            this.label = [];
            this.unixTime = []; // unix time object
            this.selections = [];
            this.filter = [];
            this.links = []; // all links at that time
        }
    }
    class LinkTypeArray extends AttributeArray {
        constructor() {
            super(...arguments);
            this.name = [];
            this.count = [];
            this.color = [];
            this.filter = [];
        }
    }
    class NodeTypeArray extends AttributeArray {
        constructor() {
            super(...arguments);
            this.name = [];
            this.count = [];
            this.color = [];
            this.filter = [];
        }
    }
    class LocationArray extends AttributeArray {
        constructor() {
            super(...arguments);
            this.id = [];
            this.label = [];
            this.longitude = [];
            this.latitude = [];
            this.x = [];
            this.y = [];
            this.z = [];
            this.radius = [];
        }
    }
    class NodeType {
        constructor(id, name, color) {
            this.id = id;
            this.name = name;
            this.color = color;
        }
    }
    class Ordering {
        constructor(name, order) {
            this.order = [];
            this.name = name;
            this.order = order;
        }
    }
    /* MOVED FROM QUERIES TO DYNAMICGRAPH */
    //// QUERIES
    class Query {
        constructor(elements) {
            this._elements = [];
            if (elements) {
                for (var i = 0; i < elements.length; i++) {
                    if (elements[i] != undefined)
                        this._elements.push(elements[i]);
                }
            }
        }
        // contains(element: number): boolean {
        //     return this._elements.indexOf(element) > -1;
        // }
        addUnique(element) {
            if (this._elements.indexOf(element) == -1)
                this._elements.push(element);
        }
        add(element) {
            this._elements.push(element);
        }
        addAll(elements) {
            for (var i = 0; i < elements.length; i++) {
                if (elements[i] != undefined)
                    this._elements.push(elements[i]);
            }
        }
        addAllUnique(elements) {
            for (var i = 0; i < elements.length; i++) {
                this.addUnique(elements[i]);
            }
        }
        /** @returns numbr of elements in this query. Same as size(). */
        get length() {
            return this._elements.length;
        }
        ;
        /** @returns numbr of elements in this query. Same as length getter. */
        size() { return this._elements.length; }
        ;
        /** @returns all ids in this query. */
        ids() {
            return this._elements;
        }
        removeDuplicates() {
            var elements = this._elements.slice(0);
            this._elements = [];
            for (var i = 0; i < elements.length; i++) {
                if (this._elements.indexOf(elements[i]) == -1)
                    this._elements.push(elements[i]);
            }
            return this;
        }
        generic_intersection(q) {
            var intersection = [];
            for (var i = 0; i < this._elements.length; i++) {
                for (var j = 0; j < q._elements.length; j++) {
                    if (this._elements[i] == q._elements[j]) {
                        intersection.push(this._elements[i]);
                    }
                }
            }
            return new Query(intersection);
        }
    }
    class GraphElementQuery extends Query {
        constructor(elements, g, elementType) {
            super(elements);
            this.g = g;
            this.elementType = elementType;
        }
        /** @returns a query that contains only the elements matching
         * the filter critera;
         * @param attribute - name of attribute that is used on filter
         * @param filter - function evaluating if the attribute's value is valid.
          */
        generic_filter(filter) {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                try {
                    if (filter(this.g.get(this.elementType, this._elements[i]))) {
                        arr.push(this._elements[i]);
                    }
                }
                catch (ex) {
                }
            }
            return arr;
        }
        /** @returns a query with selected elements, i.e. elements that are in at least
         * one selection.
         */
        generic_selected() {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                var element = this.g.get(this.elementType, this._elements[i]);
                if (element != undefined && element.isSelected()) {
                    arr.push(this._elements[i]);
                }
            }
            return arr;
        }
        /** @returns a query with visible elements.
         */
        generic_visible() {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                var element = this.g.get(this.elementType, this._elements[i]);
                if (element != undefined && element.isVisible()) {
                    arr.push(this._elements[i]);
                }
            }
            return arr;
        }
        /** @returns a query with highighted elements.
         */
        generic_highlighted() {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                var element = this.g.get(this.elementType, this._elements[i]);
                if (element != undefined && element.isHighlighted()) {
                    arr.push(this._elements[i]);
                }
            }
            return arr;
        }
        /** @returns a query with only the elements present in the specified time step
         * or period.
         */
        generic_presentIn(start, end) {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                var element = this.g.get(this.elementType, this._elements[i]);
                if (element != undefined && element.presentIn(start, end)) {
                    arr.push(this._elements[i]);
                }
            }
            return arr;
        }
        /** @returns this query with elements sorted */
        generic_sort(attrName, asc) {
            if (this._elements.length == 0) {
                return this;
            }
            var array = this._elements.slice(0);
            // ITS POSSIBLE AN UNDEFINED VALUE??
            array.sort((e1, e2) => {
                var e1_get = this.g.get(this.elementType, e1);
                var e2_get = this.g.get(this.elementType, e2);
                if (e1_get != undefined && e2_get != undefined) {
                    return attributeSort(e1_get, e2_get, attrName, asc);
                }
                else if (e1_get == undefined && e2_get == undefined) {
                    return 0;
                }
                return e1_get == undefined ? 1 : -1;
            });
            this._elements = array;
            return this;
        }
        generic_removeDuplicates() {
            var uniqueElements = [];
            for (var i = 0; i < this._elements.length; i++) {
                // for(var j=i+1 ; j <this._elements.length ; j++){
                //     if(this._elements[i]==this._elements[j])
                //         this._elements.slice(j,1);
                // }
                if (uniqueElements.indexOf(this._elements[i]) == -1)
                    uniqueElements.push(this._elements[i]);
            }
            this._elements = uniqueElements;
            return this;
        }
    }
    /** Basic class for every object in networkcube with an ID.
     * A BasicElement is a wrapper to the DynamicGraph and that
     * represents any object, i.e. node, link, node pair, time, location.
    */
    class BasicElement {
        // CONSTRUCTOR
        constructor(id, type, dynamicGraph) {
            this._id = id;
            this.type = type;
            this.g = dynamicGraph;
        }
        // GETTER
        /** @returns the object's id */
        id() {
            return this._id;
        }
        /** Generic method to return an attribute value for this element
         * @param attr: attribute name on this object.
         * @returns the attribute's value. */
        attr(attr) {
            return this.g.attr(attr, this._id, this.type);
        }
        // SELECTIONS
        /** @returns all selections this object is part of. */
        getSelections() {
            return this.g.attributeArrays[this.type].selections[this._id];
        }
        /** Adds this object to a selection
         * @param selection - the Selection object
         */
        addToSelection(b) {
            this.g.attributeArrays[this.type].selections[this._id].push(b);
        }
        /** Removes this object from a selection.
         * @param selection - the Selection objects
         */
        removeFromSelection(b) {
            var arr = this.g.attributeArrays[this.type].selections[this._id];
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] == b)
                    this.g.attributeArrays[this.type].selections[this._id].splice(i, 1);
            }
        }
        inSelection(s) {
            return this.getSelections().indexOf(s) > -1;
        }
        // DISPLAY STATES
        /** @returns true if this object is selected.
         * @param selection - (optional) if specified returns true if this object
         * is in the passed selection.
         */
        isSelected(selection) {
            if (!selection)
                return this.getSelections().length > 0;
            var selections = this.g.attributeArrays[this.type].selections[this._id];
            for (var i = 0; i < selections.length; i++) { // start with 1 to avoid default selection.
                if (selections[i] == this.g.defaultNodeSelection || selections[i] == this.g.defaultLinkSelection) {
                    continue;
                }
                if (selections[i] == selection)
                    return true;
            }
            return false;
        }
        /** @returns true if this object is highlighted */
        isHighlighted() {
            return this.g.isHighlighted(this._id, this.type);
        }
        /** @returns true if this object is filtered, i.e. removed from display. */
        isFiltered() {
            return this.g.isFiltered(this._id, this.type);
        }
        /** @returns true if this object is visible. */
        isVisible() {
            var selections = this.getSelections();
            if (selections.length == 0)
                return true;
            for (var i = 0; i < selections.length; i++) {
                if (selections[i].filter)
                    return false;
            }
            return true;
        }
        // OTHER QUERIES
        /** @returns true if this object is present in the graph
         * in a specific time or a time period.
         * @param start -  start time. If only this parameter is passed to the
         * function, method returns if this object is present in this time step.
         * @param end - end time. If this parameter is specified, returns if this
         * object is present between start and end.
         */
        presentIn(start, end) {
            var presence = this.attr('presence');
            if (!end)
                end = start;
            for (var i = start._id; i <= end._id; i++) {
                if (presence.indexOf(i) > -1)
                    return true;
            }
            return false;
        }
    }
    /** A time series with a scalar value per time step.
     * This class nestes an object that holds information for time
     * steps in the format key->value. I.e. the value for the
     * time step with ID 3 is accessed by this.3   */
    class ScalarTimeSeries {
        constructor() {
            this.serie = {};
        }
        /** @returns a ScalarTimeSeries for the specified period. */
        period(t1, t2) {
            var t1id = t1.id();
            var t2id = t2.id();
            var s = new ScalarTimeSeries();
            for (var prop in this.serie) {
                if (parseInt(prop) >= t1id
                    && parseInt(prop) <= t2id) {
                    s.serie[prop] = this.serie[prop];
                }
            }
            return s;
        }
        /** Sets a value for a specified time point. */
        set(t, element) {
            this.serie[t.id()] = element;
        }
        /** @returns the value for a specified time point. */
        get(t) {
            if (this.serie[t.id()] == undefined)
                return; // this is avoid!!
            return this.serie[t.id()];
        }
        size() {
            return this.toArray().length;
        }
        getSerie() {
            return this.serie;
        }
        /** Returns all values as array.
         * @param removeDuplicates
         * @returns array with values;
         */
        toArray(removeDuplicates) {
            if (removeDuplicates == undefined)
                removeDuplicates = false;
            var a = [];
            if (removeDuplicates) {
                for (var prop in this.serie) {
                    a.push(this.serie[prop]);
                }
            }
            else {
                for (var prop in this.serie) {
                    if (a.indexOf(this.serie[prop]) == -1)
                        a.push(this.serie[prop]);
                }
            }
            return a;
        }
    }
    /** A time series with an array per time step.
    * This class nestes an object that holds information for time
    * steps in the format key->value. I.e. the value for the
    * time step with ID 3 is accessed by this.3   */
    class ArrayTimeSeries {
        constructor() {
            this.serie = {};
        }
        period(t1, t2) {
            var t1id = t1.id();
            var t2id = t1.id();
            var s = new ArrayTimeSeries();
            for (var prop in this.serie) {
                if (parseInt(prop) >= t1id
                    && parseInt(prop) <= t1id) {
                    s.serie[prop] = this.serie[prop];
                }
            }
            return s;
        }
        add(t, element) {
            if (t == undefined) {
                return;
            }
            if (!this.serie[t._id])
                this.serie[t._id] = [];
            this.serie[t._id].push(element);
        }
        get(t) {
            return this.serie[t._id];
        }
        toArray() {
            var a = [];
            for (var prop in this.serie) {
                a.push(this.serie[prop]);
            }
            return a;
        }
        toFlatArray(removeDuplicates) {
            if (removeDuplicates == undefined)
                removeDuplicates = false;
            var a = [];
            for (var prop in this.serie) {
                for (var i = 0; i < this.serie[prop].length; i++) {
                    if (!removeDuplicates || (removeDuplicates && a.indexOf(this.serie[prop]) == -1)) {
                        a.push(this.serie[prop][i]);
                    }
                }
            }
            return a;
        }
    }
    class TimeQuery extends GraphElementQuery {
        //elementType = 'time';
        constructor(elements, g) {
            super(elements, g, 'time');
            //this.elementType = 'time';
            if (elements.length > 0 && elements[0] instanceof Time) {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements.push(elements[i].id());
                }
            }
            if (elements.length > 0 && typeof elements[0] == 'number') {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements.push(elements[i]);
                }
            }
        }
        contains(t) {
            return this._elements.indexOf(t.id()) > -1;
        }
        highlighted() {
            return new TimeQuery(super.generic_highlighted(), this.g);
        }
        visible() {
            return new TimeQuery(super.generic_visible(), this.g);
        }
        selected() {
            return new TimeQuery(super.generic_selected(), this.g);
        }
        filter(filter) {
            return new TimeQuery(super.generic_filter(filter), this.g);
        }
        presentIn(t1, t2) {
            return new TimeQuery(super.generic_presentIn(t1, t2), this.g);
        }
        sort(attributeName) {
            return super.generic_sort(attributeName);
        }
        links() {
            var links = [];
            // var allLinks = this.g.links().toArray();
            // var allTimes = this.g.times().toArray();
            // for(var i=0 ; i<allLinks.length ; i++){
            // for(var j=0 ; j<allTimes.length ; j++){
            //     if(allLinks[i].presentIn(allTimes[j])){
            //         links.push(allLinks[i].id());
            //         break
            //     }
            // }
            // }
            for (var i = 0; i < this._elements.length; i++) {
                links = links.concat(this.g.attr('links', this._elements[i], 'time'));
            }
            return new LinkQuery(links, this.g);
        }
        // returns the i-th element in this query
        get(i) { return this.g._times[this._elements[i]]; }
        last() { return this.g._times[this._elements[this._elements.length - 1]]; }
        // return array of times
        toArray() {
            var a = [];
            var allTimes = this.g._times;
            for (var i = 0; i < this._elements.length; i++) {
                a.push(allTimes[this._elements[i]]);
            }
            return a;
        }
        createAttribute(attrName, f) {
            // create and init new attribute array if necessary
            if (this.g.timeArrays[attrName] == undefined) {
                this.g.timeArrays[attrName] = [];
                for (var i = 0; i < this.g._times.length; i++) {
                    this.g.timeArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.timeArrays[attrName][this._elements[i]] = f(this.g._times[this._elements[i]]);
            }
            return this;
        }
        unixTimes() {
            var unixTimes = [];
            for (var i = 0; i < this._elements.length; i++) {
                var time = this.g.time(this._elements[i]); // UNDEFINED ??
                if (time != undefined) {
                    unixTimes.push(time.unixTime());
                }
            }
            return unixTimes;
        }
        intersection(q) {
            return new TimeQuery(this.generic_intersection(q)._elements, this.g);
        }
        forEach(f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.time(this._elements[i]), i);
            }
            return this;
        }
    }
    /**
    * Represents a Time object
    */
    class Time extends BasicElement {
        constructor(id, dynamicGraph) {
            super(id, 'time', dynamicGraph);
        }
        // SPECIFIC ATTRIBUTE QUERIES
        /** @returns the moment object associated to this time object. */
        time() { return this.attr('momentTime'); }
        moment() { return this.attr('momentTime'); }
        label() { return this.attr('label'); }
        /** @returns the unix time for this time object. */
        unixTime() { return this.attr('unixTime'); }
        /** @returns a string label for this object. */
        // label(): String { return this.attr('label') + ''; }
        links() {
            // var links:number[] = [];
            // for(var i=0 ; i<allLinks.length ; i++){
            //     if(allLinks[i].presentIn(this))
            //         links.push(allLinks[i].id());
            // }
            return new LinkQuery(this.attr('links'), this.g);
        }
        // wrapper to moment.js
        year() { return this.time().year(); }
        month() { return this.time().month(); }
        week() { return this.time().week(); }
        day() { return this.time().day(); }
        hour() { return this.time().hour(); }
        minute() { return this.time().minute(); }
        second() { return this.time().second(); }
        millisecond() { return this.time().millisecond(); }
        format(format) {
            return this.time().format(format);
        }
    }
    class LocationQuery extends GraphElementQuery {
        // elementType = 'location';
        constructor(elements, g) {
            super(elements, g, 'location');
            // this.elementType = 'location';
            if (elements.length > 0 && elements[0] instanceof Location) {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements = elements[i].id();
                }
            }
            if (elements.length > 0 && typeof elements[0] == 'number') {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements.push(elements[i]);
                }
            }
        }
        contains(l) {
            return this._elements.indexOf(l.id()) > -1;
        }
        highlighted() {
            return new LocationQuery(super.generic_highlighted(), this.g);
        }
        visible() {
            return new LocationQuery(super.generic_visible(), this.g);
        }
        selected() {
            return new LocationQuery(super.generic_selected(), this.g);
        }
        filter(filter) {
            return new LocationQuery(super.generic_filter(filter), this.g);
        }
        presentIn(t1, t2) {
            return new LocationQuery(super.generic_presentIn(t1, t2), this.g);
        }
        sort(attributeName) {
            return super.generic_sort(attributeName);
        }
        // returns the i-th element in this query
        get(i) { return this.g._locations[this._elements[i]]; }
        last() { return this.g._locations[this._elements[this._elements.length - 1]]; }
        // return array of locations
        toArray() {
            var a = [];
            for (var i = 0; i < this._elements.length; i++) {
                a.push(this.g._locations[this._elements[i]]);
            }
            return a;
        }
        createAttribute(attrName, f) {
            // create and init new attribute array if necessary
            if (this.g.locationArrays[attrName] == undefined) {
                this.g.locationArrays[attrName] = [];
                for (var i = 0; i < this.g._locations.length; i++) {
                    this.g.locationArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.locationArrays[attrName][this._elements[i]] = f(this.g._locations[this._elements[i]]);
            }
            return this;
        }
        intersection(q) {
            return new LocationQuery(this.generic_intersection(q)._elements, this.g);
        }
        removeDuplicates() {
            return new LocationQuery(this.generic_removeDuplicates()._elements, this.g);
        }
        forEach(f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.location(this._elements[i]), i);
            }
            return this;
        }
    }
    /**
     * Represents a simple array of numbers that can be used to calculate
     * max, mean, min values etc..
     */
    class NumberQuery extends Query {
        clone() {
            return this._elements.slice(0);
        }
        min() {
            this._elements = this.makeNumbers(this._elements);
            var min = parseInt(this._elements[0] + '');
            for (var i = 1; i < this._elements.length; i++) {
                if (this._elements[i] != undefined)
                    min = Math.min(min, parseInt(this._elements[i] + ''));
            }
            return min;
        }
        max() {
            var max = parseInt(this._elements[0] + '');
            for (var i = 1; i < this._elements.length; i++) {
                if (this._elements[i] != undefined)
                    max = Math.max(max, parseInt(this._elements[i] + ''));
            }
            return max;
        }
        mean() {
            this._elements = this.makeNumbers(this._elements);
            var v = 0;
            var count = 0;
            for (var i = 0; i < this._elements.length; i++) {
                if (typeof this._elements[i] == 'number') {
                    v += parseInt(this._elements[i] + '');
                    count++;
                }
            }
            return v / count;
        }
        sum() {
            var sum = 0;
            for (var i = 0; i < this._elements.length; i++) {
                if (typeof this._elements[i] == 'number') {
                    sum += parseInt(this._elements[i] + '');
                }
            }
            return sum;
        }
        toArray() {
            return this._elements.slice(0);
        }
        get(index) {
            return this._elements[index];
        }
        forEach(f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this._elements[i], i);
            }
            return this;
        }
        makeNumbers(elements) {
            if (elements && elements.length > 0) {
                var first = elements[0];
                if (typeof first == 'string') {
                    var numberElements = [];
                    for (var i = 0; i < elements.length; i++) {
                        numberElements.push(parseFloat(elements[i] + ''));
                    }
                    console.log('string array converted', numberElements);
                    return numberElements;
                }
            }
            return elements;
        }
    }
    class Location extends BasicElement {
        constructor(id, graph) {
            super(id, 'location', graph);
        }
        // SPECIFIC ATTRIBUTE QUERIES
        label() { return this.attr('label') + ''; }
        longitude() { return this.attr('longitude'); }
        latitude() { return this.attr('latitude'); }
        x() { return this.attr('x'); }
        y() { return this.attr('y'); }
        z() { return this.attr('z'); }
        radius() { return this.attr('radius'); }
    }
    class NodePairQuery extends GraphElementQuery {
        //elementType = 'nodePair';
        constructor(elements, g) {
            super(elements, g, 'nodePair');
            //this.elementType = 'nodePair';
            if (elements.length > 0 && elements[0] instanceof NodePair) {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements.push(elements[i].id());
                }
            }
            if (elements.length > 0 && typeof elements[0] == 'number') {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements.push(elements[i]);
                }
            }
        }
        contains(n) {
            return this._elements.indexOf(n.id()) > -1;
        }
        highlighted() {
            return new NodePairQuery(super.generic_highlighted(), this.g);
        }
        visible() {
            return new NodePairQuery(super.generic_visible(), this.g);
        }
        selected() {
            return new NodePairQuery(super.generic_selected(), this.g);
        }
        filter(filter) {
            return new NodePairQuery(super.generic_filter(filter), this.g);
        }
        presentIn(t1, t2) {
            return new NodePairQuery(super.generic_presentIn(t1, t2), this.g);
        }
        sort(attributeName) {
            return super.generic_sort(attributeName);
        }
        // returns the i-th element in this query
        get(i) { return this.g._nodePairs[this._elements[i]]; }
        last() { return this.g._links[this._elements[this._elements.length - 1]]; }
        // returns array of NodePair
        toArray() {
            var a = [];
            for (var i = 0; i < this._elements.length; i++) {
                a.push(this.g._nodePairs[this._elements[i]]);
            }
            return a;
        }
        createAttribute(attrName, f) {
            // create and init new attribute array if necessary
            if (this.g.nodePairArrays[attrName] == undefined) {
                this.g.nodePairArrays[attrName] = [];
                for (var i = 0; i < this.g._nodePairs.length; i++) {
                    this.g.nodePairArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.nodePairArrays[attrName][this._elements[i]] = f(this.g._nodePairs[this._elements[i]]);
            }
            return this;
        }
        intersection(q) {
            return new NodePairQuery(this.generic_intersection(q)._elements, this.g);
        }
        removeDuplicates() {
            return new NodePairQuery(this.generic_removeDuplicates()._elements, this.g);
        }
        forEach(f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.nodePair(this._elements[i]), i);
            }
            return this;
        }
    }
    class NodePair extends BasicElement {
        constructor(id, graph) {
            super(id, 'nodePair', graph);
        }
        // SPECIFIC ATTRIBUTE QUERIES
        get source() { return this.g._nodes[this.attr('source')]; }
        get target() { return this.g._nodes[this.attr('target')]; }
        links() { return new LinkQuery(this.attr('links'), this.g); }
        nodeType() { return this.attr('nodeType'); }
        presentIn(start, end) {
            for (var i = 0; i < this.links.length; i++) {
                if (this.links[i].presentIn(start, end))
                    return true;
            }
            return false;
        }
    }
    class StringQuery {
        constructor(elements) {
            if (elements)
                this._elements = elements.slice(0);
            else
                this._elements = []; // INIT WHEN ELEMENTS DOESN'T EXIST
        }
        contains(element) {
            return this._elements.indexOf(element) > -1;
        }
        addUnique(element) {
            if (this._elements.indexOf(element) == -1)
                this._elements.push(element);
        }
        add(element) {
            this._elements.push(element);
        }
        addAll(elements) {
            for (var i = 0; i < elements.length; i++) {
                if (elements[i] != undefined)
                    this._elements.push(elements[i]);
            }
        }
        addAllUnique(elements) {
            for (var i = 0; i < elements.length; i++) {
                this.addUnique(elements[i]);
            }
        }
        get length() { return this._elements.length; }
        ;
        size() { return this._elements.length; }
        ;
        toArray() {
            return this._elements.slice(0);
        }
        forEach(f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this._elements[i], i);
            }
            return this;
        }
    }
    function getBulkAttributes(attrName, ids, type, g, t1, t2) {
        var a = [];
        var temp;
        for (var i = 0; i < ids.length; i++) {
            if (t2 != undefined && t1 != undefined) {
                temp = g.attr(attrName, ids[i], type).period(t1, t2).toArray();
            }
            else if (t1 != undefined) {
                temp = [g.attr(attrName, ids[i], type).get(t1)];
            }
            else {
                temp = g.attr(attrName, ids[i], type).toArray();
            }
            for (var j = 0; j < temp.length; j++) {
                if (temp[j] instanceof Array) {
                    a = a.concat(temp[j]);
                }
                else {
                    if (a.indexOf(temp[j]) == -1)
                        a.push(temp[j]);
                }
            }
        }
        return a;
    }
    class NodeQuery extends GraphElementQuery {
        // elementType = 'node';
        constructor(elements, g) {
            super(elements, g, 'node');
            if (elements.length > 0 && elements[0] instanceof Node) {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements.push(elements[i].id());
                }
            }
            else if (elements.length > 0 && typeof elements[0] == 'number') {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements.push(elements[i]);
                }
            }
            // this.elementType = 'node';
        }
        contains(n) {
            return this._elements.indexOf(n.id()) > -1;
        }
        // WRAPPERS TO GENERIC FUNCTIONS IN GRAPH_ELEMENT_QUERY
        highlighted() {
            return new NodeQuery(super.generic_highlighted(), this.g);
        }
        visible() {
            return new NodeQuery(super.generic_visible(), this.g);
        }
        selected() {
            return new NodeQuery(super.generic_selected(), this.g);
        }
        filter(filter) {
            return new NodeQuery(super.generic_filter(filter), this.g);
        }
        presentIn(t1, t2) {
            return new NodeQuery(super.generic_presentIn(t1, t2), this.g);
        }
        sort(attributeName, asc) {
            return super.generic_sort(attributeName, asc);
        }
        // proper functions
        label() {
            var q = new StringQuery();
            for (var i = 0; i < this._elements.length; i++) {
                q.add('' + this.g.attr('label', this._elements[i], 'node'));
            }
            return q;
        }
        neighbors(t1, t2) {
            return new NodeQuery(getBulkAttributes('neighbors', this._elements, 'node', this.g, t1, t2), this.g);
        }
        links(t1, t2) {
            return new LinkQuery(getBulkAttributes('links', this._elements, 'node', this.g, t1, t2), this.g);
        }
        locations(t1, t2) {
            return new LocationQuery(getBulkAttributes('locations', this._elements, 'node', this.g, t1, t2), this.g);
        }
        nodeTypes() {
            var q = new StringQuery();
            for (var i = 0; i < this._elements.length; i++) {
                q.add(this.g.attr('nodeType', this._elements[i], 'node'));
            }
            return q;
        }
        // returns the i-th element in this query
        get(i) { return this.g._nodes[this._elements[i]]; }
        last() { return this.g._nodes[this._elements[this._elements.length - 1]]; }
        // returns array of nodes
        toArray() {
            var a = [];
            for (var i = 0; i < this._elements.length; i++) {
                a.push(this.g._nodes[this._elements[i]]);
            }
            return a;
        }
        createAttribute(attrName, f) {
            // create and init news attribute array if necessary
            if (this.g.nodeArrays[attrName] == undefined) {
                this.g.nodeArrays[attrName] = [];
                for (var i = 0; i < this.g._nodes.length; i++) {
                    this.g.nodeArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.nodeArrays[attrName][this._elements[i]] = f(this.g._nodes[this._elements[i]]);
            }
            return this;
        }
        intersection(q) {
            return new NodeQuery(this.generic_intersection(q)._elements, this.g);
        }
        removeDuplicates() {
            return new NodeQuery(this.generic_removeDuplicates()._elements, this.g);
        }
        forEach(f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.node(this._elements[i]), i);
            }
            return this;
        }
    }
    /**
     * Represents a node object
     */
    class Node extends BasicElement {
        constructor(id, graph) {
            super(id, 'node', graph);
        }
        // SPECIFIC ATTRIBUTE QUERIES
        /** @returns this node's label, specified by the user.
         * If no string value was delivered by the user, returns the ID as string.
         */
        label() { return '' + this.attr('label'); }
        shape() { return '' + this.attr('shape'); }
        color() { return '' + this.attr('color'); }
        nodeType() { return this.attr('nodeType'); }
        /** Returns this nodes neighbors in a NodeQuery. No duplicates.
         * If no parameter is supplied, returns *all* neighbors of this
         * node over all time steps.
         * @param t1 - start time. If only this parameter is specified, returns
         * neighbors in this time step only.
         * @param t2 - end time. If this parameter is specified, returns
         * neighbors between t1 and t2.
        */
        neighbors(t1, t2) {
            if (t2 != undefined && t1 != undefined) {
                return new NodeQuery(this.attr('neighbors').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new NodeQuery(this.attr('neighbors').get(t1), this.g);
            }
            return new NodeQuery(this.attr('neighbors').toFlatArray(), this.g);
        }
        inNeighbors(t1, t2) {
            if (t2 != undefined && t1 != undefined) {
                return new NodeQuery(this.attr('inNeighbors').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new NodeQuery(this.attr('inNeighbors').get(t1), this.g);
            }
            return new NodeQuery(this.attr('inNeighbors').toFlatArray(true), this.g);
        }
        outNeighbors(t1, t2) {
            if (t2 != undefined && t1 != undefined) {
                return new NodeQuery(this.attr('outNeighbors').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new NodeQuery(this.attr('outNeighbors').get(t1), this.g);
            }
            return new NodeQuery(this.attr('outNeighbors').toFlatArray(), this.g);
        }
        links(t1, t2) {
            if (t2 != undefined && t1 != undefined) {
                return new LinkQuery(this.attr('links').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new LinkQuery(this.attr('links').get(t1), this.g);
            }
            return new LinkQuery(this.attr('links').toFlatArray(true), this.g);
        }
        inLinks(t1, t2) {
            if (t2 != undefined && t1 != undefined) {
                return new LinkQuery(this.attr('inLinks').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new LinkQuery(this.attr('inLinks').get(t1), this.g);
            }
            return new LinkQuery(this.attr('inLinks').toFlatArray(true), this.g);
        }
        outLinks(t1, t2) {
            if (t2 != undefined && t1 != undefined) {
                return new LinkQuery(this.attr('outLinks').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new LinkQuery(this.attr('outLinks').get(t1), this.g);
            }
            return new LinkQuery(this.attr('outLinks').toFlatArray(true), this.g);
        }
        locations(t1, t2) {
            if (t2 != undefined && t1 != undefined) {
                return new LocationQuery(this.attr('locations').period(t1, t2).toArray(), this.g);
            }
            if (t1 != undefined) {
                return new LocationQuery([this.attr('locations').get(t1)], this.g);
            }
            return new LocationQuery(this.attr('locations').toArray(), this.g);
        }
        locationSerie(t1, t2) {
            var serie;
            if (t2 != undefined && t1 != undefined)
                serie = this.attr('locations').period(t1, t2);
            // return this.attr('locations').period(t1, t2);
            else if (t1 != undefined)
                serie = (this.attr('locations')).get(t1);
            // return this.attr('locations').get(t1);
            else
                serie = this.attr('locations');
            // return this.attr('locations');
            var serie2 = serie.getSerie();
            // replace numbers by locations
            var serie3 = new ScalarTimeSeries();
            for (var t in serie2) {
                var time = this.g.time(parseInt(t));
                var location = this.g.location(serie2[t]);
                if (time != undefined && location != undefined) {
                    serie3.set(time, location);
                }
            }
            return serie3;
        }
        linksBetween(n) {
            var links = this.links().toArray();
            var finalLinks = [];
            var l;
            for (var i = 0; i < links.length; i++) {
                l = links[i];
                if (l.source == n || l.target == n)
                    finalLinks.push(l);
            }
            return new LinkQuery(finalLinks, this.g);
        }
    }
    class LinkQuery extends GraphElementQuery {
        //elementType = 'link';
        constructor(elements, g) {
            super(elements, g, 'link');
            if (elements.length > 0 && elements[0] instanceof Link) {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements.push(elements[i].id());
                }
            }
            if (elements.length > 0 && typeof elements[0] == 'number') {
                this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    this._elements.push(elements[i]);
                }
            }
        }
        contains(l) {
            return this._elements.indexOf(l.id()) > -1;
        }
        highlighted() {
            return new LinkQuery(super.generic_highlighted(), this.g);
        }
        visible() {
            return new LinkQuery(super.generic_visible(), this.g);
        }
        selected() {
            return new LinkQuery(super.generic_selected(), this.g);
        }
        filter(filter) {
            return new LinkQuery(super.generic_filter(filter), this.g);
        }
        presentIn(t1, t2) {
            return new LinkQuery(super.generic_presentIn(t1, t2), this.g);
        }
        sort(attributeName) {
            return super.generic_sort(attributeName);
        }
        // returns the i-th element in this query
        get(i) { return this.g._links[this._elements[i]]; }
        last() { return this.g._links[this._elements[this._elements.length - 1]]; }
        // returns array of links
        toArray() {
            var a = [];
            for (var i = 0; i < this._elements.length; i++) {
                a.push(this.g._links[this._elements[i]]);
            }
            return a;
        }
        weights(start, end) {
            var s = new NumberQuery();
            for (var i = 0; i < this._elements.length; i++) {
                var gLink = this.g.link(i);
                if (gLink != undefined)
                    s.addAll(gLink.weights(start, end).toArray());
                // ELSE ???
            }
            return s;
        }
        createAttribute(attrName, f) {
            // create and init new attribute array if necessary
            if (this.g.linkArrays[attrName] == undefined) {
                this.g.linkArrays[attrName] = [];
                for (var i = 0; i < this.g._links.length; i++) {
                    this.g.linkArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.linkArrays[attrName][this._elements[i]] = f(this.g._links[this._elements[i]]);
            }
            return this;
        }
        linkTypes() {
            var linkTypes = [];
            var s;
            for (var i = 0; i < this._elements.length; i++) {
                var gLink = this.g.link(this._elements[i]);
                if (gLink != undefined) {
                    s = gLink.linkType();
                    if (linkTypes.indexOf(s) == -1)
                        linkTypes.push(s);
                }
                // ELSE ??
            }
            return linkTypes;
        }
        sources() {
            var nodes = [];
            var link;
            for (var i = 0; i < this._elements.length; i++) {
                link = this.g.link(this._elements[i]);
                if (link != undefined) { // UNDEFINED??
                    if (nodes.indexOf(link.source.id()) == -1) // ID??
                        nodes.push(link.source.id());
                }
            }
            return new NodeQuery(nodes, this.g);
        }
        targets() {
            var nodes = [];
            var link;
            for (var i = 0; i < this._elements.length; i++) {
                link = this.g.link(this._elements[i]);
                if (link != undefined) { // UNDEFINED??
                    if (nodes.indexOf(link.target.id()) == -1) // ID??
                        nodes.push(link.target.id());
                }
            }
            return new NodeQuery(nodes, this.g);
        }
        intersection(q) {
            return new LinkQuery(this.generic_intersection(q)._elements, this.g);
        }
        removeDuplicates() {
            return new LinkQuery(this.generic_removeDuplicates()._elements, this.g);
        }
        forEach(f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.link(this._elements[i]), i);
            }
            return this;
        }
    }
    /**
      * Represents a link object on a WindowGraph
      */
    class Link extends BasicElement {
        constructor(id, graph) {
            super(id, 'link', graph);
            this.targetNPO = undefined;
            this.sourceNPO = undefined;
        }
        // SPECIFIC ATTRIBUTE QUERIES
        linkType() { return this.attr('linkType'); }
        get source() { return this.g._nodes[this.attr('source')]; }
        get target() { return this.g._nodes[this.attr('target')]; }
        nodePair() { return this.g._nodePairs[this.attr('nodePair')]; }
        directed() { return this.attr('directed'); }
        other(n) {
            return this.source == n ? this.target : this.source;
        }
        /** Returns this link's weights over time as NumberQuery
        * If no time parameter is supplied, returns *all* weights of this
         * link over all time steps.
         * @param t1 - start time. If only this parameter is specified, returns
         * only the value for t1.
         * @param t2 - end time. If this parameter is specified, returns
         * weights between t1 and t2.
        */
        weights(start, end) {
            if (start == undefined)
                return new NumberQuery(this.attr('weights').toArray());
            if (end == undefined)
                return new NumberQuery([this.attr('weights').get(start)]);
            return new NumberQuery(this.attr('weights').period(start, end).toArray());
        }
        presentIn(start, end) {
            var presence = this.weights(start, end).toArray();
            return presence.length > 0;
        }
        /** Returns all times in which this link's weight != 0  */
        times() {
            // var weights:ScalarTimeSeries<number> = <ScalarTimeSeries<number>>this.attr('weights');
            // var times = []
            // var allTimes = this.g.times().toArray();
            // for(var t in weights.serie){
            //     times.push(allTimes[parseInt(t)]);
            // }
            return new TimeQuery(this.attr('presence'), this.g);
        }
    }
    class LinkType {
        constructor(id, name, color) {
            this.id = id;
            this.name = name;
            this.color = color;
        }
    }
    /* Moved from utils to dynamicgraph to eliminate circular dependency */
    /* used by dynamicgraph, but not used none of utils*/
    function attributeSort(a, b, attributeName, asc) {
        var value = a.attr(attributeName);
        var result;
        if (typeof value == 'string') {
            result = a.attr(attributeName).localeCompare(b.attr(attributeName));
        }
        else if (typeof value == 'number') {
            result = b.attr(attributeName) - a.attr(attributeName);
        }
        else {
            result = 0;
        }
        if (asc == false) {
            result = -result;
        }
        return result;
    }
    /* moved from utils to dynamicgraph */
    class IDCompound {
        constructor() {
            this.nodeIds = [];
            this.linkIds = [];
            this.timeIds = [];
            this.nodePairIds = [];
            this.locationIds = [];
        }
    }
    /******** MOVED FROM UTILS TO DYNAMICGRAPH *********/
    function copyPropsShallow(source, target) {
        for (var p in source) {
            if (source.hasOwnProperty(p))
                target[p] = source[p];
        }
        return target;
    }
    function copyTimeseriesPropsShallow(source, target) {
        for (var q in source) {
            if (source.hasOwnProperty(q)) {
                for (var p in source[q]) {
                    if (source[q].hasOwnProperty(p)) {
                        target[q][p] = source[q][p];
                    }
                }
            }
        }
        return target;
    }
    function copyTimeSeries(arr, ctorFunc) {
        var arrayClone = [];
        for (var elem in arr) {
            arrayClone.push(copyTimeseriesPropsShallow(arr[elem], ctorFunc()));
        }
        return arrayClone;
    }
    function compareTypesDeep(a, b, depth) {
        var result = true;
        if (a == null || b == null)
            return a == b;
        if (typeof a != typeof b)
            return false;
        else if (typeof a != 'object')
            return true;
        else if (a.constructor !== b.constructor)
            return false;
        else {
            if (depth > 0) {
                for (var key in a) {
                    if (key in b
                        && a.hasOwnProperty(key)
                        && b.hasOwnProperty(key)
                        && !compareTypesDeep(a[key], b[key], depth - 1)) {
                        console.log("compareFailed for key", key, a[key], b[key]);
                        result = false;
                    }
                }
            }
            return result;
        }
    }
    function sortNumber(a, b) {
        return a - b;
    }
    function array(value, size) {
        var array = [];
        while (size--)
            array[size] = value;
        return array;
    }
    function doubleArray(size1, size2, value) {
        var array = [];
        if (value == undefined)
            value = [];
        var a = [];
        if (size2) {
            while (size2--)
                a[size2] = value;
        }
        while (size1--)
            array[size1] = a.slice(0);
        return array;
    }
    class DataManager {
        constructor(options) {
            this.keepOnlyOneSession = false;
            this.session = '';
            this.sessionDataPrefix = "ncubesession";
            // Strings used to access local storage
            this.SEP = "_";
            if (options) {
                // initialize stuff differently here
                if (options.keepOnlyOneSession)
                    this.setOptions(options);
            }
            else {
                this.keepOnlyOneSession = false;
            }
        }
        setOptions(options) {
            this.keepOnlyOneSession = options.keepOnlyOneSession;
        }
        // sessionDataPrefix: string = "";
        clearSessionData(session) {
            var searchPrefix = this.sessionDataPrefix + this.SEP + session;
            // var searchPrefix = session;
            var keysToClear = [];
            for (var i = 0; i < localStorage.length; i++) {
                var key = localStorage.key(i);
                if (!key)
                    continue;
                if (key.indexOf(searchPrefix) == 0)
                    keysToClear.push(key);
                // these are the old keys that we used to store before we
                // added support for multiple sessions
                else if (key.indexOf('connectoscope1') == 0)
                    keysToClear.push(key);
            }
            for (var i = 0; i < keysToClear.length; i++) {
                var k = keysToClear[i];
                localStorage.removeItem(k);
            }
        }
        clearAllSessionData() {
            this.clearSessionData('');
        }
        isSessionCached(session, dataSetName) {
            var prefix = this.sessionDataPrefix + this.SEP + session + this.SEP + dataSetName;
            //var firstSessionKey: string = null;
            for (var i = 0; i < localStorage.length; i++) {
                var key = localStorage.key(i);
                if (key && key.indexOf(prefix) == 0) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Import a data set into networkcube's local storage.
         * @param  {string}  session - current session id
         * @param  {DataSet} data    - a networkcube.DataSet
         */
        importData(session, data) {
            this.session = session;
            // check if all data (tables + schemas) are there
            if (!data.nodeTable && !data.linkTable) {
                console.log('Empty tables. No data imported.');
                return;
            }
            if (!data.nodeTable) {
                console.log('[n3] Node table missing!');
            }
            if (!data.linkTable) {
                console.log('[n3] Link table missing!');
            }
            if (!data.nodeSchema) {
                console.log('[n3] Node schema missing!');
            }
            if (!data.linkSchema) {
                console.log('[n3] Link schema missing!');
            }
            // format data
            for (var i = 0; i < data.nodeTable.length; i++) {
                for (var j = 0; j < data.nodeTable[i].length; j++) {
                    if (typeof data.nodeTable[i][j] == 'string')
                        data.nodeTable[i][j] = data.nodeTable[i][j].trim();
                }
            }
            for (var i = 0; i < data.linkTable.length; i++) {
                for (var j = 0; j < data.linkTable[i].length; j++) {
                    if (typeof data.linkTable[i][j] == 'string')
                        data.linkTable[i][j] = data.linkTable[i][j].trim();
                }
            }
            // this.saveToStorage(data.name, this.NODE_TABLE, data.nodeTable);
            // this.saveToStorage(data.name, this.NODE_SCHEMA, data.nodeSchema);
            // this.saveToStorage(data.name, this.LINK_SCHEMA, data.linkSchema);
            // this.saveToStorage(data.name, this.LINK_TABLE, data.linkTable);
            // // if(data.locationTable){
            // this.saveToStorage(data.name, this.LOCATION_TABLE, data.locationTable);
            // this.saveToStorage(data.name, this.LOCATION_SCHEMA, data.locationSchema);
            // }
            // In order to initialize the dynamic graph, our schema must be sufficiently well-defined
            if (this.isSchemaWellDefined(data)) {
                console.log('data is well-schematized, caching dynamicGraph');
                // in order to ensure that we have enough quota, we only keep one session
                // cached at a time.
                if (this.keepOnlyOneSession)
                    this.clearAllSessionData();
                var graphForCaching = new DynamicGraph();
                graphForCaching.initDynamicGraph(data);
                // CACHEGRAPH store DynamicGraph in localstorage
                graphForCaching.saveDynamicGraph(this);
                // CACHEGRAPH : this code is strictly for diagnostics;
                var doubleCheckSave = false;
                if (doubleCheckSave) {
                    var testGraph = new DynamicGraph();
                    testGraph.loadDynamicGraph(this, data.name);
                    testGraph.debugCompareTo(graphForCaching);
                }
            }
            else {
                console.log('data is not well-schematized, so not caching dynamicGraph');
            }
        }
        // NODE_TABLE: string = 'networkcube.nodetable';
        // LINK_TABLE: string = 'networkcube.linktable';
        // NODE_SCHEMA: string = 'networkcube.nodeschema';
        // LINK_SCHEMA: string = 'networkcube.linkschema';
        // LOCATION_TABLE: string = 'networkcube.locationtable';
        // LOCATION_SCHEMA: string = 'networkcube.locationschema';
        // GRAPH: string = 'networkcube.graph';
        // storage primitives /////////////////////////////////////
        //
        saveToStorage(dataName, valueName, value, replacer) {
            if (value == undefined) {
                console.log('attempting to save undefined value. aborting', dataName, valueName);
                return;
            }
            var stringifyResult = JSON.stringify(value, replacer);
            var stringToSave;
            if (stringifyResult.length > 1024 * 1024 * 4)
                stringToSave = LZString.compress(stringifyResult);
            else
                stringToSave = stringifyResult;
            localStorage[this.sessionDataPrefix + this.SEP
                + this.session
                + this.SEP + dataName
                + this.SEP + valueName] = stringToSave;
        }
        getFromStorage(dataName, valueName, reviver, state) {
            console.assert(this.session != '');
            var statefulReviver;
            if (reviver)
                statefulReviver = function (key, value) {
                    return reviver(key, value, state);
                };
            else
                statefulReviver = undefined;
            var storedResult = localStorage[this.sessionDataPrefix
                + this.SEP + this.session
                + this.SEP + dataName
                + this.SEP + valueName];
            if (storedResult && storedResult != "undefined") {
                // we try to detect whether the string was compressed or not. Given that it is
                // JSON, we would expect it to begin with either a quote, a bracket, or a curly-brace
                var parseText;
                if (storedResult == "true") {
                    parseText = true;
                }
                else if (storedResult == "false") {
                    parseText = false;
                }
                else if ("\"'[{0123456789".indexOf(storedResult[0]) >= 0)
                    parseText = storedResult;
                else
                    parseText = LZString.decompress(storedResult);
                return JSON.parse(parseText, statefulReviver);
            }
            else {
                return undefined;
            }
        }
        removeFromStorage(dataName, valueName) {
            localStorage.removeItem(this.sessionDataPrefix
                + this.SEP + this.session
                + this.SEP + dataName
                + this.SEP + valueName);
        }
        //
        // end storage primitives //////////////////////////////
        // GRAPH
        getGraph(session, dataname) {
            this.session = session;
            if (!this.dynamicGraph || this.dynamicGraph.name != dataname) {
                this.dynamicGraph = new DynamicGraph();
                this.dynamicGraph.loadDynamicGraph(this, dataname);
            }
            return this.dynamicGraph;
        }
        isSchemaWellDefined(data) {
            console.log('isSchemaWellDefined');
            if (data.locationTable && !isValidIndex(data.locationSchema.id))
                return false;
            if (data.nodeTable.length > 0 && !isValidIndex(data.nodeSchema.id))
                return false;
            if (data.linkTable.length > 0
                && !(isValidIndex(data.linkSchema.id)
                    && isValidIndex(data.linkSchema.source)
                    && isValidIndex(data.linkSchema.target)))
                return false;
            return true;
        }
    }

    var dynamicgraph = /*#__PURE__*/Object.freeze({
        __proto__: null,
        GRANULARITY: GRANULARITY,
        DGRAPH_SUB: DGRAPH_SUB,
        DGRAPH_SER_VERBOSE_LOGGING: DGRAPH_SER_VERBOSE_LOGGING,
        dgraphReviver: dgraphReviver,
        dgraphReplacer: dgraphReplacer,
        DynamicGraph: DynamicGraph,
        AttributeArray: AttributeArray,
        NodeArray: NodeArray,
        LinkArray: LinkArray,
        NodePairArray: NodePairArray,
        TimeArray: TimeArray,
        LinkTypeArray: LinkTypeArray,
        NodeTypeArray: NodeTypeArray,
        LocationArray: LocationArray,
        NodeType: NodeType,
        Ordering: Ordering,
        Query: Query,
        GraphElementQuery: GraphElementQuery,
        BasicElement: BasicElement,
        ScalarTimeSeries: ScalarTimeSeries,
        ArrayTimeSeries: ArrayTimeSeries,
        TimeQuery: TimeQuery,
        Time: Time,
        LocationQuery: LocationQuery,
        NumberQuery: NumberQuery,
        Location: Location,
        NodePairQuery: NodePairQuery,
        NodePair: NodePair,
        StringQuery: StringQuery,
        NodeQuery: NodeQuery,
        Node: Node,
        LinkQuery: LinkQuery,
        Link: Link,
        LinkType: LinkType,
        attributeSort: attributeSort,
        IDCompound: IDCompound,
        copyPropsShallow: copyPropsShallow,
        copyTimeseriesPropsShallow: copyTimeseriesPropsShallow,
        copyTimeSeries: copyTimeSeries,
        compareTypesDeep: compareTypesDeep,
        sortNumber: sortNumber,
        array: array,
        doubleArray: doubleArray,
        DataManager: DataManager
    });

    ////////////////
    //// MOTIFS ////
    ////////////////
    class Motif {
        constructor(nodes, links) {
            this.nodes = [];
            this.links = [];
            this.times = [];
            this.nodes = nodes.slice(0);
            this.links = links.slice(0);
        }
        print() {
            console.log('nodes:', this.nodes.length, 'links:', this.links.length);
        }
    }
    class MotifTemplate {
        constructor(nodes, links) {
            this.nodes = [];
            this.links = [];
            this.nodes = nodes.slice(0);
            this.links = links.slice(0);
        }
    }
    class MotifSequence {
        constructor() {
            this.motifs = [];
        }
        push(m) {
            this.motifs.push(m);
        }
    }
    //}

    var queries = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Motif: Motif,
        MotifTemplate: MotifTemplate,
        MotifSequence: MotifSequence
    });

    /// <reference path="./lib/d3.d.ts"/>
    /* moved from utils to queries */
    function getType(elements) {
        var type = ''; // before only string, without init
        if (elements.length == 0)
            return;
        if (elements[0] instanceof Node)
            type = 'node';
        else if (elements[0] instanceof Link) {
            type = 'link';
        }
        else if (elements[0] instanceof Time) {
            type = 'time';
        }
        else if (elements[0] instanceof NodePair) {
            type = 'nodePair';
        }
        else if (elements[0] instanceof LinkType) {
            type = 'linkType';
        }
        else if (typeof elements[0] == 'number') {
            type = 'number';
        }
        return type;
    }
    /* moved from utils to queries */
    function makeElementCompound(elements, g) {
        var result = new ElementCompound;
        if (elements != undefined) {
            if (elements.nodeIds) {
                result.nodes = elements.nodeIds.map((id, i) => g.node(id)); // ?? WITH OR WITHOUT ?? .filter((element) => { return (element != undefined) });
            }
            if (elements.linkIds) {
                result.links = elements.linkIds.map((id, i) => g.link(id));
            }
            if (elements.timeIds) {
                result.times = elements.timeIds.map((id, i) => g.time(id));
            }
            if (elements.nodePairIds) {
                result.nodePairs = elements.nodePairIds.map((id, i) => g.nodePair(id));
            }
        }
        return result;
    }
    /* moved from utils to queries */
    class ElementCompound {
        constructor() {
            this.nodes = [];
            this.links = [];
            this.times = [];
            this.nodePairs = [];
            this.locations = [];
        }
    }
    function getPriorityColor(element) {
        var j = 0;
        var selections = element.getSelections();
        while (!selections[j].showColor) {
            j++;
            if (j == selections.length) {
                j = -1;
                return;
            }
        }
        return element.getSelections()[j].color;
    }
    function sortByPriority(s1, s2) {
        return s1.priority - s2.priority;
    }
    function getUrlVars() {
        var vars = {};
        var params = window.location.search.replace("?", "").split('&');
        var tmp;
        var value;
        params.forEach(function (item) {
            tmp = item.split("=");
            value = decodeURIComponent(tmp[1]);
            vars[tmp[0]] = value;
        });
        return vars;
    }
    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function isBefore(t1, t2) {
        return t1.time < t2.time;
    }
    function isAfter(t1, t2) {
        return t1.time > t2.time;
    }
    function hex2Rgb(hex) {
        return [hexToR(hex), hexToG(hex), hexToB(hex)];
    }
    function hexToR(h) { return parseInt((cutHex(h)).substring(0, 2), 16); }
    function hexToG(h) { return parseInt((cutHex(h)).substring(2, 4), 16); }
    function hexToB(h) { return parseInt((cutHex(h)).substring(4, 6), 16); }
    function cutHex(h) { return (h.charAt(0) == "#") ? h.substring(1, 7) : h; }
    function hex2web(v) {
        v = v + '';
        return v.replace('0x', '#');
    }
    function hex2RgbNormalized(hex) {
        return [hexToR(hex) / 255, hexToG(hex) / 255, hexToB(hex) / 255];
    }
    function areEqualShallow(a, b) {
        for (var key in a) {
            if (!(key in b) || a[key] !== b[key]) {
                return false;
            }
        }
        for (var key in b) {
            if (!(key in a) || a[key] !== b[key]) {
                return false;
            }
        }
        return true;
    }
    function compareTypesShallow(a, b) {
        if (a == null || b == null)
            return a == b;
        if (typeof a != typeof b)
            return false;
        else if (typeof a != 'object')
            return true;
        else if (a.constructor !== b.constructor)
            return false;
        else {
            return true;
        }
    }
    function copyArray(arr, ctorFunc) {
        var arrayClone = [];
        for (var elem in arr) {
            arrayClone.push(copyPropsShallow(arr[elem], ctorFunc()));
        }
        return arrayClone;
    }
    class Box {
        constructor(x1, y1, x2, y2) {
            this.x1 = Math.min(x1, x2);
            this.x2 = Math.max(x1, x2);
            this.y1 = Math.min(y1, y2);
            this.y2 = Math.max(y1, y2);
        }
        get width() {
            return this.x2 - this.x1;
        }
        get height() {
            return this.y2 - this.y1;
        }
        isPoint() {
            return (this.width == 0) && (this.height == 0);
        }
    }
    function inBox(x, y, box) {
        return (x > box.x1
            && x < box.x2
            && y > box.y1
            && y < box.y2);
    }
    function isSame(a, b) {
        if (a.length != b.length)
            return false;
        var found = true;
        for (var i = 0; i < a.length; i++) {
            found = false;
            for (var j = 0; j < b.length; j++) {
                if (a[i] == b[j])
                    found = true;
            }
            if (!found)
                return false;
        }
        return true;
    }
    function cloneCompound(compound) {
        var result = new IDCompound();
        if (compound.nodeIds) {
            result.nodeIds = [];
            for (var i = 0; i < compound.nodeIds.length; i++) {
                result.nodeIds.push(compound.nodeIds[i]);
            }
        }
        if (compound.linkIds) {
            result.linkIds = [];
            for (var i = 0; i < compound.linkIds.length; i++) {
                result.linkIds.push(compound.linkIds[i]);
            }
        }
        if (compound.nodePairIds) {
            result.nodePairIds = [];
            for (var i = 0; i < compound.nodePairIds.length; i++) {
                result.nodePairIds.push(compound.nodePairIds[i]);
            }
        }
        if (compound.timeIds) {
            result.timeIds = [];
            for (var i = 0; i < compound.timeIds.length; i++) {
                result.timeIds.push(compound.timeIds[i]);
            }
        }
        return result;
    }
    function makeIdCompound(elements) {
        var result = new IDCompound;
        if (elements != undefined) {
            if (elements.nodes) {
                result.nodeIds = elements.nodes.map((n, i) => n.id());
            }
            if (elements.links) {
                result.linkIds = elements.links.map((n, i) => n.id());
            }
            if (elements.times) {
                result.timeIds = elements.times.map((n, i) => n.id());
            }
            if (elements.nodePairs) {
                result.nodePairIds = elements.nodePairs.map((n, i) => n.id());
            }
        }
        return result;
    }
    function formatAtGranularity(time, granualarity) {
        switch (granualarity) {
            case 0: return time.millisecond();
            case 1: return time.second();
            case 2: return time.minute();
            case 3: return time.hour();
            case 4: return time.day();
            case 5: return time.week();
            case 6: return time.month() + 1;
            case 7: return time.year();
        }
    }
    function arraysEqual(a, b) {
        if (a === b)
            return true;
        if (a == null || b == null)
            return false;
        if (a.length != b.length)
            return false;
        // If you don't care about the order of the elements inside
        // the array, you should sort both arrays here.
        for (var i = 0; i < a.length; ++i) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    }
    function encapsulate(array, attrName) {
        if (attrName == undefined) {
            attrName = 'element';
        }
        var a = [];
        var o;
        for (var i = 0; i < array.length; i++) {
            o = {
                index: i,
            };
            o[attrName] = array[i];
            a.push(o);
        }
        return a;
    }
    function isPointInPolyArray(poly, pt) {
        for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)
            ((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) || (poly[j][1] <= pt[1] && pt[1] < poly[i][1])) && (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0]) && (c = !c);
        return c;
    }
    function formatTimeAtGranularity(time, granualarity) {
        var momentTime = moment.utc(time.unixTime());
        switch (granualarity) {
            case 0: return momentTime.millisecond();
            case 1: return momentTime.second();
            case 2: return momentTime.minute();
            case 3: return momentTime.hour();
            case 4: return momentTime.day();
            case 5: return momentTime.week();
            case 6: return momentTime.month() + 1;
            default: return momentTime.year();
        }
    }
    ////////////////////////////
    /// SCREENSHOT FUNCTIONS ///
    ////////////////////////////
    ///////////
    /// PNG ///
    ///////////
    // Downloads the content of the openGL canvas to the 
    // desktop.
    function downloadPNGFromCanvas(name) {
        var blob = getBlobFromCanvas(document.getElementsByTagName('canvas')[0]);
        var fileNameToSaveAs = name + '_' + new Date().toUTCString() + '.png';
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.href = window.URL.createObjectURL(blob);
        downloadLink.click();
    }
    // Returns a blob from the passed canvas.
    function getBlobFromCanvas(canvas) {
        var dataURL = canvas.toDataURL("image/png");
        return dataURItoBlob(dataURL);
    }
    ///////////
    /// SVG ///
    ///////////
    // downloads a screenshot on the desktop from the passed svg
    function downloadPNGfromSVG(name, svgId) {
        var blob = getBlobFromSVG(name, svgId);
    }
    // creates an image blob from the passed svg and calls the 
    // callback function with the blob as parameter
    function getBlobFromSVG(name, svgId, callback) {
        var width = $('#' + svgId).width();
        var height = $('#' + svgId).height();
        if (callback != undefined) // UNDEFINED ?? 
            getBlobFromSVGString(name, getSVGString(d3.select('#' + svgId).node()), width, height, callback); // what happend if callback undefinied (example above)
    }
    function getBlobFromSVGNode(name, svgNode, callback, backgroundColor) {
        var string = getSVGString(svgNode);
        var width = svgNode.getAttribute('width');
        var height = svgNode.getAttribute('height');
        if (width == null) {
            width = window.innerWidth + 1000;
        }
        if (height == null) {
            height = window.innerHeight + 1000;
        }
        getBlobFromSVGString(name, string, width, height, callback, backgroundColor);
    }
    function getBlobFromSVGString(name, svgString, width, height, callback, backgroundColor) {
        // turn SVG in to PNG
        var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL
        // Prepare canvas
        var canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext("2d");
        var image = new Image();
        image.src = imgsrc;
        image.onload = function () {
            context.clearRect(0, 0, width, height);
            if (backgroundColor) {
                context.fillStyle = backgroundColor;
                context.fillRect(0, 0, canvas.width, canvas.height);
            }
            context.drawImage(image, 0, 0, width, height);
            canvas.toBlob(function (blob) {
                callback(blob, name);
            });
        };
    }
    function getSVGString(svgNode) {
        svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
        var cssStyleText = getCSSStyles(svgNode);
        appendCSS(cssStyleText, svgNode);
        var serializer = new XMLSerializer();
        var svgString = serializer.serializeToString(svgNode);
        svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
        svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix
        return svgString;
        function getCSSStyles(parentElement) {
            var selectorTextArr = [];
            // Add Parent element Id and Classes to the list
            selectorTextArr.push('#' + parentElement.id);
            for (var c = 0; c < parentElement.classList.length; c++)
                if (!contains('.' + parentElement.classList[c], selectorTextArr))
                    selectorTextArr.push('.' + parentElement.classList[c]);
            // Add Children element Ids and Classes to the list
            var nodes = parentElement.getElementsByTagName("*");
            for (var i = 0; i < nodes.length; i++) {
                var id = nodes[i].id;
                if (!contains('#' + id, selectorTextArr))
                    selectorTextArr.push('#' + id);
                var classes = nodes[i].classList;
                for (var c = 0; c < classes.length; c++)
                    if (!contains('.' + classes[c], selectorTextArr))
                        selectorTextArr.push('.' + classes[c]);
            }
            // Extract CSS Rules
            var extractedCSSText = "";
            for (var i = 0; i < document.styleSheets.length; i++) {
                var s = document.styleSheets[i];
                try {
                    if (!s.cssRules)
                        continue;
                }
                catch (e) {
                    if (e.name !== 'SecurityError')
                        throw e; // for Firefox
                    continue;
                }
                var cssRules = s.cssRules;
                for (var r = 0; r < cssRules.length; r++) {
                    var rule = cssRules[r];
                    if (contains(rule.selectorText, selectorTextArr))
                        extractedCSSText += rule.cssText;
                }
            }
            return extractedCSSText;
            function contains(str, arr) {
                return arr.indexOf(str) === -1 ? false : true;
            }
        }
        function appendCSS(cssText, element) {
            var styleElement = document.createElement("style");
            styleElement.setAttribute("type", "text/css");
            styleElement.innerHTML = cssText;
            var refNode = element.hasChildNodes() ? element.children[0] : null;
            element.insertBefore(styleElement, refNode);
        }
    }
    function exportPNG(canvas, name) {
        var dataURL = canvas.toDataURL('image/jpg', 1);
        var blob = dataURItoBlob(dataURL);
        // window.open(dataURL);
        var fileNameToSaveAs = name + '_' + new Date().toUTCString() + '.png';
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.href = window.webkitURL.createObjectURL(blob);
        downloadLink.click();
    }
    // returns a blob from a URL/URI
    function dataURItoBlob(dataURI) {
        // convert base64/URLEncoded data component to raw binary data held in a string
        var byteString;
        if (dataURI.split(',')[0].indexOf('base64') >= 0)
            byteString = atob(dataURI.split(',')[1]);
        else
            byteString = unescape(dataURI.split(',')[1]);
        // separate out the mime component
        var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
        console.log('mimeString', mimeString);
        // write the bytes of the string to a typed array
        var ia = new Uint8Array(byteString.length);
        for (var i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
        return new Blob([ia], { type: mimeString });
    }
    var msgBox;
    function showMessage(message, timeout) {
        if ($('.messageBox'))
            $('.messageBox').remove();
        msgBox = $('<div id="div" class="messageBox" style="\
            width: 100%;\
            height: 100%;\
            background-color: #ffffff;\
            opacity: .9;\
            position: absolute;\
            top: 0px;\
            left: 0px;"></div>');
        msgBox.append('<div id="div" style="\
            font-size: 20pt;\
            font-weight: bold;\
            font-family: "Helvetica Neue", Helvetica, sans-serif;\
            width: 500px;\
            padding-top: 300px;\
            text-align: center;\
            margin:auto;">\
            <p>' + message + '</p></div>');
        $('body').append(msgBox);
        msgBox.click(function () {
            $('.messageBox').remove();
        });
        if (timeout) {
            // Automatically disappear
            window.setTimeout(function () {
                $('.messageBox').fadeOut(1000);
            }, timeout);
        }
    }

    var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getType: getType,
        makeElementCompound: makeElementCompound,
        ElementCompound: ElementCompound,
        getPriorityColor: getPriorityColor,
        sortByPriority: sortByPriority,
        getUrlVars: getUrlVars,
        capitalizeFirstLetter: capitalizeFirstLetter,
        isBefore: isBefore,
        isAfter: isAfter,
        hex2Rgb: hex2Rgb,
        hex2web: hex2web,
        hex2RgbNormalized: hex2RgbNormalized,
        areEqualShallow: areEqualShallow,
        compareTypesShallow: compareTypesShallow,
        copyArray: copyArray,
        Box: Box,
        inBox: inBox,
        isSame: isSame,
        cloneCompound: cloneCompound,
        makeIdCompound: makeIdCompound,
        formatAtGranularity: formatAtGranularity,
        arraysEqual: arraysEqual,
        encapsulate: encapsulate,
        isPointInPolyArray: isPointInPolyArray,
        formatTimeAtGranularity: formatTimeAtGranularity,
        downloadPNGFromCanvas: downloadPNGFromCanvas,
        downloadPNGfromSVG: downloadPNGfromSVG,
        getBlobFromSVG: getBlobFromSVG,
        getBlobFromSVGNode: getBlobFromSVGNode,
        getBlobFromSVGString: getBlobFromSVGString,
        getSVGString: getSVGString,
        exportPNG: exportPNG,
        showMessage: showMessage
    });

    /**
    * Calculates an ordering for the passed graph and time span
    * @param  {DynamicGraph} dgraph [description]
    * @param  {Time}         start  [description]
    * @param  {Time}         end    [description]
    * @return {[type]}              [description]
    */
    function orderNodes(graph, config) {
        var similarityMatrix = [];
        var order = graph.nodes().ids();
        var distance;
        var nodes;
        var links;
        var start;
        var end;
        if (config != undefined) {
            distance = config.distance ? config.distance : distance.manhattan;
            nodes = config.nodes ? config.nodes : graph.nodes().toArray();
            links = config.links ? config.links : graph.links().toArray();
            start = config.start ? config.start : graph.startTime;
            end = config.end ? config.end : graph.endTime;
        }
        else {
            distance = distance.manhattan;
            nodes = graph.nodes().toArray();
            links = graph.links().toArray();
            start = graph.startTime;
            end = graph.endTime;
        }
        // init similarity matrix with all 0.
        var arr;
        for (var i = 0; i < nodes.length; i++) {
            arr = [];
            similarityMatrix.push(arr);
            for (var j = 0; j < nodes.length; j++) {
                similarityMatrix[i].push(0);
            }
        }
        // fill matrix
        var weight = 0;
        var s;
        var t;
        for (var i = 0; i < links.length; i++) {
            weight = 0;
            // check if nodes are in allowed nodes
            s = nodes.indexOf(links[i].source);
            t = nodes.indexOf(links[i].target);
            if (s == -1 || t == -1)
                continue;
            // get weight in allowed time span                 
            weight += links[i].weights(start, end).mean();
            if (weight) {
                similarityMatrix[s][t] = weight;
                similarityMatrix[t][s] = weight;
            }
            else {
                console.log('weight', weight);
            }
        }
        // Reorder
        var leafOrder = reorder.optimal_leaf_order()
            .distance(distance)
            .reorder(similarityMatrix);
        leafOrder.forEach(function (lo, i) {
            order[nodes[lo].id()] = i;
        });
        return order;
    }
    class OrderingConfiguration {
        constructor(start, end) {
            this.nodes = [];
            this.links = [];
            this.algorithm = [];
            this.distance = [];
            this.start = start,
                this.end = end;
        }
    }

    var ordering = /*#__PURE__*/Object.freeze({
        __proto__: null,
        orderNodes: orderNodes,
        OrderingConfiguration: OrderingConfiguration
    });

    // import swiftSet from 'swiftset';
    function findTemplate(nodes, template, config) {
        var nodeCount = template.nodes.length;
        var linkCount = template.links.length;
        var links;
        for (var i = 0; i < nodes.length; i++) {
            links = nodes[i].links().toArray();
            for (var j = 0; j < nodeCount; j++) {
                for (var k = 0; k < linkCount; k++) {
                    if (template.links[k][0] == template.nodes[j])
                        ;
                }
            }
        }
    }
    function findClusters(nodes, config) {
        if (nodes.length == 0)
            return [];
        var g = nodes[0].g;
        var links = nodes[0].g.links().toArray();
        for (var i = 0; i < links.length; i++) {
            links[i].value = links[i].weights().sum(); // VALUE ???
        }
        var clusters = netClustering.cluster(nodes, links);
        var motifs = [];
        // replace ids with nodes
        var clusterLinks = [];
        var cl;
        for (var c = 0; c < clusters.length; c++) {
            clusterLinks = [];
            cl = clusters[c];
            // exclude clusters with less than 4 nodes
            if (cl.length < 4)
                continue;
            for (var j = 0; j < cl.length; j++) {
                cl[j] = g.node(parseInt(cl[j]));
            }
            for (var i = 0; i < cl.length; i++) {
                for (var j = i + 1; j < cl.length; j++) {
                    clusterLinks = clusterLinks.concat(cl[i].linksBetween(cl[j]).toArray());
                }
            }
            motifs.push({ nodes: cl, links: clusterLinks });
        }
        return motifs;
    }
    /*
    function bronKerboschIterative(nodes: Node[], config: Object): any[] {
        var cliques: any[] = []

        var stack: any[] = [];
        var R: number = 0
        var P: number = 1
        var X: number = 2
        stack.push([[], nodes, []])

        var r: Node[];
        var p: Node[];
        var x: Node[];
        var p2: Node[];
        var x2: Node[];
        var step: any[];
        var newStep: any[];
        var v: Node;
        var count: number = 0;
        while (stack.length > 0) {
            count++;
            step = stack.pop();
            r = [].concat(step[R]);
            p = [].concat(step[P]);
            x = [].concat(step[X]);
            if (p.length == 0
                && x.length == 0) {
                cliques.push(r.slice())
            }
            if (p.length > 0) {
                v = p[0] // 'some vertex in P'

                // P \ v
                p2 = p.slice()
                p2.splice(p2.indexOf(v), 1)

                // X u v
                x2 = x.slice()
                if (x2.indexOf(v) == -1)
                    x2.push(v);

                // R, P\v, X u v
                stack.push([r.slice(), p2, x2])

                // R u v
                if (r.indexOf(v) == -1)
                    r.push(v)

                newStep = [r]

                p = swiftSet.intersection(p2, v.neighbors().toArray())
                p2 = []
                for (var i = 0; i < p.length; i++) {
                    if (p2.indexOf(p[i]) == -1)
                        p2.push(p[i])
                }
                newStep.push(p2)

                x = swiftSet.intersection(x2, v.neighbors().toArray())
                x2 = []
                for (var i = 0; i < x.length; i++) {
                    if (x2.indexOf(x[i]) == -1)
                        x2.push(x[i])
                }
                newStep.push(x2)

                stack.push(newStep)
            }
        }


        return cliques;
    }
    */
    function findFullEgoNetwork(nodes, config) {
        var motifs = [];
        var ns;
        var ls;
        var finalLinks;
        var n;
        for (var i = 0; i < nodes.length; i++) {
            n = nodes[i];
            finalLinks = [];
            ns = n.neighbors().removeDuplicates();
            ls = ns.links().removeDuplicates().toArray();
            ns = ns.toArray().concat(n);
            for (var j = 0; j < ls.length; j++) {
                if (ls[j] == undefined)
                    continue;
                if (ns.indexOf(ls[j].source) > -1 && ns.indexOf(ls[j].target) > -1) {
                    finalLinks.push(ls[j]);
                }
            }
            motifs.push(new Motif(ns, finalLinks));
        }
        return motifs;
    }
    /*
    export function findStars(nodes: Node[], config?: any) {
        if (!config)
            var config: any = {}

        if (config.minLinkCount == undefined)
            config.minLinkCount = 5;

        if (config.minNeighborCount == undefined) {
            config.minNeighborCount = 5;
            config.minLinkCount = 5;
        }

        if (config.links == undefined)
            config.links = nodes[0].g.links().toArray();

        var motifs: Motif[] = [];
        var n: Node;
        var lls: Link[]
        var m: Motif;
        var neighbors;
        for (var i = 0; i < nodes.length; i++) {
            n = nodes[i];
            lls = n.links().toArray();
            lls = swiftSet.intersection(lls, config.links);
            if (lls.length <= config.minLinkCount)
                continue

            // count real neighbors
            neighbors = []
            for (var j = 0; j < lls.length; j++) {
                if (neighbors.indexOf(lls[j].other(n)) == -1)
                    neighbors.push(lls[j].other(n))
            }
            if (neighbors.length <= config.minNeighborCount)
                continue;

            // create motif
            m = new Motif([n], [])
            for (var j = 0; j < lls.length; j++) {
                m.links.push(lls[j])
                m.nodes.push(lls[j].other(n))
            }
            motifs.push(m);
        }
        return motifs;
    }
    */
    /*
    // returns triangles
    export function findTriangles(nodes: Node[], config?: any): Motif[] {

        if (!config)
            var config: any = {}

        if (config.links == undefined)
            config.links = nodes[0].g.links().toArray();



        var motifs: Motif[] = [];
        var g: DynamicGraph = nodes[0].g;

        var l: Link;
        var s: Node, t: Node
        var ns: Node[], nt: Node[];
        var common: Node[]
        var n: Node;
        var ll1: Link[], ll2: Link[];
        var found;
        var m: Motif;
        for (var i = 0; i < config.links.length; i++) {
            s = config.links[i].source;
            ns = s.neighbors().toArray();
            ns = swiftSet.intersection(ns, nodes);
            if (ns.length == 0)
                continue;
            t = config.links[i].target;
            nt = t.neighbors().toArray();
            nt = swiftSet.intersection(nt, nodes);
            if (nt.length == 0)
                continue;
            common = swiftSet.intersection(ns, nt);
            // remove s and t from common neighbors
            common = swiftSet.difference(common, [s, t])
            if (common.length == 0)
                continue;

            // create triangle motifs
            for (var j = 0; j < common.length; j++) {
                n = common[j];
                ll1 = swiftSet.intersection(g.linksBetween(s, n).toArray(), config.links);
                if (ll1.length == 0) continue;
                ll2 = swiftSet.intersection(g.linksBetween(t, n).toArray(), config.links);
                if (ll2.length == 0) continue;

                ll1 = ll1.concat(ll2);
                ll1.push(config.links[i]);
                motifs.push(new Motif(
                    [s, t, n],
                    ll1
                ))
            }
        }

        return motifs;
    }
    */
    //}

    var motifs = /*#__PURE__*/Object.freeze({
        __proto__: null,
        findTemplate: findTemplate,
        findClusters: findClusters,
        findFullEgoNetwork: findFullEgoNetwork
    });

    /** A collection of Networkcube's  global function availeble
     * through networkcube.myFunc()
     * */
    // must agree with var of same name in DynamicGraph.initDynamicGraph()
    var TIME_FORMAT = 'YYYY-MM-DD hh:mm:ss';
    /**
     * Returns the networkcube standart time format
     * @return {[type]} [description]
     */
    function timeFormat() {
        return TIME_FORMAT;
    }
    // GLOBAL VARIABLES
    var dataManager = new DataManager();
    var session;
    function getSessionId() {
        return session;
    }
    function setDataManagerOptions(options) {
        dataManager.setOptions(options);
    }
    function isSessionCached(session, dataSetName) {
        return dataManager.isSessionCached(session, dataSetName);
    }
    // DATA
    /**
     * Imports a data set into network cube.
     * @param  {string}  session [description]
     * @param  {DataSet} data    [description]
     * @return {[type]}          [description]
     */
    function importData(sessionName, data) {
        console.log('[n3] Import data', data.name);
        session = sessionName;
        dataManager.importData(sessionName, data);
    }
    function clearAllDataManagerSessionCaches() {
        dataManager.clearAllSessionData();
    }
    function getDynamicGraph(dataName, sessionName) {
        var vars = getUrlVars();
        if (!dataName)
            dataName = vars['datasetName'];
        if (!sessionName)
            session = vars['session'];
        else
            session = sessionName;
        return dataManager.getGraph(session, dataName);
    }
    // VIEWS + VISUALIZATIONS
    // opens a new window and loads a visualization of type vistype,
    // // with the data set dataname
    function openVisualizationWindow(session, visUri, dataName) {
        openView(session, visUri, dataName, false);
    }
    // opens a new tab and loads a visualization of type vistype,
    // // with the data set dataname
    function openVisualizationTab(session, visUri, dataName) {
        openView(session, visUri, dataName, true);
    }
    // create a tab that shows one of the specified visualizations at a time
    function createTabVisualizations(parentId, visSpec, session, dataName, width, height, visParams) {
        var parent = $('#' + parentId);
        var tabDiv = $('<div></div>');
        parent.append(tabDiv);
        var visDiv = $('<div></div>');
        parent.append(visDiv);
        var ul = $('<ul class="networkcube-tabs"\
                style="\
                    list-style-type: none;\
                    margin: 0;\
                    padding:2px;\
                    overflow: hidden;\
                    border: none;\
                    background-color: #f1f1f1;"\
                ></ul>');
        tabDiv.append(ul);
        // create tabs and divs
        for (var i = 0; i < visSpec.length; i++) {
            visSpec[i].name = visSpec[i].name.replace(' ', '-');
            ul.append($('<li style="float: left;"><a style="\
                display: inline-block;\
                color: black;\
                margin-right: 8px;\
                margin-left: 8px;\
                padding: 5px;\
                text-align: left;\
                text-decoration: none;\
                transition: 0.3s;\
                font-weight: 800;\
                border: #fff 1px solid;\
                border-raduis: 5px;\
                font-size: 13px;" href="#" class="networkcube-tablinks" onclick="networkcube.switchVisTab(event, \'' + visSpec[i].name + '\')">' + visSpec[i].name + '</a></li>'));
            visDiv.append($('<div id="networkcube-visTab-' + visSpec[i].name + '" style="display:' + (i == 0 ? 'block' : 'none') + ';" class="networkcube-visTabContent"></div>'));
            createVisualizationIFrame('networkcube-visTab-' + visSpec[i].name, visSpec[i].url, session, dataName, width, height, visParams);
        }
    }
    function switchVisTab(evt, visName) {
        // Declare all variables
        var i, tabcontent, tablinks;
        // Get all elements with class="tabcontent" and hide them
        tabcontent = document.getElementsByClassName("networkcube-visTabContent");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }
        // Get all elements with class="tablinks" and remove the class "active"
        tablinks = document.getElementsByClassName("networkcube-tablinks");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        // Show the current tab, and add an "active" class to the link that opened the tab
        // ADD IF GETELEMENT IS NULL
        var element = document.getElementById('networkcube-visTab-' + visName);
        if (element) {
            element.style.display = "block";
        }
        evt.currentTarget.className += " active";
    }
    // returns an iframe that loads a visualization of type vistype,
    // with the data set dataname
    function createVisualizationIFrame(parentId, visUri, session, dataName, width, height, visParams) {
        $('#' + parentId)
            .append('<iframe></iframe>')
            .attr('width', width)
            .attr('height', height);
        var iframe = $('#' + parentId + '> iframe');
        var visParamString = '';
        for (var prop in visParams) {
            visParamString += '&' + prop + '=' + visParams[prop];
        }
        if (!visUri.startsWith('http')) {
            if (window.location.port)
                var server = location.protocol + '//' + window.location.hostname + ':' + window.location.port + '' + window.location.pathname;
            else
                var server = location.protocol + '//' + window.location.hostname + '' + window.location.pathname;
            visUri = server + "/node_modules/vistorian-" + visUri + "/web/index.html";
        }
        iframe.attr('src', visUri + '?'
            + 'session=' + session
            + '&datasetName=' + dataName
            + visParamString);
        if (width)
            iframe.attr('width', width);
        if (height)
            iframe.attr('height', height);
        if (visParams != undefined && visParams.hasOwnProperty('scrolling')) {
            iframe.attr('scrolling', visParams.scrolling);
        }
        return iframe;
    }
    //
    // // Internal convenient function to open a window
    function openView(session, visUri, dataname, tab) {
        if (!visUri.startsWith('http')) {
            if (window.location.port)
                var server = location.protocol + '//' + window.location.hostname + ':' + window.location.port + '' + window.location.pathname;
            else
                var server = location.protocol + '//' + window.location.hostname + '' + window.location.pathname;
            visUri = server + "/node_modules/vistorian-" + visUri + "/web/index.html";
        }
        var url = visUri + '?session=' + session + '&datasetName=' + dataname;
        if (tab)
            window.open(url, '_blank');
        else
            window.open(url);
    }
    function getURLString(dataName) {
        return '?session=' + session + '&datasetName=' + dataName;
    }
    /// UTILITY FUNCTIONS
    var OrderType;
    (function (OrderType) {
        OrderType[OrderType["Local"] = 0] = "Local";
        OrderType[OrderType["Global"] = 1] = "Global";
        OrderType[OrderType["Data"] = 2] = "Data";
    })(OrderType || (OrderType = {}));
    function isTrackingEnabled() {
        var value = localStorage.getItem("NETWORKCUBE_IS_TRACKING_ENABLED");
        return value == 'true' ? true : false;
    }
    function isTrackingSet() {
        var value = localStorage.getItem("NETWORKCUBE_IS_TRACKING_ENABLED");
        return value === null ? false : true;
    }
    function deleteData(dataSetName) {
        // deletes a network
        getDynamicGraph(dataSetName).delete(dataManager);
    }

    var main = /*#__PURE__*/Object.freeze({
        __proto__: null,
        TIME_FORMAT: TIME_FORMAT,
        timeFormat: timeFormat,
        getSessionId: getSessionId,
        setDataManagerOptions: setDataManagerOptions,
        isSessionCached: isSessionCached,
        importData: importData,
        clearAllDataManagerSessionCaches: clearAllDataManagerSessionCaches,
        getDynamicGraph: getDynamicGraph,
        openVisualizationWindow: openVisualizationWindow,
        openVisualizationTab: openVisualizationTab,
        createTabVisualizations: createTabVisualizations,
        switchVisTab: switchVisTab,
        createVisualizationIFrame: createVisualizationIFrame,
        getURLString: getURLString,
        get OrderType () { return OrderType; },
        isTrackingEnabled: isTrackingEnabled,
        isTrackingSet: isTrackingSet,
        deleteData: deleteData
    });

    function loadDyson(url, callback) {
        d3.json(url, (data) => {
            // create node table
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var nodes = data.nodes;
            for (var i = 0; i < nodes.length; i++) {
                nodeTable.push([i, nodes[i].name]);
            }
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2, weight: 3, time: 4 };
            var times = data.times;
            var m;
            for (var i = 0; i < times.length; i++) {
                m = times[i].matrix;
                for (var s = 0; s < m.length; s++) {
                    for (var t = 0; t < m.length; t++) {
                        linkTable.push([s * m.length + t, s, t, m[s][t], i]);
                    }
                }
            }
            callback(new DataSet({
                nodeTable: nodeTable,
                linkTable: linkTable,
                linkSchema: linkSchema,
                nodeSchema: nodeSchema,
                name: url
            }));
        });
    }
    /** Loads a .csv file from the indicated url*/
    // does not check for locations
    function loadLinkTable(url, callBack, linkSchema, delimiter, timeFormat$1) {
        if (timeFormat$1 == undefined)
            timeFormat$1 = 'x';
        // Check if linkSchema is well defined: 
        if (linkSchema.source == undefined) {
            console.error('[n3] Link Schema does not have -source- attribute. Import aborted.');
            return;
        }
        if (linkSchema.target == undefined) {
            console.error('[n3] Link Schema does not have -target- attribute. Import aborted.');
            return;
        }
        $.get(url, (linkData) => {
            var array = [];
            var rows = linkData.split('\r\n');
            for (var i = 1; i < rows.length; i++) {
                array.push(rows[i].split(delimiter));
            }
            linkData = array;
            // get references to tables
            var nodeTable = [];
            // var nodeIds: number[] = [];
            var names = [];
            var nodeSchema = new NodeSchema(0);
            nodeSchema.label = 1;
            var id_source;
            var id_target;
            var name;
            var linkTable = [];
            var newLinkSchema = new LinkSchema(0, 1, 2);
            // fill new link schema
            var colCount = 3;
            for (var prop in linkSchema) {
                if (prop != 'source' && prop != 'target')
                    newLinkSchema[prop] = colCount++;
            }
            // Create node table
            // skip first row, as 1st row contains header information
            linkData.shift();
            var linkRow;
            for (var i = 0; i < linkData.length; i++) {
                if (linkData[i].length == 0 || linkData[i][0].length == 0) {
                    continue;
                }
                linkRow = new Array(colCount);
                if (linkSchema.id == undefined)
                    linkRow[0] = linkTable.length;
                else
                    linkRow[0] = linkData[i][linkSchema.id];
                // remove whitespace in table entries
                for (var j = 0; j < linkData[i].length; j++) {
                    linkData[i][j] = linkData[i][j].trim();
                }
                // sources
                name = linkData[i][linkSchema.source];
                if (names.indexOf(name) == -1) {
                    names.push(name);
                }
                id_source = names.indexOf(name);
                // targets
                name = linkData[i][linkSchema.target];
                if (names.indexOf(name) == -1) {
                    names.push(name);
                }
                id_target = names.indexOf(name);
                // replace node names by node indices
                linkRow[newLinkSchema.source] = id_source;
                linkRow[newLinkSchema.target] = id_target;
                // format weight
                if (linkSchema.weight != undefined) {
                    linkRow[newLinkSchema.weight] = Number(linkData[i][linkSchema.weight]);
                }
                // format time
                if (linkSchema.time != undefined) {
                    linkRow[newLinkSchema.time] = moment.utc(linkData[i][linkSchema.time], timeFormat$1).format(timeFormat());
                }
                // copy remaining attributes (linkType, weight, etc..)
                for (var prop in linkSchema) {
                    if (prop != 'source' && prop != 'target' && prop != 'time' && prop != 'weight') {
                        linkRow[newLinkSchema[prop]] = linkData[i][linkSchema[prop]];
                    }
                }
                linkTable.push(linkRow);
            }
            // create node table from node name list
            for (var i = 0; i < names.length; i++) {
                nodeTable.push([i, names[i]]);
            }
            var dataSet = new DataSet({
                nodeTable: nodeTable,
                linkTable: linkTable,
                linkSchema: newLinkSchema,
                nodeSchema: nodeSchema,
                name: url
            });
            if (linkSchema.time != undefined) {
                dataSet.timeFormat = timeFormat();
            }
            callBack(dataSet);
        }, 'text');
    }
    function loadXML(url, callBack) {
        var url = url;
        var callBack = callBack;
        d3.xml(url, (data) => {
            var nodes = data.documentElement.getElementsByTagName("node");
            var nodeTable = [];
            var nodeIds = [];
            var nodeSchema = { id: 0, label: 1, nodeType: 2 };
            for (var i = 0; i < nodes.length; i++) {
                nodeTable.push([nodeTable.length, nodes[i].getAttribute('name'), nodes[i].getAttribute('type')]);
                nodeIds.push(nodes[i].id);
            }
            var linkTable = [];
            var linkSchema = new LinkSchema(0, 1, 2);
            var links = data.documentElement.getElementsByTagName("edge");
            var s, t;
            var sPrev, tPrev;
            for (var i = 0; i < links.length; i++) {
                s = nodeIds.indexOf(links[i].getAttribute('source'));
                t = nodeIds.indexOf(links[i].getAttribute('through'));
                if (sPrev == s && tPrev == t) {
                    continue;
                }
                sPrev = s;
                tPrev = t;
                linkTable.push([linkTable.length, s, t]);
            }
            callBack(new DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    /** Loads a .json file from the indicated url.
     * The json must have a 'nodes/vertices' and a 'links/edge/connections/relations' array.
    */
    function loadJson(url, callBack, dataName) {
        var url = url;
        var callBack = callBack;
        d3.json(url, (data) => {
            if (!data)
                return;
            // fill edge table
            var links = data.links;
            if (!links)
                links = data.edges;
            if (!links)
                links = data.connections;
            if (!links)
                links = data.relations;
            var linkTable = [];
            var line = [];
            var link;
            var linkSchema = { id: 0, source: 1, target: 2, weight: 3 };
            var weight;
            var linkUserProps = [];
            var prop;
            // check for user-properties to complete schema
            for (var i = 0; i < links.length; i++) {
                link = links[i];
                for (prop in link) {
                    if (link.hasOwnProperty(prop)
                        && prop != 'id'
                        && prop != 'linkType'
                        && prop != 'time'
                        && prop != 'name'
                        && prop != 'source'
                        && prop != 'target'
                        && prop != 'weight'
                        && prop != 'directed') {
                        if (linkSchema[prop] == undefined) {
                            linkUserProps.push(prop);
                            linkSchema[prop] = 3 + linkUserProps.length;
                        }
                    }
                }
            }
            // collect data from links
            for (var i = 0; i < links.length; i++) {
                link = links[i];
                weight = 1;
                if (link.weight != undefined)
                    weight = link.weight;
                line = [i, link.source, link.target, weight];
                for (var p = 0; p < linkUserProps.length; p++) {
                    prop = linkUserProps[p];
                    if (link[prop] == undefined) {
                        line.push(undefined);
                    }
                    else {
                        line.push(link[prop]);
                    }
                }
                linkTable.push(line);
            }
            // fill node table
            var nodes = data.nodes;
            if (!nodes)
                nodes = data.vertices;
            var node;
            var nodeTable = [];
            var locationTable = []; // location table in case there are locations
            var locationSchema = { id: 0, longitude: 1, latitude: 2 }; // location table in case there are locations
            var nodeSchema = { id: 0, label: 1 };
            var nodeUserProperties = [];
            for (var i = 0; i < nodes.length; i++) {
                node = nodes[i];
                for (prop in node) {
                    if (node.hasOwnProperty(prop)
                        && prop != 'id'
                        && prop != 'label'
                        && prop != 'time'
                        && prop != 'name'
                        && prop != 'nodeType'
                        && prop != 'location'
                        && prop != 'constructor') {
                        if (nodeSchema[prop] == undefined) {
                            nodeUserProperties.push(prop);
                            nodeSchema[prop] = 1 + nodeUserProperties.length;
                        }
                    }
                }
            }
            for (var i = 0; i < nodes.length; i++) {
                node = nodes[i];
                line = [i];
                if (node.name) {
                    line.push(node.name);
                }
                else if (node.label) {
                    line.push(node.label);
                }
                else {
                    line.push('' + i);
                }
                // if(node.group){
                //     line.push(node.group)
                // }else{
                //     line.push('0')
                // }
                // check for user-properties
                for (var p = 0; p < nodeUserProperties.length; p++) {
                    prop = nodeUserProperties[p];
                    if (node[prop] == undefined) {
                        line.push(undefined);
                    }
                    else {
                        line.push(node[prop]);
                    }
                }
                nodeTable.push(line);
            }
            if (dataName == undefined)
                dataName = url.split('=')[0];
            callBack(new DataSet({
                name: dataName,
                nodeTable: nodeTable,
                locationTable: locationTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                locationSchema: locationSchema,
                linkSchema: linkSchema
            }));
        });
    }
    function loadJsonList(url, callBack) {
        var url = url;
        var callBack = callBack;
        d3.json(url, (data) => {
            if (!data)
                return;
            // fill node and link table
            var linkTable = [];
            var line = [];
            var linkSchema = new LinkSchema(0, 1, 2);
            var nodes = data;
            var node;
            var nodeTable = [];
            var nodeSchema = new NodeSchema(0);
            var nodeNames = [];
            for (var i = 0; i < nodes.length; i++) {
                node = nodes[i];
                line = [i];
                if (node.name) {
                    line.push(node.name);
                    nodeSchema.label = 1;
                }
                if (node.label) {
                    line.push(node.name);
                    nodeSchema.label = 1;
                }
                nodeNames.push(node.name);
                nodeTable.push(line);
            }
            // links
            var s, t;
            for (var i = 0; i < nodes.length; i++) {
                for (var j = 0; j < nodes[i].imports.length; j++) {
                    s = nodeNames.indexOf(nodes[i].name);
                    t = nodeNames.indexOf(nodes[i].imports[j]);
                    if (s == -1 || t == -1)
                        console.error('---');
                    else
                        linkTable.push([linkTable.length, s, t]);
                }
            }
            callBack(new DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    function loadNCube(url, callBack) {
        var url = url;
        var callBack = callBack;
        d3.json(url, (data) => {
            var nodeTable = [];
            var linkTable = [];
            var nodeSchema = new NodeSchema(0);
            nodeSchema.id = 0;
            nodeSchema.label = 1;
            nodeSchema.nodeType = 2;
            // create node table:
            for (var i = 0; i < data.nodes.length; i++) {
                console.log('data.nodes[i].name.substring(0,3)', data.nodes[i].name.substring(0, 3));
                nodeTable.push([
                    data.nodes[i].nodeId,
                    data.nodes[i].name,
                    data.nodes[i].name.substring(0, 3) // create node type for brain regions
                ]);
            }
            var linkSchema = new LinkSchema(0, 1, 2);
            linkSchema.id = 0;
            linkSchema.source = 1;
            linkSchema.target = 2;
            linkSchema.time = 3;
            linkSchema.weight = 4;
            // create link table
            // data.edges = data.edges.slice(0,20000);
            for (var i = 0; i < data.edges.length; i++) {
                linkTable.push([
                    data.edges[i].edgeId,
                    data.edges[i].sourceNodeId,
                    data.edges[i].targetNodeId,
                    moment.utc().add(data.edges[i].timeIndex, 'seconds').format('YYYY-MM-DD hh:mm:ss'),
                    data.edges[i].weight
                ]);
            }
            callBack(new DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    function loadPajek(url, callBack) {
        var url = url;
        var callBack = callBack;
        $.get(url, (data) => {
            var lines = data.split('\n');
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2, directed: 3 };
            var parseType = '';
            var line;
            for (var i = 0; i < lines.length; i++) {
                line = lines[i];
                // define data type
                if (line.indexOf('*Vertices') > -1) {
                    parseType = 'nodes';
                    continue;
                }
                else if (line.indexOf('*Arcs') > -1) {
                    parseType = 'undirectedLinks';
                    continue;
                }
                else if (line.indexOf('*Edges') > -1) {
                    parseType = 'directedLinks';
                    continue;
                }
                // prepare and clean line
                line = line.trim();
                line = line.split(' ');
                for (var j = 0; j < line.length; j) {
                    if (line[j].length == 0) {
                        line.splice(j, 1);
                    }
                    else {
                        j++;
                    }
                }
                if (line.length == 0)
                    continue;
                // parse data
                if (parseType.indexOf('nodes') > -1) {
                    nodeTable.push([nodeTable.length, line[1]]);
                }
                else if (parseType.indexOf('undirectedLinks') > -1) {
                    linkTable.push([linkTable.length, parseInt(line[0]) - 1, parseInt(line[1]) - 1, false]);
                }
                else if (parseType.indexOf('directedLinks') > -1) {
                    linkTable.push([linkTable.length, parseInt(line[0]) - 1, parseInt(line[1]) - 1, true]);
                }
            }
            callBack(new DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    function loadMat(url, callBack) {
        var url = url;
        var callBack = callBack;
        $.get(url, (data) => {
            var lines = data.split('\n');
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2 };
            var parseType = '';
            var line;
            var rowCount = 0;
            var currRow = 0;
            for (var i = 0; i < lines.length; i++) {
                line = lines[i];
                // define data type
                if (line.indexOf('ROW LABELS') > -1) {
                    parseType = 'rows';
                    continue;
                }
                else if (line.indexOf('COLUMN LABELS') > -1) {
                    parseType = 'cols';
                    continue;
                }
                else if (line.indexOf('DATA:') > -1) {
                    parseType = 'links';
                    continue;
                }
                if (parseType.length == 0)
                    continue;
                line = line.trim();
                line = line.split(' ');
                if (parseType.indexOf('rows') > -1) {
                    nodeTable.push([nodeTable.length, line[0]]);
                    rowCount++;
                }
                else if (parseType.indexOf('cols') > -1) {
                    if (line[0].indexOf(nodeTable[0][1] > -1)) {
                        parseType = '';
                        rowCount = 0;
                        continue;
                    }
                    nodeTable.push([nodeTable.length, line[0]]);
                }
                else if (parseType.indexOf('links') > -1) {
                    for (var j = 0; j < line.length; j++) {
                        if (parseInt(line[j]) == 1) {
                            linkTable.push([linkTable.length, currRow, rowCount + 1]);
                        }
                    }
                    currRow++;
                }
            }
            callBack(new DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    function loadGEDCOM(url, callBack) {
        var url = url;
        var callBack = callBack;
        var nodeTable = [];
        var nodeSchema = { id: 0, label: 1, nodeType: 2 };
        var linkTable = [];
        var linkSchema = { id: 0, source: 1, target: 2 };
        $.get(url, (data) => {
            data = data.split('\n');
            var singleLine;
            var line;
            var personIds = [];
            var personSex = [];
            var familiyIds = [];
            var familiyChildren = [];
            var familiyHusband = [];
            var familiyWife = [];
            for (var i = 0; i < data.length; i++) {
                singleLine = data[i].replace(/@/g, '');
                line = singleLine.split(' ');
                // parsing persons
                if (line.length < 3)
                    continue;
                if (parseInt(line[0]) == 0 && line[2].indexOf('INDI') > -1) {
                    personIds.push(line[1].trim());
                    personSex.push('');
                }
                else if (parseInt(line[0]) == 1 && line[1].indexOf('SEX') > -1) {
                    personSex[personSex.length - 1] = line[2].trim();
                }
                else if (parseInt(line[0]) == 0 && line[2].indexOf('FAM') > -1) {
                    familiyIds.push(line[1].trim());
                    familiyChildren.push([]);
                    familiyHusband.push(undefined);
                    familiyWife.push(undefined);
                }
                else if (parseInt(line[0]) == 1 && line[1].indexOf('CHIL') > -1) {
                    familiyChildren[familiyChildren.length - 1].push(line[2].trim());
                }
                else if (parseInt(line[0]) == 1 && line[1].indexOf('HUSB') > -1) {
                    familiyHusband[familiyChildren.length - 1] = line[2].trim();
                }
                else if (parseInt(line[0]) == 1 && line[1].indexOf('WIFE') > -1) {
                    familiyWife[familiyChildren.length - 1] = line[2].trim();
                }
            }
            for (var fi = 0; fi < personIds.length; fi++) {
                nodeTable.push([fi, personIds[fi], personSex[fi]]);
            }
            var hi, wi, ci;
            for (var fi = 0; fi < familiyIds.length; fi++) {
                hi = personIds.indexOf(familiyHusband[fi]);
                wi = personIds.indexOf(familiyWife[fi]);
                console.log('-->', hi, wi, familiyHusband[fi], familiyWife[fi]);
                for (var i = 0; i < familiyChildren[fi].length; i++) {
                    ci = personIds.indexOf(familiyChildren[fi][i]);
                    if (ci == undefined || ci == -1)
                        continue;
                    if (hi != undefined && hi > -1)
                        linkTable.push([linkTable.length, hi, ci]);
                    if (wi != undefined && wi > -1)
                        linkTable.push([linkTable.length, wi, ci]);
                }
            }
            callBack(new DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    function loadLinkList(url, callBack) {
        var url = url;
        var callBack = callBack;
        $.get(url, (data) => {
            var lines = data.split('\n');
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2, weight: 3 };
            var line;
            var s, t;
            for (var i = 0; i < lines.length; i++) {
                line = lines[i];
                if (line.indexOf('#') == -1) {
                    break;
                }
            }
            var DEL = ' ';
            if (lines[i].indexOf(',') > -1)
                DEL = ',';
            else if (lines[i].indexOf('\t') > -1)
                DEL = '\t';
            var nodeLabels = [];
            var weight;
            for (i; i < lines.length; i++) {
                line = lines[i];
                line = line.split(DEL);
                for (var j = 0; j < line.length; j) {
                    if (line[j].length == 0) {
                        line.splice(j, 1);
                    }
                    else {
                        j++;
                    }
                }
                if (line.length < 2)
                    continue;
                s = line[0].toLowerCase();
                if (s == undefined || s == '')
                    continue;
                var si = nodeLabels.indexOf(s);
                if (si == -1) {
                    si = nodeLabels.length;
                    nodeLabels.push(s);
                }
                t = line[1].toLowerCase();
                if (t == undefined)
                    continue;
                t = t.trim();
                var ti = nodeLabels.indexOf(t);
                if (ti == -1) {
                    ti = nodeLabels.length;
                    nodeLabels.push(t);
                }
                weight = 1;
                linkTable.push([linkTable.length, si, ti, weight]);
            }
            for (i = 0; i <= nodeLabels.length; i++) {
                nodeTable.push([i, nodeLabels[i] + '']);
            }
            callBack(new DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    function loadMatrix(url, callBack) {
        var url = url;
        var callBack = callBack;
        $.get(url, (data) => {
            var lines = data.split('\n');
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2 };
            var line;
            var nodeNames = [];
            var label;
            // get nodes from rows
            var line = lines[0].trim().split(',');
            for (var i = 0; i < line.length; i++) {
                label = line[i].trim();
                nodeTable.push([nodeTable.length, label]);
                nodeNames.push(label);
            }
            var t;
            for (var i = 1; i < lines.length; i++) {
                line = lines[i];
                line = line.trim();
                line = line.split(',');
                t = nodeNames.indexOf(line[0].trim());
                if (t == -1) {
                    console.error('Node', line[0], 'not defined');
                    continue;
                }
                for (var j = 1; j < line.length; j++) {
                    if (line[j].length > 0 && parseInt(line[j].replace(/\s/g, '')) > 300000) {
                        linkTable.push([linkTable.length, t, j - 1]);
                    }
                }
            }
            console.log('---->nodes found:', nodeTable.length);
            console.log('---->links found:', linkTable.length);
            callBack(new DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    /// EXPORTERS
    /** Returns a csv table representation of this graph. It should be the same as
     * the input table format (fix!)
     * Currently: returns simple list of node index pairs.
     */
    function exportCSV(graph) {
        var csv = '';
        var DEL = ',';
        var ST = '';
        var BR = '\n';
        for (var i = 0; i < graph.links().length; i++) {
            var graph_link = graph.link(i);
            if (graph_link != undefined) {
                csv += ST + graph_link.source.id() + ST + DEL
                    + ST + graph_link.target.id() + ST + BR;
            }
        }
        return csv;
    }
    /// HELPER FUNCTIONS
    /** Downloads a string as file.*/
    function downloadText(text, filename) {
        var textFileAsBlob = new Blob([text], { type: 'text/text' });
        var fileNameToSaveAs = filename;
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        downloadLink.click();
    }

    var importers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        loadDyson: loadDyson,
        loadLinkTable: loadLinkTable,
        loadXML: loadXML,
        loadJson: loadJson,
        loadJsonList: loadJsonList,
        loadNCube: loadNCube,
        loadPajek: loadPajek,
        loadMat: loadMat,
        loadGEDCOM: loadGEDCOM,
        loadLinkList: loadLinkList,
        loadMatrix: loadMatrix,
        exportCSV: exportCSV,
        downloadText: downloadText
    });

    function searchForTerm(term, dgraph, type) {
        var terms = term.toLowerCase().split(',');
        var result = new IDCompound();
        for (var i = 0; i < terms.length; i++) {
            term = terms[i].trim();
            if (!type || type == 'node')
                result.nodeIds = result.nodeIds.concat(dgraph.nodes().filter((e) => e.label().toLowerCase().indexOf(term) > -1
                    || e.nodeType().toLowerCase().indexOf(term) > -1).ids());
            if (!type || type == 'link')
                result.linkIds = result.linkIds.concat(dgraph.links().filter((e) => e.source.label().toLowerCase().indexOf(term) > -1
                    || e.target.label().toLowerCase().indexOf(term) > -1
                    || e.linkType().indexOf(term) > -1).ids());
            if (!type || type == 'locations')
                result.locationIds = result.locationIds.concat(dgraph.locations().filter((e) => e.label().toLowerCase().indexOf(term) > -1).ids());
        }
        return result;
    }

    var search = /*#__PURE__*/Object.freeze({
        __proto__: null,
        searchForTerm: searchForTerm
    });

    var MESSAGE_HIGHLIGHT = 'highlight';
    var MESSAGE_SELECTION = 'selection';
    var MESSAGE_TIME_RANGE = 'timeRange';
    var MESSAGE_SELECTION_CREATE = 'createSelection';
    var MESSAGE_SELECTION_DELETE = 'deleteSelection';
    var MESSAGE_SELECTION_SET_CURRENT = 'setCurrentSelectionId';
    var MESSAGE_SELECTION_COLORING = 'setSelectionColor';
    var MESSAGE_SELECTION_SET_COLORING_VISIBILITY = 'selectionColoring';
    var MESSAGE_SELECTION_FILTER = 'selectionFilter';
    var MESSAGE_SELECTION_PRIORITY = 'selectionPriority';
    var MESSAGE_SEARCH_RESULT = 'searchResult';
    var MESSAGE_SET_STATE = 'SET_STATE';
    var MESSAGE_GET_STATE = 'GET_STATE';
    var MESSAGE_STATE_CREATED = 'STATE_CREATED';
    var MESSAGE_HANDLERS = [
        MESSAGE_HIGHLIGHT,
        MESSAGE_SELECTION,
        MESSAGE_TIME_RANGE,
        MESSAGE_SELECTION_CREATE,
        MESSAGE_SELECTION_DELETE,
        MESSAGE_SELECTION_SET_CURRENT,
        MESSAGE_SELECTION_SET_COLORING_VISIBILITY,
        MESSAGE_SELECTION_FILTER,
        MESSAGE_SELECTION_PRIORITY,
        MESSAGE_SEARCH_RESULT,
        MESSAGE_SELECTION_COLORING,
        MESSAGE_SET_STATE,
        MESSAGE_GET_STATE,
        MESSAGE_STATE_CREATED
    ];
    // contains handlers for passing messages to the
    // visualization.
    class MessageHandler {
        constructor() {
            /* DEFAULT VALUES ?? */
            this.highlightUpdate = () => { return; };
            this.selectionUpdate = () => { return; };
        }
    }
    var messageHandler = new MessageHandler();
    var previousMessageId = -1;
    // register an event handler
    function addEventListener(messageType, handler) {
        messageHandler[messageType] = handler;
    }
    function setDefaultEventListener(handler) {
        for (var i = 0; i < MESSAGE_HANDLERS.length; i++) {
            messageHandler[MESSAGE_HANDLERS[i]] = handler;
        }
    }
    // create internal listener to storage events
    window.addEventListener('storage', receiveMessage, false);
    class Message {
        constructor(type) {
            this.id = Math.random();
            this.type = type;
            this.body = null;
        }
    }
    /////////////////////////////
    /// NON-SPECIFIC MESSAGES ///
    /////////////////////////////
    function sendMessage(type, body) {
        var m = new Message(type);
        m.body = body;
        distributeMessage(m, true);
    }
    /////////////////////////
    /// SPECIFIC MESSAGES ///
    /////////////////////////
    function isEmpty(obj) {
        for (var key in obj) {
            if (obj.hasOwnProperty(key))
                return false;
        }
        return true;
    }
    // HIGHLIGHT
    function highlight(action, elementCompound) {
        var g = getDynamicGraph();
        var idCompound = makeIdCompound(elementCompound);
        if (elementCompound != null && !isEmpty(elementCompound)) ;
        if (!elementCompound == undefined)
            action = 'reset';
        // create message
        var m;
        m = new HighlightMessage(action, idCompound);
        distributeMessage(m);
        if (elementCompound && g.currentSelection_id > 0) {
            $('body').css('cursor', 'url(/networkcube/icons/brush.png),auto');
        }
        else {
            $('body').css('cursor', 'auto');
        }
    }
    class HighlightMessage extends Message {
        constructor(action, idCompound) {
            super(MESSAGE_HIGHLIGHT);
            this.action = action;
            this.idCompound = idCompound != undefined ? idCompound : new IDCompound(); // WHAT HAPPEND IF IT IS UNDEFINED??
        }
    }
    // SELECTION MESSAGES
    function selection(action, compound, selectionId) {
        var g = getDynamicGraph();
        if (!selectionId)
            selectionId = g.currentSelection_id;
        var selection = g.getSelection(selectionId);
        var idCompound = makeIdCompound(compound);
        var m = new SelectionMessage(action, idCompound, selectionId);
        distributeMessage(m);
    }
    class SelectionMessage extends Message {
        constructor(action, idCompound, selectionId) {
            super(MESSAGE_SELECTION);
            this.action = action;
            this.idCompound = idCompound;
            this.selectionId = selectionId != undefined ? selectionId : 0; // WHAT HAPPEND IF IT IS UNDEFINED?
        }
    }
    // TIME CHANGE MESSAGES
    function timeRange(startUnix, endUnix, single, propagate) {
        var m = new TimeRangeMessage(startUnix, endUnix);
        if (propagate == undefined)
            propagate = false;
        if (propagate)
            distributeMessage(m); // notifies all views, including this
        else
            processMessage(m);
    }
    class TimeRangeMessage extends Message {
        constructor(start, end) {
            super(MESSAGE_TIME_RANGE);
            this.startUnix = start;
            this.endUnix = end;
        }
    }
    /// CREATE NEW SELECTION
    function createSelection(type, name) {
        var g = getDynamicGraph();
        var b = g.createSelection(type);
        b.name = name;
        var m = new CreateSelectionMessage(b);
        distributeMessage(m, false);
        return b;
    }
    class CreateSelectionMessage extends Message {
        constructor(b) {
            super(MESSAGE_SELECTION_CREATE);
            this.selection = b;
        }
    }
    // SET CURRENT SELECTION
    function setCurrentSelection(b) {
        var g = getDynamicGraph();
        var m = new SetCurrentSelectionIdMessage(b);
        distributeMessage(m);
    }
    class SetCurrentSelectionIdMessage extends Message {
        constructor(b) {
            super(MESSAGE_SELECTION_SET_CURRENT);
            this.selectionId = b.id;
        }
    }
    // CHANGE SELECTION COLOR
    function showSelectionColor(selection, showColor) {
        var m = new ShowSelectionColorMessage(selection, showColor);
        distributeMessage(m);
    }
    class ShowSelectionColorMessage extends Message {
        constructor(selection, showColor) {
            super(MESSAGE_SELECTION_SET_COLORING_VISIBILITY);
            this.selectionId = selection.id;
            this.showColor = showColor;
        }
    }
    /// FILTER SELECTION
    function filterSelection(selection, filter) {
        var m = new FilterSelectionMessage(selection, filter);
        distributeMessage(m);
    }
    class FilterSelectionMessage extends Message {
        constructor(selection, filter) {
            super(MESSAGE_SELECTION_FILTER);
            this.selectionId = selection.id;
            this.filter = filter;
        }
    }
    /// SWAP PRIORITY
    function swapPriority(s1, s2) {
        var m = new SelectionPriorityMessage(s1, s2, s2.priority, s1.priority);
        distributeMessage(m);
    }
    class SelectionPriorityMessage extends Message {
        constructor(s1, s2, p1, p2) {
            super(MESSAGE_SELECTION_PRIORITY);
            this.selectionId1 = s1.id;
            this.selectionId2 = s2.id;
            this.priority1 = p1;
            this.priority2 = p2;
        }
    }
    /// DELETE SELECTION
    function deleteSelection(selection) {
        var m = new DeleteSelectionMessage(selection);
        distributeMessage(m);
    }
    class DeleteSelectionMessage extends Message {
        constructor(selection) {
            super(MESSAGE_SELECTION_DELETE);
            this.selectionId = selection.id;
        }
    }
    /// SET SELECTION COLOR
    function setSelectionColor(s, color) {
        distributeMessage(new SelectionColorMessage(s, color));
    }
    class SelectionColorMessage extends Message {
        constructor(selection, color) {
            super(MESSAGE_SELECTION_COLORING);
            this.selectionId = selection.id;
            this.color = color;
        }
    }
    /// SEARCH SELECTION
    function search$1(term, type) {
        var idCompound = searchForTerm(term, getDynamicGraph(), type);
        distributeMessage(new SearchResultMessage(term, idCompound));
    }
    class SearchResultMessage extends Message {
        constructor(searchTerm, idCompound) {
            super(MESSAGE_SEARCH_RESULT);
            this.idCompound = idCompound;
            this.searchTerm = searchTerm;
        }
    }
    class NetworkControls {
        constructor(networkType, startTime, endTime) {
            this.networkType = networkType;
            this.timeSliderStart = startTime;
            this.timeSliderEnd = endTime;
        }
    }
    class NodeLinkControls extends NetworkControls {
        constructor(networkType, startTime, endTime, globalZoom, panOffsetLocal, panOffsetGlobal, linkOpacity, nodeOpacity, nodeSize, edgeGap, linkWidth, labellingType) {
            super(networkType, startTime, endTime);
            this.globalZoom = globalZoom;
            this.panOffsetGlobal = panOffsetGlobal;
            this.panOffsetLocal = panOffsetLocal;
            this.linkOpacity = linkOpacity;
            this.nodeOpacity = nodeOpacity;
            this.nodeSize = nodeSize;
            this.edgeGap = edgeGap;
            this.linkWidth = linkWidth;
            this.labellingType = labellingType;
        }
    }
    class MatrixControls extends NetworkControls {
        constructor(networkType, startTime, endTime, zoom, labellingType) {
            super(networkType, startTime, endTime);
            this.zoom = zoom;
            this.labellingType = labellingType;
        }
    }
    class TimeArchsControls extends NetworkControls {
        /* webglState:any;
        camera_position_x:number;
        camera_position_y:number;
        camera_position_z:number; */
        constructor(networkType, startTime, endTime, labellingType) {
            //,webglState:any,camera_position_x:number,camera_position_y:number,camera_position_z:number){
            super(networkType, startTime, endTime);
            this.labellingType = labellingType;
            /*  this.webglState=webglState;
             this.camera_position_x=camera_position_x;
             this.camera_position_y=camera_position_z;
             this.camera_position_z=camera_position_z;
      */
        }
    }
    class MapControls extends NetworkControls {
        constructor(networkType, startTime, endTime, nodeOverlap, linkOpacity, opacityOfPositionlessNodes) {
            super(networkType, startTime, endTime);
            this.nodeOverlap = nodeOverlap;
            this.linkOpacity = linkOpacity;
            this.opacityOfPositionlessNodes = opacityOfPositionlessNodes;
        }
    }
    // SET STATE MESSAGE
    class SetStateMessage extends Message {
        constructor(state, viewType) {
            super(MESSAGE_SET_STATE);
            this.state = state;
            this.viewType = viewType;
        }
    }
    function setState(state, viewType) {
        // is called from anywhere in vistorian by calling 
        // window.vc.messenger.setState(myState);
        distributeMessage(new SetStateMessage(state, viewType), true);
    }
    // GET STATE MESSAGE
    class GetStateMessage extends Message {
        constructor(bookmarkIndex, viewType, isNewBookmark, typeOfMultiView) {
            super(MESSAGE_GET_STATE);
            this.bookmarkIndex = bookmarkIndex;
            this.viewType = viewType;
            this.isNewBookmark = isNewBookmark;
            this.typeOfMultiView = typeOfMultiView;
        }
    }
    function getState(bookmarkIndex, viewType, isNewBookmark, typeOfMultiView) {
        // is called from anywhere in vistorian by calling 
        // window.vc.messenger.getState(bookmarkIndex);
        distributeMessage(new GetStateMessage(bookmarkIndex, viewType, isNewBookmark, typeOfMultiView), true);
    }
    class StateCreatedMessage extends Message {
        constructor(state, bookmarkIndex, viewType, isNewBookmark, typeOfMultiView) {
            super(MESSAGE_STATE_CREATED);
            this.state = state;
            this.bookmarkIndex = bookmarkIndex;
            this.viewType = viewType;
            this.isNewBookmark = isNewBookmark;
            this.typeOfMultiView = typeOfMultiView;
        }
    }
    function stateCreated(state, bookmarkIndex, viewType, isNewBookmark, typeOfMultiView) {
        // State created : to set the state after getting it from the selected network
        distributeMessage(new StateCreatedMessage(state, bookmarkIndex, viewType, isNewBookmark, typeOfMultiView), true);
    }
    ////////////////////////
    // INTERNAL FUNCTIONS //
    ////////////////////////
    var MESSAGE_KEY = 'networkcube_message';
    localStorage[MESSAGE_KEY] = undefined;
    function distributeMessage(message, ownView) {
        //VS: Link Function Use
        // trace.event(null, 'LinkFunctionUse', message.type, );
        if (ownView == undefined || ownView)
            processMessage(message);
        // other views
        {
            localStorage[MESSAGE_KEY] = JSON.stringify(message, function (k, v) { return dgraphReplacer(k, v); });
        }
    }
    function receiveMessage() {
        // read message from local storage
        var s = localStorage[MESSAGE_KEY];
        if (s == undefined || s == 'undefined')
            return;
        var dgraph = getDynamicGraph();
        var m = JSON.parse(s, function (k, v) { return dgraphReviver(dgraph, k, v); });
        if (!m || m.id == previousMessageId) {
            return;
        }
        previousMessageId = m.id;
        processMessage(m);
    }
    function processMessage(m) {
        var graph = getDynamicGraph();
        if (messageHandler[m.type]) {
            // for messages with handlers
            if (m.type == MESSAGE_HIGHLIGHT) {
                var m2 = m;
                graph.highlight(m2.action, m2.idCompound);
            }
            else if (m.type == MESSAGE_SELECTION) {
                var m3 = m;
                graph.selection(m3.action, m3.idCompound, m3.selectionId);
            }
            else if (m.type == MESSAGE_TIME_RANGE) ;
            else if (m.type == MESSAGE_SELECTION_SET_COLORING_VISIBILITY) {
                var m4 = m;
                var m4Selection = graph.getSelection(m4.selectionId);
                if (m4Selection != undefined) {
                    m4Selection.showColor = m4.showColor;
                }
            }
            else if (m.type == MESSAGE_SELECTION_PRIORITY) {
                var m5 = m;
                var m5SelectionId1 = graph.getSelection(m5.selectionId1);
                var m5SelectionId2 = graph.getSelection(m5.selectionId2);
                if (m5SelectionId1 != undefined) {
                    m5SelectionId1.priority = m5.priority1;
                } // ELSE?
                if (m5SelectionId2 != undefined) {
                    m5SelectionId2.priority = m5.priority2;
                } // ELSE?
                var linkElements = graph.links().selected().toArray();
                for (var i = 0; i < linkElements.length; i++) {
                    linkElements[i].getSelections().sort(sortByPriority);
                }
                var nodeElements = graph.nodes().selected().toArray();
                for (var i = 0; i < nodeElements.length; i++) {
                    nodeElements[i].getSelections().sort(sortByPriority);
                }
                var nodePairElements = graph.nodePairs().selected().toArray();
                for (var i = 0; i < nodePairElements.length; i++) {
                    nodePairElements[i].getSelections().sort(sortByPriority);
                }
            }
            else if (m.type == MESSAGE_SELECTION_FILTER) {
                var m6 = m;
                graph.filterSelection(m6.selectionId, m6.filter);
            }
            else 
            // test messages that don't require a message handler
            if (m.type == MESSAGE_SELECTION_CREATE) {
                var m7 = m;
                graph.addSelection(m7.selection.id, m7.selection.color, m7.selection.acceptedType, m7.selection.priority);
            }
            else if (m.type == MESSAGE_SELECTION_SET_CURRENT) {
                var m8 = m;
                graph.setCurrentSelection(m8.selectionId);
            }
            else if (m.type == MESSAGE_SELECTION_DELETE) {
                var m10 = m;
                graph.deleteSelection(m10.selectionId);
            }
            else if (m.type == MESSAGE_SEARCH_RESULT) {
                var m11 = m;
                graph.highlight('set', m11.idCompound);
            }
            else if (m.type == MESSAGE_SELECTION_COLORING) {
                var m12 = m;
                var m12Selection = graph.getSelection(m12.selectionId);
                if (m12Selection != undefined) {
                    m12Selection.color = m12.color;
                } // ELSE ??
            }
            else if (m.type == MESSAGE_GET_STATE || m.type == MESSAGE_SET_STATE || m.type == MESSAGE_STATE_CREATED) ;
            callHandler(m);
        }
    }
    // calls the handler for the passed message
    function callHandler(message) {
        if (messageHandler[message.type] && messageHandler[message.type] != undefined) {
            messageHandler[message.type](message);
        }
    }

    var messenger = /*#__PURE__*/Object.freeze({
        __proto__: null,
        MESSAGE_HIGHLIGHT: MESSAGE_HIGHLIGHT,
        MESSAGE_SELECTION: MESSAGE_SELECTION,
        MESSAGE_TIME_RANGE: MESSAGE_TIME_RANGE,
        MESSAGE_SELECTION_CREATE: MESSAGE_SELECTION_CREATE,
        MESSAGE_SELECTION_DELETE: MESSAGE_SELECTION_DELETE,
        MESSAGE_SELECTION_SET_CURRENT: MESSAGE_SELECTION_SET_CURRENT,
        MESSAGE_SELECTION_COLORING: MESSAGE_SELECTION_COLORING,
        MESSAGE_SELECTION_SET_COLORING_VISIBILITY: MESSAGE_SELECTION_SET_COLORING_VISIBILITY,
        MESSAGE_SELECTION_FILTER: MESSAGE_SELECTION_FILTER,
        MESSAGE_SELECTION_PRIORITY: MESSAGE_SELECTION_PRIORITY,
        MESSAGE_SEARCH_RESULT: MESSAGE_SEARCH_RESULT,
        MESSAGE_SET_STATE: MESSAGE_SET_STATE,
        MESSAGE_GET_STATE: MESSAGE_GET_STATE,
        MESSAGE_STATE_CREATED: MESSAGE_STATE_CREATED,
        addEventListener: addEventListener,
        setDefaultEventListener: setDefaultEventListener,
        Message: Message,
        sendMessage: sendMessage,
        highlight: highlight,
        HighlightMessage: HighlightMessage,
        selection: selection,
        SelectionMessage: SelectionMessage,
        timeRange: timeRange,
        TimeRangeMessage: TimeRangeMessage,
        createSelection: createSelection,
        CreateSelectionMessage: CreateSelectionMessage,
        setCurrentSelection: setCurrentSelection,
        SetCurrentSelectionIdMessage: SetCurrentSelectionIdMessage,
        showSelectionColor: showSelectionColor,
        ShowSelectionColorMessage: ShowSelectionColorMessage,
        filterSelection: filterSelection,
        FilterSelectionMessage: FilterSelectionMessage,
        swapPriority: swapPriority,
        SelectionPriorityMessage: SelectionPriorityMessage,
        deleteSelection: deleteSelection,
        DeleteSelectionMessage: DeleteSelectionMessage,
        setSelectionColor: setSelectionColor,
        search: search$1,
        SearchResultMessage: SearchResultMessage,
        NetworkControls: NetworkControls,
        NodeLinkControls: NodeLinkControls,
        MatrixControls: MatrixControls,
        TimeArchsControls: TimeArchsControls,
        MapControls: MapControls,
        SetStateMessage: SetStateMessage,
        setState: setState,
        GetStateMessage: GetStateMessage,
        getState: getState,
        StateCreatedMessage: StateCreatedMessage,
        stateCreated: stateCreated,
        distributeMessage: distributeMessage
    });

    function findDegree(nodes) {
        const motifs = [];
        for (const n of nodes) {
            const ns = n.neighbors().removeDuplicates().toArray().concat(n);
            const ls = n.links().removeDuplicates().toArray();
            motifs.push(new Motif(ns, ls));
        }
        return motifs;
    }

    var analytics = /*#__PURE__*/Object.freeze({
        __proto__: null,
        findDegree: findDegree
    });

    // namespace colorSchemes{
    // create more color pallets on
    // http://www.palettefx.com/
    const schema1 = [
        "#775566",
        "#6688bb",
        "#556677",
        "#88aa88",
        "#88bb33",
        "#cc7744",
        "#003366",
        "#994422",
        "#331111",
    ];
    const schema2 = [
        "#44B3C2",
        "#F1A94E",
        "#E45641",
        "#5D4C46",
        "#7B8D8E",
        "#2ca02c",
        "#003366",
        "#9467bd",
        "#bcbd22",
        "#e377c2",
    ];
    const schema3 = [
        "#001166",
        "#0055aa",
        "#1199cc",
        "#99ccdd",
        "#002222",
        "#ddffff",
        "#446655",
        "#779988",
        "#115522",
    ];
    const schema4 = [
        "#1f77b4",
        "#ff7f0e",
        "#2ca02c",
        "#d62728",
        "#9467bd",
        "#8c564b",
        "#e377c2",
        "#7f7f7f",
        "#bcbd22",
        "#17becf",
    ];
    const schema5 = [
        "#1f77b4",
        "#aec7e8",
        "#ff7f0e",
        "#ffbb78",
        "#2ca02c",
        "#98df8a",
        "#d62728",
        "#ff9896",
        "#9467bd",
        "#c5b0d5",
        "#8c564b",
        "#c49c94",
        "#e377c2",
        "#f7b6d2",
        "#7f7f7f",
        "#c7c7c7",
        "#bcbd22",
        "#dbdb8d",
        "#17becf",
        "#9edae5",
    ];
    // colorbrewer categorical 12
    const schema6 = [
        "#a6cee3",
        "#1f78b4",
        "#b2df8a",
        "#33a02c",
        "#fb9a99",
        "#e31a1c",
        "#fdbf6f",
        "#ff7f00",
        "#cab2d6",
        "#6a3d9a",
        "#ffff99",
        "#b15928",
    ];
    // }

    var colors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        schema1: schema1,
        schema2: schema2,
        schema3: schema3,
        schema4: schema4,
        schema5: schema5,
        schema6: schema6
    });

    class BSpline {
        constructor(points, degree, copy) {
            this.points = [];
            this.baseFuncRangeInt = 0; // INIT??
            if (copy) {
                this.points = [];
                for (var i = 0; i < points.length; i++) {
                    this.points.push(points[i]);
                }
            }
            else {
                this.points = points;
            }
            this.degree = degree;
            this.dimension = points[0].length;
            if (degree == 2) {
                this.baseFunc = this.basisDeg2;
                this.baseFuncRangeInt = 2;
            }
            else if (degree == 3) {
                this.baseFunc = this.basisDeg3;
                this.baseFuncRangeInt = 2;
            }
            else if (degree == 4) {
                this.baseFunc = this.basisDeg4;
                this.baseFuncRangeInt = 3;
            }
            else if (degree == 5) {
                this.baseFunc = this.basisDeg5;
                this.baseFuncRangeInt = 3;
            }
        }
        //BSpline.prototype.seqAt = function(dim: any): any{
        seqAt(dim) {
            var points = this.points;
            var margin = this.degree + 1;
            return function (n) {
                if (n < margin) {
                    return points[0][dim];
                }
                else if (points.length + margin <= n) {
                    return points[points.length - 1][dim];
                }
                else {
                    return points[n - margin][dim];
                }
            };
        }
        ;
        //BSpline.prototype.basisDeg2 = function(x: any): number{
        basisDeg2(x) {
            if (-0.5 <= x && x < 0.5) {
                return 0.75 - x * x;
            }
            else if (0.5 <= x && x <= 1.5) {
                return 1.125 + (-1.5 + x / 2.0) * x;
            }
            else if (-1.5 <= x && x < -0.5) {
                return 1.125 + (1.5 + x / 2.0) * x;
            }
            else {
                return 0;
            }
        }
        ;
        //BSpline.prototype.basisDeg3 = function(x: any): number{
        basisDeg3(x) {
            if (-1 <= x && x < 0) {
                return 2.0 / 3.0 + (-1.0 - x / 2.0) * x * x;
            }
            else if (1 <= x && x <= 2) {
                return 4.0 / 3.0 + x * (-2.0 + (1.0 - x / 6.0) * x);
            }
            else if (-2 <= x && x < -1) {
                return 4.0 / 3.0 + x * (2.0 + (1.0 + x / 6.0) * x);
            }
            else if (0 <= x && x < 1) {
                return 2.0 / 3.0 + (-1.0 + x / 2.0) * x * x;
            }
            else {
                return 0;
            }
        }
        ;
        //BSpline.prototype.basisDeg4 = function(x: any): number{
        basisDeg4(x) {
            if (-1.5 <= x && x < -0.5) {
                return 55.0 / 96.0 + x * (-(5.0 / 24.0) + x * (-(5.0 / 4.0) + (-(5.0 / 6.0) - x / 6.0) * x));
            }
            else if (0.5 <= x && x < 1.5) {
                return 55.0 / 96.0 + x * (5.0 / 24.0 + x * (-(5.0 / 4.0) + (5.0 / 6.0 - x / 6.0) * x));
            }
            else if (1.5 <= x && x <= 2.5) {
                return 625.0 / 384.0 + x * (-(125.0 / 48.0) + x * (25.0 / 16.0 + (-(5.0 / 12.0) + x / 24.0) * x));
            }
            else if (-2.5 <= x && x <= -1.5) {
                return 625.0 / 384.0 + x * (125.0 / 48.0 + x * (25.0 / 16.0 + (5.0 / 12.0 + x / 24.0) * x));
            }
            else if (-1.5 <= x && x < 1.5) {
                return 115.0 / 192.0 + x * x * (-(5.0 / 8.0) + x * x / 4.0);
            }
            else {
                return 0;
            }
        }
        ;
        //BSpline.prototype.basisDeg5 = function(x: any): number{
        basisDeg5(x) {
            if (-2 <= x && x < -1) {
                return 17.0 / 40.0 + x * (-(5.0 / 8.0) + x * (-(7.0 / 4.0) + x * (-(5.0 / 4.0) + (-(3.0 / 8.0) - x / 24.0) * x)));
            }
            else if (0 <= x && x < 1) {
                return 11.0 / 20.0 + x * x * (-(1.0 / 2.0) + (1.0 / 4.0 - x / 12.0) * x * x);
            }
            else if (2 <= x && x <= 3) {
                return 81.0 / 40.0 + x * (-(27.0 / 8.0) + x * (9.0 / 4.0 + x * (-(3.0 / 4.0) + (1.0 / 8.0 - x / 120.0) * x)));
            }
            else if (-3 <= x && x < -2) {
                return 81.0 / 40.0 + x * (27.0 / 8.0 + x * (9.0 / 4.0 + x * (3.0 / 4.0 + (1.0 / 8.0 + x / 120.0) * x)));
            }
            else if (1 <= x && x < 2) {
                return 17.0 / 40.0 + x * (5.0 / 8.0 + x * (-(7.0 / 4.0) + x * (5.0 / 4.0 + (-(3.0 / 8.0) + x / 24.0) * x)));
            }
            else if (-1 <= x && x < 0) {
                return 11.0 / 20.0 + x * x * (-(1.0 / 2.0) + (1.0 / 4.0 + x / 12.0) * x * x);
            }
            else {
                return 0;
            }
        }
        ;
        //BSpline.prototype.getInterpol = function(seq: any, t: any): number{
        getInterpol(seq, t) {
            var f = this.baseFunc;
            var rangeInt = this.baseFuncRangeInt;
            var tInt = Math.floor(t);
            var result = 0;
            for (var i = tInt - rangeInt; i <= tInt + rangeInt; i++) {
                result += seq(i) * f(t - i);
            }
            return result;
        }
        ;
        //BSpline.prototype.calcAt = function(t: any): any{
        calcAt(t) {
            t = t * ((this.degree + 1) * 2 + this.points.length); //t must be in [0,1]
            if (this.dimension == 2) {
                return [this.getInterpol(this.seqAt(0), t), this.getInterpol(this.seqAt(1), t)];
            }
            else if (this.dimension == 3) {
                return [this.getInterpol(this.seqAt(0), t), this.getInterpol(this.seqAt(1), t), this.getInterpol(this.seqAt(2), t)];
            }
            else {
                var res = [];
                for (var i = 0; i < this.dimension; i++) {
                    res.push(this.getInterpol(this.seqAt(i), t));
                }
                return res;
            }
        }
        ;
    }
    /*
    var BSpline = function(points: any, degree: any, copy: any){
        if(copy){
            this.points = []
            for(var i = 0;i<points.length;i++){
                this.points.push(points[i]);
            }
        }else{
            this.points = points;
        }
        this.degree = degree;
        this.dimension = points[0].length;
        if(degree == 2){
            this.baseFunc = this.basisDeg2;
            this.baseFuncRangeInt = 2;
        }else if(degree == 3){
            this.baseFunc = this.basisDeg3;
            this.baseFuncRangeInt = 2;
        }else if(degree == 4){
            this.baseFunc = this.basisDeg4;
            this.baseFuncRangeInt = 3;
        }else if(degree == 5){
            this.baseFunc = this.basisDeg5;
            this.baseFuncRangeInt = 3;
        }
    };
    */

    var BSpline$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BSpline: BSpline
    });

    //module glutils {
    function makeAlphaBuffer(array, stretch) {
        var buffer = new Float32Array(array.length * stretch); // three components per vertex
        for (var i = 0; i < array.length; i++) {
            for (var j = 0; j < stretch; j++) {
                buffer[i * stretch + j] = array[i];
            }
        }
        return buffer;
    }
    function addBufferedHatchedRect(vertexArray, x, y, z, width, height, colorArray, c) {
        var HATCH_NUM = 3;
        var LINE_WIDTH = 1;
        var hatchWidth = width / HATCH_NUM;
        width = width / 2;
        height = height / 2;
        var startX = x + width;
        var startY = y - height;
        for (var i = 1; i <= HATCH_NUM; i++) {
            vertexArray.push([startX - hatchWidth * i, startY, z], [startX - hatchWidth * i + LINE_WIDTH, startY, z], [startX, startY + hatchWidth * i + LINE_WIDTH, z], [startX, startY + hatchWidth * i + LINE_WIDTH, z], [startX, startY + hatchWidth * i, z], [startX - hatchWidth * i, startY, z]);
            colorArray.push([c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]]);
        }
    }
    function addBufferedRect(vertexArray, x, y, z, width, height, colorArray, c) {
        width = width / 2;
        height = height / 2;
        vertexArray.push([x - width, y - height, z], [x + width, y - height, z], [x + width, y + height, z], [x + width, y + height, z], [x - width, y + height, z], [x - width, y - height, z]);
        colorArray.push([c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]]);
    }
    function addBufferedCirlce(vertexArray, x, y, z, radius, colorArray, c) {
        var segments = 11;
        var angle = Math.PI / (segments / 2);
        for (var i = 0; i < segments; i++) {
            vertexArray.push([x + Math.cos(i * angle) * radius, y + Math.sin(i * angle) * radius, z], [x + Math.cos((i + 1) * angle) * radius, y + Math.sin((i + 1) * angle) * radius, z], [x, y, z]);
            colorArray.push([c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]]);
        }
    }
    function addBufferedDiamond(vertexArray, x, y, z, width, height, colorArray, c) {
        width = width / 2;
        height = height / 2;
        vertexArray.push([x - width, y, z], [x, y - height, z], [x + width, y, z], [x + width, y, z], [x, y + height, z], [x - width, y, z]);
        colorArray.push([c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]]);
    }
    function createRectFrame(w, h, color, lineThickness) {
        w = w / 2;
        h = h / 2;
        var geom = new THREE.Geometry();
        geom.vertices = [
            new THREE.Vector3(-w, -h, 0),
            new THREE.Vector3(-w, h, 0),
            new THREE.Vector3(w, h, 0),
            new THREE.Vector3(w, -h, 0),
            new THREE.Vector3(-w, -h, 0)
        ];
        var material = new THREE.LineBasicMaterial({
            color: color,
        });
        return new THREE.Line(geom, material);
    }
    function createDiagonalCross(w, h, color, lineThickness) {
        w = w / 2;
        h = h / 2;
        var geom = new THREE.Geometry();
        geom.vertices = [
            new THREE.Vector3(-w, -h, 0),
            new THREE.Vector3(-w, h, 0),
            new THREE.Vector3(w, h, 0),
            new THREE.Vector3(w, -h, 0),
            new THREE.Vector3(-w, -h, 0),
            new THREE.Vector3(w, h, 0),
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(-w, h, 0),
            new THREE.Vector3(w, -h, 0)
        ];
        var material = new THREE.LineBasicMaterial({
            color: color,
            linewidth: lineThickness,
        });
        return new THREE.Line(geom, material);
    }
    function makeBuffer3f(array) {
        var buffer = new Float32Array(array.length * 3); // three components per vertex
        for (var i = 0; i < array.length; i++) {
            buffer[i * 3 + 0] = array[i][0];
            buffer[i * 3 + 1] = array[i][1];
            buffer[i * 3 + 2] = array[i][2];
        }
        return buffer;
    }
    function makeBuffer4f(array) {
        var buffer = new Float32Array(array.length * 4); // three components per vertex
        for (var i = 0; i < array.length; i++) {
            buffer[i * 4 + 0] = array[i][0];
            buffer[i * 4 + 1] = array[i][1];
            buffer[i * 4 + 2] = array[i][2];
            buffer[i * 4 + 3] = array[i][3];
        }
        return buffer;
    }
    function updateBuffer(buffer, array, size) {
        for (var i = 0; i < array.length; i++) {
            for (var j = 0; j < size; j++) {
                buffer[i * size + j] = array[i][j];
            }
        }
    }
    function createText(string, x, y, z, size, color, weight = 'normal', align = 'left') {
        var textGeom = new THREE.TextGeometry(string, {
            // font: 'helvetiker', // IT'S NOT CORRECT FORMAT
            size: size,
            height: 1,
            curveSegments: 1,
        });
        var textMaterial = new THREE.MeshBasicMaterial({ color: color });
        var label = new THREE.Mesh(textGeom, textMaterial);
        if (align == 'right') {
            label.geometry.computeBoundingBox();
            var bounds = label.geometry.boundingBox;
            x -= bounds.max.x - bounds.min.x;
        }
        label.position.set(x, y, z);
        return label;
    }
    function getMousePos(canvas, x, y) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: x - rect.left,
            y: y - rect.top
        };
    }
    /////////////////////////////
    /// QUERY LAYER FOR WEBGL ///
    /////////////////////////////    
    // SETUP
    var txtCanvas = document.createElement("canvas");
    class WebGL {
        constructor(params) {
            /* INIT ?????? */
            this.scene = new THREE.Scene();
            this.camera = new THREE.OrthographicCamera(0, 0, 0, 0);
            this.renderer = new THREE.WebGLRenderer();
            this.geometry = new THREE.BufferGeometry();
            this.elementQueries = [];
            txtCanvas = document.createElement("canvas");
            txtCanvas.setAttribute('id', 'textCanvas');
        }
        render() {
            // var d = new Date();
            // var begin = d.getTime()
            // check which webgl groups must be updated
            for (var i = 0; i < this.elementQueries.length; i++) {
                if (this.elementQueries[i].updateAttributes || this.elementQueries[i].updateStyle) {
                    this.elementQueries[i].set();
                }
            }
            this.renderer.render(this.scene, this.camera);
        }
        selectAll() {
            return selectAll();
        }
        ///////////////////////
        // RENDER PARAMETERS //
        ///////////////////////
        enableZoom(b) {
            function mouseWheel(event) {
                event.preventDefault();
                webgl.camera.zoom += event.wheelDelta / 1000;
                webgl.camera.zoom = Math.max(0.1, webgl.camera.zoom);
                webgl.camera.updateProjectionMatrix();
                webgl.render();
            }
            if (b) {
                window.addEventListener("mousewheel", mouseWheel, false);
            }
            else {
                window.addEventListener("mousewheel", mouseWheel, false);
            }
        }
        enablePanning(b) {
            this.interactor.isPanEnabled = b;
        }
        enableHorizontalPanning(b) {
            this.interactor.isHorizontalPanEnabled = b;
        }
    }
    var webgl;
    function initWebGL(parentId, width, height, params) {
        webgl = new WebGL(params);
        webgl.camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 0, 1000);
        webgl.scene = new THREE.Scene();
        webgl.scene.add(webgl.camera);
        webgl.camera.position.z = 100;
        // renderer
        webgl.renderer = new THREE.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: true
        });
        webgl.renderer.setSize(width, height);
        webgl.renderer.setClearColor(0xffffff, 1);
        // position canvas element containing cells
        webgl.canvas = webgl.renderer.domElement;
        $$1("#" + parentId).append(webgl.canvas);
        webgl.interactor = new WebGLInteractor(webgl.scene, webgl.canvas, webgl.camera);
        var light = new THREE.PointLight(0x000000, 1, 100);
        light.position.set(0, 0, 1000);
        webgl.scene.add(light);
        return webgl;
    }
    // camera BEFORE THREE.Camera, renderer BEFORE THREE.Renderer
    function setWebGL(scene, camera, renderer, canvas) {
        webgl = new WebGL();
        webgl.camera = camera;
        webgl.scene = scene;
        webgl.renderer = renderer;
    }
    // INTERACTION
    /// SELECTIONS in the style of D3
    function selectAll() {
        var q = new WebGLElementQuery();
        webgl.elementQueries.push(q);
        return q;
    }
    class WebGLElementQuery {
        constructor() {
            this.dataElements = [];
            this.visualElements = [];
            this.mesh = new THREE.Mesh();
            this.children = [];
            this.scene = new THREE.Scene();
            // attribute arrays
            this.x = [];
            this.y = [];
            this.z = [];
            this.r = [];
            // style arrays
            this.fill = []; // BEFORE number
            this.stroke = []; // BEFORE number
            this.strokewidth = [];
            this.opacity = [];
            this.shape = ''; // INIT ??
            this.updateAttributes = false;
            this.updateStyle = false;
            this.IS_SHADER = false;
            this.scene = webgl.scene;
        }
        data(arr) {
            this.dataElements = arr.slice(0);
            return this;
        }
        append(shape) {
            var elements = [];
            switch (shape) {
                // case 'circle': elements = createCirclesNoShader(this.dataElements, this.scene); break
                case 'circle':
                    createCirclesWithBuffers(this, this.scene);
                    break;
                // case 'circle': elements = createCircles(this.dataElements, this.scene); break
                // case 'g': elements = createG(this.dataElements, this.scene); break
                case 'path':
                    elements = createPaths(this.dataElements, this.scene);
                    break;
                case 'line':
                    elements = createLines(this.dataElements, this.scene);
                    break;
                case 'rect':
                    elements = createRectangles(this.dataElements, this.scene);
                    break;
                case 'text':
                    elements = createWebGLText(this.dataElements, this.scene);
                    break;
                case 'polygon':
                    elements = createPolygons(this.dataElements, this.scene);
                    break;
                default: console.error('Shape', shape, 'does not exist.');
            }
            // init position arrays
            if (!this.IS_SHADER) {
                for (var i = 0; i < elements.length; i++) {
                    this.x.push(0);
                    this.y.push(0);
                    this.z.push(0);
                }
            }
            this.shape = shape;
            this.visualElements = elements;
            return this;
        }
        push(e) {
            this.dataElements.push(e);
            return this;
        }
        getData(i) {
            return this.dataElements[this.visualElements.indexOf(i)];
        }
        getVisual(i) {
            return this.visualElements[this.dataElements.indexOf(i)];
        }
        get length() {
            return this.dataElements.length;
        }
        filter(f) {
            var arr = [];
            var visArr = [];
            for (var i = 0; i < this.dataElements.length; i++) {
                if (f(this.dataElements[i], i)) {
                    arr.push(this.dataElements[i]);
                    visArr.push(this.visualElements[i]);
                }
            }
            var q = new WebGLElementQuery().data(arr);
            q.visualElements = visArr;
            return q;
        }
        // geometric attributes
        attr(name, v) {
            var l = this.visualElements.length;
            if (this.IS_SHADER) {
                for (var i = 0; i < this.dataElements.length; i++) {
                    this[name][i] = v instanceof Function ? v(this.dataElements[i], i) : v;
                }
            }
            else {
                for (var i = 0; i < l; i++) {
                    this.setAttr(this.visualElements[i], name, v instanceof Function ? v(this.dataElements[i], i) : v, i);
                    if (this.visualElements[i].hasOwnProperty('wireframe')) {
                        this.setAttr(this.visualElements[i].wireframe, name, v instanceof Function ? v(this.dataElements[i], i) : v, i);
                    }
                }
            }
            this.updateAttributes = true;
            return this;
        }
        // style attributes
        style(name, v) {
            var l = this.visualElements.length;
            if (this.IS_SHADER) {
                name = name.replace('-', '');
                for (var i = 0; i < this.dataElements.length; i++) {
                    this[name][i] = v instanceof Function ? v(this.dataElements[i], i) : v;
                }
            }
            else {
                for (var i = 0; i < l; i++) {
                    setStyle(this.visualElements[i], name, v instanceof Function ? v(this.dataElements[i], i) : v, this);
                }
            }
            this.updateStyle = true;
            return this;
        }
        // called after all visual attributes have been set
        // method that passes updated values to the shaders 
        set() {
            if (!this.IS_SHADER)
                return this;
            var l = this.visualElements.length;
            var vertexPositionBuffer = [];
            var vertexColorBuffer = [];
            var c;
            if (this.shape == 'circle') {
                for (var i = 0; i < this.dataElements.length; i++) {
                    c = new THREE.Color(this.fill[i]);
                    addBufferedCirlce(vertexPositionBuffer, this.x[i], this.y[i], this.z[i], this.r[i], vertexColorBuffer, [c.r, c.g, c.b, this.opacity[i]]);
                }
            }
            var geometry = this.mesh.geometry;
            geometry.addAttribute('position', new THREE.BufferAttribute(makeBuffer3f(vertexPositionBuffer), 3));
            geometry.addAttribute('customColor', new THREE.BufferAttribute(makeBuffer4f(vertexColorBuffer), 4));
            geometry.needsUpdate = true;
            geometry.verticesNeedUpdate = true;
            this.mesh.material.needsUpdate = true;
            this.updateAttributes = false;
            this.updateStyle = false;
            return this;
        }
        text(v) {
            var l = this.visualElements.length;
            for (var i = 0; i < l; i++) {
                this.visualElements[i]['text'] = v instanceof Function ? v(this.dataElements[i], i) : v;
                if (this.visualElements[i]['text'] == undefined)
                    continue;
                setText(this.visualElements[i], this.visualElements[i]['text']);
            }
            return this;
        }
        // interaction
        on(event, f) {
            switch (event) {
                case 'mouseover':
                    this.mouseOverHandler = f;
                    break;
                case 'mousemove':
                    this.mouseMoveHandler = f;
                    break;
                case 'mouseout':
                    this.mouseOutHandler = f;
                    break;
                case 'mousedown':
                    this.mouseDownHandler = f;
                    break;
                case 'mouseup':
                    this.mouseUpHandler = f;
                    break;
                case 'click':
                    this.clickHandler = f;
                    break;
            }
            webgl.interactor.register(this, event);
            return this;
        }
        call(method, dataElement, event) {
            var i = this.dataElements.indexOf(dataElement);
            switch (method) {
                case 'mouseover':
                    this.mouseOverHandler(dataElement, i, event);
                    break;
                case 'mousemove':
                    this.mouseMoveHandler(dataElement, i, event);
                    break;
                case 'mouseout':
                    this.mouseOutHandler(dataElement, i, event);
                    break;
                case 'mousedown':
                    this.mouseDownHandler(dataElement, i, event);
                    break;
                case 'mouseup':
                    this.mouseUpHandler(dataElement, i, event);
                    break;
                case 'click':
                    this.clickHandler(dataElement, i, event);
                    break;
            }
            return this;
        }
        setAttr(element, attr, v, index) {
            switch (attr) {
                case 'x':
                    element.position.x = v;
                    this.x[index] = v;
                    break;
                case 'y':
                    element.position.y = v;
                    this.y[index] = v;
                    break;
                case 'z':
                    element.position.z = v;
                    this.z[index] = v;
                    break;
                case 'x1':
                    setX1(element, v);
                    break; // lines only
                case 'y1':
                    setY1(element, v);
                    break; // lines only
                case 'x2':
                    setX2(element, v);
                    break; // lines only
                case 'y2':
                    setY2(element, v);
                    break; // lines only
                case 'r':
                    element.scale.set(v, v, v);
                    break; // circles only
                case 'width':
                    element.scale.setX(v);
                    break;
                case 'height':
                    element.scale.setY(v);
                    break;
                case 'depth':
                    element.scale.setZ(v);
                    break;
                case 'd':
                    createPath(element, v);
                    break;
                case 'points':
                    createPolygon(element, v);
                    break;
                case 'rotation':
                    element.rotation.z = v * Math.PI / 180;
                    break;
                case 'scaleX':
                    element.scale.x = v;
                    break;
                case 'scaleY':
                    element.scale.y = v;
                    break;
                default: console.error('Attribute', attr, 'does not exist.');
            }
            element.geometry.verticesNeedUpdate = true;
            element.geometry.elementsNeedUpdate = true;
            element.geometry.lineDistancesNeedUpdate = true;
        }
        removeAll() {
            for (var i = 0; i < this.visualElements.length; i++) {
                if (this.visualElements[i].wireframe)
                    this.scene.remove(this.visualElements[i].wireframe);
                this.scene.remove(this.visualElements[i]);
            }
        }
    }
    ///////////////
    /// METHODS /// 
    ///////////////
    function setStyle(element, attr, v, query) {
        switch (attr) {
            case 'fill':
                if (query.shape == 'text')
                    setText(element, element['text'], { color: v });
                else
                    element.material.color = new THREE.Color(v);
                break;
            case 'stroke':
                if (element.hasOwnProperty('wireframe')) {
                    element.wireframe.material.color = new THREE.Color(v);
                }
                else {
                    element.material.color = new THREE.Color(v);
                }
                break;
            case 'opacity':
                element.material.opacity = v;
                if (element.hasOwnProperty('wireframe'))
                    element.wireframe.material.opacity = v;
                break;
            case 'stroke-width':
                if (element.hasOwnProperty('wireframe'))
                    element.wireframe.material.linewidth = v;
                else
                    element.material.linewidth = v;
                break;
            case 'font-size':
                element.scale.x = v / 30;
                element.scale.y = v / 30;
                element.geometry.verticesNeedUpdate = true;
                break;
            default: console.error('Style', attr, 'does not exist.');
        }
        element.material.needsUpdate = true;
        if (element.hasOwnProperty('wireframe'))
            element.wireframe.material.needsUpdate = true;
    }
    // var textCtx
    function setText(mesh, text, parConfig) {
        var config = parConfig;
        if (config == undefined) {
            config = {};
        }
        if (config.color == undefined)
            config.color = '#000000';
        mesh['text'] = text;
        var txtCanvas = document.createElement("canvas");
        var context = txtCanvas.getContext("2d");
        var SIZE = 30;
        var WIDTH = 0; // ????????
        if (context) {
            context.font = SIZE + "pt Helvetica";
            WIDTH = context.measureText(text).width;
            txtCanvas.width = WIDTH;
            txtCanvas.height = SIZE;
            context.textAlign = "left";
            context.textBaseline = "middle";
            context.fillStyle = config.color;
            context.font = SIZE + "pt Helvetica";
            // context.clearColor(1.0, 1.0, 0.0, 1.0)
            // context.clear(gl.COLOR_BUFFER_BIT)
            context.fillText(text, 0, txtCanvas.height / 2);
        }
        var tex = new THREE.Texture(txtCanvas);
        tex.minFilter = THREE.LinearFilter;
        tex.flipY = true;
        tex.needsUpdate = true;
        mesh.material.map = tex;
        mesh.material.transparent = true;
        mesh.material.needsUpdate = true;
        // adjust mesh geometry
        mesh.geometry = new THREE.PlaneGeometry(WIDTH, SIZE);
        mesh.geometry.needsUpdate = true;
        mesh.geometry.verticesNeedUpdate = true;
        mesh.needsUpdate = true;
    }
    // function setText(mesh:any, text:string, parConfig?:Object){
    //     var SIZE = 10
    //     var MARGIN = 2
    //     var config = parConfig;            
    //     if(config == undefined){
    //         config = {};
    //     }
    //     if(config.color == undefined)        
    //        config.color = '#000000'
    //     var canvas = document.createElement("canvas");
    //     var context = canvas.getContext("2d");
    //     context.font = SIZE + "pt Arial";
    //     var textWidth = context.measureText(text).width;
    //     canvas.width = textWidth + MARGIN;
    //     canvas.height = SIZE + MARGIN;
    //     context = canvas.getContext("2d");
    //     context.font = SIZE + "pt Arial";
    //     // if(backGroundColor) {
    //     //     context.fillStyle = backGroundColor;
    //     //     context.fillRect(canvas.width / 2 - textWidth / 2 - backgroundMargin / 2, canvas.height / 2 - size / 2 - +backgroundMargin / 2, textWidth + backgroundMargin, size + backgroundMargin);
    //     // }
    //     context.textAlign = "left";
    //     context.textBaseline = "middle";
    //     context.fillStyle = config.color;;
    //     context.fillText(text, canvas.width / 2, canvas.height / 2);
    //     // context.strokeStyle = "black";
    //     // context.strokeRect(0, 0, canvas.width, canvas.height);
    //     var texture = new THREE.Texture(canvas);
    //     texture.needsUpdate = true;
    //     var material = new THREE.MeshBasicMaterial({
    //         map : texture
    //     });
    //     // tex.minFilter = THREE.LinearFilter
    //     // tex.flipY = true;
    //     // tex.needsUpdate = true;
    //     mesh.material.map = texture;
    //     mesh.material.transparent = true;
    //     mesh.material.needsUpdate = true;
    //     // adjust mesh geometry
    //     mesh.geometry = new THREE.PlaneGeometry(WIDTH, SIZE);
    //     mesh.geometry.needsUpdate = true;
    //     mesh.geometry.verticesNeedUpdate = true;
    //     mesh.needsUpdate = true;
    //     return mesh;
    //     // var mesh = new THREE.Mesh(new THREE.PlaneGeometry(canvas.width, canvas.height), material);
    //     // // mesh.overdraw = true;
    //     // mesh.doubleSided = true;
    //     // mesh.position.x = x - canvas.width;
    //     // mesh.position.y = y - canvas.height;
    //     // mesh.position.z = z;
    //     // return mesh;
    // }
    function setX1(mesh, v) {
        mesh.geometry.vertices[0].x = v;
    }
    function setY1(mesh, v) {
        mesh.geometry.vertices[0].y = v;
    }
    function setX2(mesh, v) {
        mesh.geometry.vertices[1].x = v;
    }
    function setY2(mesh, v) {
        mesh.geometry.vertices[1].y = v;
    }
    /////////////////////
    /// CREATE SHAPES /// 
    /////////////////////
    // function fillCurve(color){
    //     var shape = new THREE.Shape(line.getSpacedPoints(100));
    //     var geometry = new THREE.ShapeGeometry( shape );
    //     var mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [ new THREE.MeshLambertMaterial( { color: 0xeeeeee } )] );
    //     for(var i=0 ; i < this.visualElements.length ; i++){
    //     }
    // }
    function createG(dataElements, scene) {
        var visualElements = [];
        // create group element for every data element
        for (var i = 0; i < dataElements.length; i++) {
            visualElements.push(new GroupElement());
        }
        return visualElements;
    }
    class GroupElement {
        constructor() {
            this.position = { x: 0, y: 0, z: 0 };
            this.children = [];
        }
    }
    function createCirclesNoShader(dataElements, scene) {
        var material;
        var geometry;
        var visualElements = [];
        var c;
        for (var i = 0; i < dataElements.length; i++) {
            material = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true });
            geometry = new THREE.CircleGeometry(1, 10);
            geometry.dynamic = true;
            c = new THREE.Mesh(geometry, material);
            visualElements.push(c);
            c.position.set(0, 0, 1);
            c.scale.set(10, 10, 1);
            scene.add(c);
        }
        return visualElements;
    }
    // SHADERS
    var vertexShaderProgram = "\
        attribute vec4 customColor;\
        varying vec4 vColor;\
        void main() {\
            vColor = customColor;\
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1 );\
        }";
    var fragmentShaderProgram = "\
        varying vec4 vColor;\
        void main() {\
            gl_FragColor = vec4(vColor[0], vColor[1], vColor[2], vColor[3]);\
        }";
    function createCirclesWithBuffers(query, scene) {
        var dataElements = query.dataElements;
        query.IS_SHADER = true;
        var shaderMaterial = new THREE.ShaderMaterial({
            // attributes: attributes, // attributes doesn't exists
            vertexShader: vertexShaderProgram,
            fragmentShader: fragmentShaderProgram,
        });
        shaderMaterial.blending = THREE.NormalBlending;
        shaderMaterial.depthTest = true;
        shaderMaterial.transparent = true;
        shaderMaterial.side = THREE.DoubleSide;
        var geometry = new THREE.BufferGeometry();
        // geometry.vertices.push(new THREE.Vector3(10, -10,0))
        addBufferedRect([], 0, 0, 0, 10, 10, [], [0, 0, 1, .5]);
        for (var i = 0; i < dataElements.length; i++) {
            // addBufferedCirlce(vertexPositionBuffer, Math.random()*10,Math.random()*10,0,2, vertexColorBuffer, [0,0,1,.5] )
            query.x.push(0);
            query.y.push(0);
            query.z.push(0);
            query.r.push(0);
            query.fill.push('0x000000');
            query.stroke.push('0x000000');
            query.strokewidth.push(1);
            query.opacity.push(1);
        }
        // geometry = new THREE.BufferGeometry();
        // CREATE + ADD MESH
        geometry.addAttribute('position', new THREE.BufferAttribute(makeBuffer3f([]), 3));
        geometry.addAttribute('customColor', new THREE.BufferAttribute(makeBuffer4f([]), 4));
        query.mesh = new THREE.Mesh(geometry, shaderMaterial);
        query.mesh.position.set(0, 0, 1);
        scene.add(query.mesh);
        return query;
    }
    function createRectangles(dataElements, scene) {
        var geometry;
        var visualElements = [];
        var c;
        for (var i = 0; i < dataElements.length; i++) {
            var rectShape = new THREE.Shape();
            rectShape.moveTo(0, 0);
            rectShape.lineTo(0, -1);
            rectShape.lineTo(1, -1);
            rectShape.lineTo(1, 0);
            rectShape.lineTo(0, 0);
            geometry = new THREE.ShapeGeometry(rectShape);
            c = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true }));
            c.position.set(0, 0, 1);
            visualElements.push(c);
            scene.add(c);
            geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, -1, 0), new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0));
            var wireframe = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, linewidth: 1 }));
            c['wireframe'] = wireframe;
            wireframe.position.set(0, 0, 1.1);
            scene.add(wireframe);
        }
        return visualElements;
    }
    function createPaths(dataElements, scene) {
        var geometry;
        var visualElements = [];
        var c;
        for (var i = 0; i < dataElements.length; i++) {
            geometry = new THREE.Geometry();
            c = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true }));
            c.position.set(0, 0, 0);
            visualElements.push(c);
            scene.add(c);
        }
        return visualElements;
    }
    function createPolygons(dataElements, scene) {
        var geometry;
        var visualElements = [];
        var c;
        for (var i = 0; i < dataElements.length; i++) {
            geometry = new THREE.Geometry();
            // geometry.vertices.push(
            //     new THREE.Vector3(5, 0, 0 ),
            //     new THREE.Vector3( 15, 3, 0 ),
            //     new THREE.Vector3( 15, -3, 0 )
            // );
            // geometry.faces.push(new THREE.Face3(0, 1, 2)); 
            c = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, side: THREE.DoubleSide }));
            c.doubleSided = true;
            c.position.set(0, 0, 0);
            visualElements.push(c);
            scene.add(c);
        }
        return visualElements;
    }
    function createLines(dataElements, scene) {
        var geometry;
        var visualElements = [];
        var c;
        for (var i = 0; i < dataElements.length; i++) {
            geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(-10, 0, 0), new THREE.Vector3(0, 10, 0));
            c = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true }));
            c.position.set(0, 0, 0);
            visualElements.push(c);
            scene.add(c);
        }
        return visualElements;
    }
    function createWebGLText(dataElements, scene) {
        var visualElements = [];
        var mesh;
        for (var i = 0; i < dataElements.length; i++) {
            mesh = new THREE.Mesh(new THREE.PlaneGeometry(1000, 100), new THREE.MeshBasicMaterial());
            mesh.doubleSided = true;
            visualElements.push(mesh);
            scene.add(mesh);
        }
        return visualElements;
    }
    function createPath(mesh, points) {
        mesh.geometry.vertices = [];
        for (var i = 0; i < points.length; i++) {
            mesh.geometry.vertices.push(new THREE.Vector3(points[i].x, points[i].y, 0));
        }
        mesh.geometry.verticesNeedUpdate = true;
    }
    function createPolygon(mesh, points) {
        var shape = new THREE.Shape(points);
        mesh.geometry = new THREE.ShapeGeometry(shape);
        mesh.geometry.verticesNeedUpdate = true;
    }
    ///////////////////
    /// INTERACTION /// 
    ///////////////////
    class WebGLInteractor {
        constructor(scene, canvas, camera) {
            this.mouse = [];
            this.mouseStart = [];
            this.mouseDown = false;
            this.cameraStart = [];
            this.panOffset = [];
            this.lastIntersectedSelections = [];
            this.lastIntersectedElements = [];
            this.isPanEnabled = true;
            this.isHorizontalPanEnabled = true;
            this.isLassoEnabled = true;
            this.lassoPoints = [];
            this.mouseOverSelections = [];
            this.mouseMoveSelections = [];
            this.mouseOutSelections = [];
            this.mouseDownSelections = [];
            this.mouseUpSelections = [];
            this.clickSelections = [];
            this.scene = scene;
            this.canvas = canvas;
            this.camera = camera;
            this.mouse = [0, 0];
            canvas.addEventListener('mousemove', (e) => {
                this.mouseMoveHandler(e);
            });
            canvas.addEventListener('mousedown', (e) => {
                this.mouseDownHandler(e);
            });
            canvas.addEventListener('mouseup', (e) => {
                this.mouseUpHandler(e);
            });
            canvas.addEventListener('click', (e) => {
                this.clickHandler(e);
            });
            // not really working in iFrames..
            // window.addEventListener('keyDown', (e)=>{
            //     this.keyDownHandler(e);
            // })
            // window.addEventListener('keyUp', (e)=>{
            //     this.keyUpHandler(e);
            // })
        }
        register(selection, method) {
            switch (method) {
                case 'mouseover':
                    this.mouseOverSelections.push(selection);
                    break;
                case 'mousemove':
                    this.mouseMoveSelections.push(selection);
                    break;
                case 'mouseout':
                    this.mouseOutSelections.push(selection);
                    break;
                case 'mousedown':
                    this.mouseDownSelections.push(selection);
                    break;
                case 'mouseup':
                    this.mouseUpSelections.push(selection);
                    break;
                case 'click':
                    this.clickSelections.push(selection);
                    break;
            }
        }
        addEventListener(eventName, f) {
            if (eventName == 'lassoStart')
                this.lassoStartHandler = f;
            if (eventName == 'lassoEnd')
                this.lassoEndHandler = f;
            if (eventName == 'lassoMove')
                this.lassoMoveHandler = f;
        }
        // Event handlers
        mouseMoveHandler(e) {
            this.mouse = mouseToWorldCoordinates(e.clientX, e.clientY);
            if (this.isLassoEnabled && e.which == 2) {
                this.lassoPoints.push(this.mouse);
                if (this.lassoMoveHandler)
                    this.lassoMoveHandler(this.lassoPoints);
            }
            else {
                var intersectedVisualElements = [];
                // remove previous highlighting
                for (var i = 0; i < this.lastIntersectedSelections.length; i++) {
                    for (var j = 0; j < this.lastIntersectedElements[i].length; j++) {
                        this.lastIntersectedSelections[i].call('mouseout', this.lastIntersectedElements[i][j]);
                    }
                }
                this.lastIntersectedSelections = [];
                this.lastIntersectedElements = [];
                var nothingIntersected = true;
                // call mouseover on all elements with a mouse over handler
                for (var i = 0; i < this.mouseOverSelections.length; i++) {
                    // If selecton is SHADER, check manually
                    intersectedVisualElements = this.intersect(this.mouseOverSelections[i], this.mouse[0], this.mouse[1]);
                    if (intersectedVisualElements.length > 0) {
                        this.lastIntersectedElements.push(intersectedVisualElements);
                        this.lastIntersectedSelections.push(this.mouseOverSelections[i]);
                    }
                    for (var j = 0; j < intersectedVisualElements.length; j++) {
                        this.mouseOverSelections[i].call('mouseover', intersectedVisualElements[j], e);
                    }
                    if (intersectedVisualElements.length > 0)
                        nothingIntersected = false;
                }
                // call mousemove on all elements with a mouse move handler
                for (var i = 0; i < this.mouseMoveSelections.length; i++) {
                    intersectedVisualElements = this.intersect(this.mouseMoveSelections[i], this.mouse[0], this.mouse[1]);
                    for (var j = 0; j < intersectedVisualElements.length; j++) {
                        this.mouseMoveSelections[i].call('mousemove', intersectedVisualElements[j], e);
                    }
                    if (intersectedVisualElements.length > 0)
                        nothingIntersected = false;
                }
                // if nothing intersected pan:
                if (nothingIntersected && this.mouseDown) {
                    if (this.isPanEnabled) {
                        this.panOffset = [e.clientX - this.mouseStart[0], e.clientY - this.mouseStart[1]];
                        if (this.isHorizontalPanEnabled)
                            webgl.camera.position.x = this.cameraStart[0] - this.panOffset[0] / webgl.camera.zoom;
                        webgl.camera.position.y = this.cameraStart[1] + this.panOffset[1] / webgl.camera.zoom;
                        webgl.render();
                    }
                }
            }
        }
        clickHandler(e) {
            this.mouse = mouseToWorldCoordinates(e.clientX, e.clientY);
            var intersectedVisualElements = [];
            // call mouseclick on all elements with a mouse over handler
            for (var i = 0; i < this.clickSelections.length; i++) {
                intersectedVisualElements = this.intersect(this.clickSelections[i], this.mouse[0], this.mouse[1]);
                for (var j = 0; j < intersectedVisualElements.length; j++) {
                    this.clickSelections[i].call('click', intersectedVisualElements[j], e);
                }
            }
            this.mouseDown = false;
        }
        mouseDownHandler(e) {
            this.mouse = mouseToWorldCoordinates(e.clientX, e.clientY);
            this.mouseStart = [e.clientX, e.clientY];
            this.cameraStart = [webgl.camera.position.x, webgl.camera.position.y];
            this.mouseDown = true;
            var intersectedVisualElements = [];
            for (var i = 0; i < this.mouseDownSelections.length; i++) {
                intersectedVisualElements = this.intersect(this.mouseDownSelections[i], this.mouse[0], this.mouse[1]);
                for (var j = 0; j < intersectedVisualElements.length; j++) {
                    this.mouseDownSelections[i].call('mousedown', intersectedVisualElements[j], e);
                }
            }
            this.lassoPoints = [];
            this.lassoPoints.push(this.mouse);
            if (this.lassoStartHandler && e.which == 2) {
                this.lassoStartHandler(this.lassoPoints);
            }
        }
        mouseUpHandler(e) {
            this.mouse = mouseToWorldCoordinates(e.clientX, e.clientY);
            var intersectedVisualElements = [];
            for (var i = 0; i < this.mouseUpSelections.length; i++) {
                intersectedVisualElements = this.intersect(this.mouseUpSelections[i], this.mouse[0], this.mouse[1]);
                for (var j = 0; j < intersectedVisualElements.length; j++) {
                    this.mouseUpSelections[i].call('mouseup', intersectedVisualElements[j], e);
                }
            }
            this.mouseDown = false;
            if (this.lassoEndHandler && e.which == 2) {
                this.lassoEndHandler(this.lassoPoints);
            }
        }
        intersect(selection, mousex, mousey) {
            switch (selection.shape) {
                case 'circle':
                    return this.intersectCircles(selection);
                case 'rect':
                    return this.intersectRects(selection);
                case 'path':
                    return this.intersectPaths(selection);
                case 'text':
                    return this.intersectRects(selection);
            }
            return [];
        }
        // returns list of data elements 
        intersectCircles(selection) {
            var intersectedElements = [];
            var d;
            for (var i = 0; i < selection.dataElements.length; i++) {
                d = Math.sqrt(Math.pow(this.mouse[0] - selection.x[i], 2) + Math.pow(this.mouse[1] - selection.y[i], 2));
                if (d <= selection.r[i])
                    intersectedElements.push(selection.dataElements[i]);
            }
            return intersectedElements;
        }
        intersectRects(selection) {
            var intersectedElements = [];
            var e;
            for (var i = 0; i < selection.visualElements.length; i++) {
                e = selection.visualElements[i];
                if (this.mouse[0] >= e.position.x && this.mouse[0] <= e.position.x + e.geometry.vertices[0].x * e.scale.x
                    && this.mouse[1] <= e.position.y && this.mouse[1] >= e.position.y + e.geometry.vertices[1].y * e.scale.y)
                    intersectedElements.push(selection.dataElements[i]);
            }
            return intersectedElements;
        }
        intersectPaths(selection) {
            var intersectedElements = [];
            var e;
            var v1, v2;
            var found = false;
            for (var i = 0; i < selection.visualElements.length; i++) {
                e = selection.visualElements[i];
                for (var j = 1; j < e.geometry.vertices.length; j++) {
                    v1 = e.geometry.vertices[j - 1];
                    v1 = {
                        x: v1.x + selection.x[i],
                        y: v1.y + selection.y[i]
                    };
                    v2 = e.geometry.vertices[j];
                    v2 = {
                        x: v2.x + selection.x[i],
                        y: v2.y + selection.y[i]
                    };
                    if (distToSegmentSquared({ x: this.mouse[0], y: this.mouse[1] }, v1, v2) < 3) {
                        intersectedElements.push(selection.dataElements[i]);
                        found = true;
                        break;
                    }
                }
                if (found)
                    break;
            }
            return intersectedElements;
            function sqr(x) {
                return x * x;
            }
            function dist2(v, w) {
                return sqr(v.x - w.x) + sqr(v.y - w.y);
            }
            function distToSegmentSquared(p, v, w) {
                var l2 = dist2(v, w);
                if (l2 == 0)
                    return dist2(p, v);
                var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                if (t < 0)
                    return dist2(p, v);
                if (t > 1)
                    return dist2(p, w);
                return dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });
            }
        }
    }
    // Calculate intersection
    function mouseToWorldCoordinates(mouseX, mouseY) {
        var rect = webgl.canvas.getBoundingClientRect();
        var x = webgl.camera.position.x + webgl.camera.left / webgl.camera.zoom + (mouseX - rect.left) / webgl.camera.zoom;
        var y = webgl.camera.position.y + webgl.camera.top / webgl.camera.zoom - (mouseY - rect.top) / webgl.camera.zoom; // this.mouse[1] *= -1
        return [x, y];
    }
    function curve(points) {
        var arrayPoints = [];
        for (var i = 0; i < points.length; i++) {
            if (!isNaN(points[i].x))
                arrayPoints.push([points[i].x, points[i].y]);
        }
        var spline = new BSpline(arrayPoints, 3); //making BSpline
        var curvePoints = [];
        for (var t = 0; t <= 1; t += 0.01) {
            var p = spline.calcAt(t);
            curvePoints.push({ x: p[0], y: p[1] });
        }
        return curvePoints;
    }
    ///////////////////
    /// UI ELEMENTS ///
    ///////////////////
    class CheckBox {
        constructor() {
            this.selected = false;
            this.frame = selectAll()
                .data([0])
                .append('circle')
                .attr('r', 5)
                .style('fill', '#fff')
                .style('stroke', '#000000')
                .on('click', () => {
                this.selected = !this.selected;
                this.circle.style('opacity', this.selected ? 1 : 0);
                if (this.changeCallBack != undefined)
                    this.changeCallBack();
            });
            this.circle = selectAll()
                .data([0]);
            // .append('circle')
            //     .attr('r', 3)
            //     .attr('z', 1)
            //     .style('fill', '#000000')
            //     .style('opacity', 0);
        }
        attr(attrName, value) {
            switch (attrName) {
                case 'x':
                    this.frame.attr('x', value);
                    // this.circle.attr('x', value); 
                    return this;
                case 'y':
                    this.frame.attr('y', value);
                    // this.circle.attr('y', value); 
                    return this;
            }
        }
        on(eventType, fn) {
            switch (eventType) {
                case 'change': this.changeCallBack = fn;
            }
        }
    }
    // }
    class THREEx {
        /**
         * create a dynamic texture with a underlying canvas
         *
         * @param {Number} width  width of the canvas
         * @param {Number} height height of the canvas
        */
        constructor(width, height) {
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            this.canvas = canvas;
            var context = canvas.getContext('2d');
            this.context = context;
            var texture = new THREE.Texture(canvas);
            this.texture = texture;
        }
        /**
         * clear the canvas
         *
         * @param  {String*} fillStyle 		the fillStyle to clear with, if not provided, fallback on .clearRect
         * @return {THREEx.DynamicTexture}      the object itself, for chained texture
         */
        clear(fillStyle) {
            // depends on fillStyle
            if (fillStyle !== undefined) {
                this.context.fillStyle = fillStyle;
                this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            else {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            // make the texture as .needsUpdate
            this.texture.needsUpdate = true;
            // for chained API 
            return this;
        }
        /**
         * draw text
         *
         * @param  {String}		text	the text to display
         * @param  {Number|undefined}	x	if provided, it is the x where to draw, if not, the text is centered
         * @param  {Number}		y	the y where to draw the text
         * @param  {String*} 		fillStyle the fillStyle to clear with, if not provided, fallback on .clearRect
         * @param  {String*} 		contextFont the font to use
         * @return {THREEx.DynamicTexture}	the object itself, for chained texture
         */
        drawText(text, x, y, fillStyle, contextFont) {
            // set font if needed
            if (contextFont !== undefined)
                this.context.font = contextFont;
            // if x isnt provided 
            if (x === undefined || x === null) {
                var textSize = this.context.measureText(text);
                x = (this.canvas.width - textSize.width) / 2;
            }
            // actually draw the text
            this.context.fillStyle = fillStyle;
            this.context.fillText(text, x, y);
            // make the texture as .needsUpdate
            this.texture.needsUpdate = true;
            // for chained API 
            return this;
        }
        ;
        drawTextCooked(text, options) {
            var context = this.context;
            var canvas = this.canvas;
            options = options || {};
            var params = {
                margin: options.margin !== undefined ? options.margin : 0.1,
                lineHeight: options.lineHeight !== undefined ? options.lineHeight : 0.1,
                align: options.align !== undefined ? options.align : 'left',
                fillStyle: options.fillStyle !== undefined ? options.fillStyle : 'black',
            };
            context.save();
            context.fillStyle = params.fillStyle;
            var y = (params.lineHeight + params.margin) * canvas.height;
            while (text.length > 0) {
                // compute the text for specifically this line
                var maxText = computeMaxTextLength(text);
                // update the remaining text
                text = text.substr(maxText.length);
                // compute x based on params.align
                var textSize = context.measureText(maxText);
                // new variable to recognize if x exists or not
                var computeX = true;
                var x = 0;
                if (params.align === 'left') {
                    x = params.margin * canvas.width;
                }
                else if (params.align === 'right') {
                    x = (1 - params.margin) * canvas.width - textSize.width;
                }
                else if (params.align === 'center') {
                    x = (canvas.width - textSize.width) / 2;
                }
                else {
                    computeX = false;
                    console.assert(false);
                }
                if (computeX) {
                    // actually draw the text at the proper position
                    this.context.fillText(maxText, x, y);
                }
                // goto the next line
                y += params.lineHeight * canvas.height;
            }
            context.restore();
            // make the texture as .needsUpdate
            this.texture.needsUpdate = true;
            // for chained API
            return this;
            function computeMaxTextLength(text) {
                var maxText = '';
                var maxWidth = (1 - params.margin * 2) * canvas.width;
                while (maxText.length !== text.length) {
                    var textSize = context.measureText(maxText);
                    if (textSize.width > maxWidth)
                        break;
                    maxText += text.substr(maxText.length, 1);
                }
                return maxText;
            }
        }
        /**
         * execute the drawImage on the internal context
         * the arguments are the same the official context2d.drawImage
         */
        drawImage( /* same params as context2d.drawImage */) {
            // call the drawImage
            this.context.drawImage.apply(this.context, arguments);
            // make the texture as .needsUpdate
            this.texture.needsUpdate = true;
            // for chained API 
            return this;
        }
    }
    /*
    var THREEx: any = THREEx || {}

    //////////////////////////////////////////////////////////////////////////////////
    //		Constructor							//
    //////////////////////////////////////////////////////////////////////////////////

    /**
     * create a dynamic texture with a underlying canvas
     *
     * @param {Number} width  width of the canvas
     * @param {Number} height height of the canvas
     */
    /*
    THREEx.DynamicTexture = function (width: number, height: number) {
        var canvas = document.createElement('canvas')
        canvas.width = width
        canvas.height = height
        this.canvas = canvas

        var context = canvas.getContext('2d')
        this.context = context

        var texture = new THREE.Texture(canvas)
        this.texture = texture
    }

    //////////////////////////////////////////////////////////////////////////////////
    //		methods								//
    //////////////////////////////////////////////////////////////////////////////////

    /**
     * clear the canvas
     *
     * @param  {String*} fillStyle 		the fillStyle to clear with, if not provided, fallback on .clearRect
     * @return {THREEx.DynamicTexture}      the object itself, for chained texture
     */
    /*
    THREEx.DynamicTexture.prototype.clear = function (fillStyle: any) {
        // depends on fillStyle
        if (fillStyle !== undefined) {
            this.context.fillStyle = fillStyle
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)
        } else {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
        }
        // make the texture as .needsUpdate
        this.texture.needsUpdate = true;
        // for chained API
        return this;
    }

    /**
     * draw text
     *
     * @param  {String}		text	the text to display
     * @param  {Number|undefined}	x	if provided, it is the x where to draw, if not, the text is centered
     * @param  {Number}		y	the y where to draw the text
     * @param  {String*} 		fillStyle the fillStyle to clear with, if not provided, fallback on .clearRect
     * @param  {String*} 		contextFont the font to use
     * @return {THREEx.DynamicTexture}	the object itself, for chained texture
     */
    /*
    THREEx.DynamicTexture.prototype.drawText = function (text, x, y, fillStyle, contextFont) {
        // set font if needed
        if (contextFont !== undefined) this.context.font = contextFont;
        // if x isnt provided
        if (x === undefined || x === null) {
            var textSize = this.context.measureText(text);
            x = (this.canvas.width - textSize.width) / 2;
        }
        // actually draw the text
        this.context.fillStyle = fillStyle;
        this.context.fillText(text, x, y);
        // make the texture as .needsUpdate
        this.texture.needsUpdate = true;
        // for chained API
        return this;
    };

    THREEx.DynamicTexture.prototype.drawTextCooked = function (text, options) {
        var context = this.context
        var canvas = this.canvas
        options = options || {}
        var params = {
            margin: options.margin !== undefined ? options.margin : 0.1,
            lineHeight: options.lineHeight !== undefined ? options.lineHeight : 0.1,
            align: options.align !== undefined ? options.align : 'left',
            fillStyle: options.fillStyle !== undefined ? options.fillStyle : 'black',
        }
        context.save()
        context.fillStyle = params.fillStyle;

        var y = (params.lineHeight + params.margin) * canvas.height
        while (text.length > 0) {
            // compute the text for specifically this line
            var maxText = computeMaxTextLength(text)
            // update the remaining text
            text = text.substr(maxText.length)


            // compute x based on params.align
            var textSize = context.measureText(maxText);
            if (params.align === 'left') {
                var x = params.margin * canvas.width
            } else if (params.align === 'right') {
                var x = (1 - params.margin) * canvas.width - textSize.width
            } else if (params.align === 'center') {
                var x = (canvas.width - textSize.width) / 2;
            } else console.assert(false)

            // actually draw the text at the proper position
            this.context.fillText(maxText, x, y);

            // goto the next line
            y += params.lineHeight * canvas.height
        }
        context.restore()

        // make the texture as .needsUpdate
        this.texture.needsUpdate = true;
        // for chained API
        return this;

        function computeMaxTextLength(text) {
            var maxText = ''
            var maxWidth = (1 - params.margin * 2) * canvas.width
            while (maxText.length !== text.length) {
                var textSize = context.measureText(maxText);
                if (textSize.width > maxWidth) break;
                maxText += text.substr(maxText.length, 1)
            }
            return maxText
        }
    }

    /**
     * execute the drawImage on the internal context
     * the arguments are the same the official context2d.drawImage
     */
    /*
    THREEx.DynamicTexture.prototype.drawImage = function () {
        // call the drawImage
        this.context.drawImage.apply(this.context, arguments)
        // make the texture as .needsUpdate
        this.texture.needsUpdate = true;
        // for chained API
        return this;
    }
    */
    //////////////////
    /// VECTOR OPS ///
    //////////////////
    //module geometry {
    function length(v1) {
        return Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
    }
    function normalize(v) {
        var l = length(v);
        return [v[0] / l, v[1] / l];
    }
    function setLength(v, l) {
        var len = length(v);
        return [l * v[0] / len, l * v[1] / len];
    }
    //}

    var glutils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        makeAlphaBuffer: makeAlphaBuffer,
        addBufferedHatchedRect: addBufferedHatchedRect,
        addBufferedRect: addBufferedRect,
        addBufferedCirlce: addBufferedCirlce,
        addBufferedDiamond: addBufferedDiamond,
        createRectFrame: createRectFrame,
        createDiagonalCross: createDiagonalCross,
        makeBuffer3f: makeBuffer3f,
        makeBuffer4f: makeBuffer4f,
        updateBuffer: updateBuffer,
        createText: createText,
        getMousePos: getMousePos,
        WebGL: WebGL,
        initWebGL: initWebGL,
        setWebGL: setWebGL,
        selectAll: selectAll,
        WebGLElementQuery: WebGLElementQuery,
        setStyle: setStyle,
        setText: setText,
        setX1: setX1,
        setY1: setY1,
        setX2: setX2,
        setY2: setY2,
        createG: createG,
        GroupElement: GroupElement,
        createCirclesNoShader: createCirclesNoShader,
        createCirclesWithBuffers: createCirclesWithBuffers,
        createRectangles: createRectangles,
        createPaths: createPaths,
        createPolygons: createPolygons,
        createLines: createLines,
        createWebGLText: createWebGLText,
        createPath: createPath,
        createPolygon: createPolygon,
        WebGLInteractor: WebGLInteractor,
        mouseToWorldCoordinates: mouseToWorldCoordinates,
        curve: curve,
        CheckBox: CheckBox,
        THREEx: THREEx,
        length: length,
        normalize: normalize,
        setLength: setLength
    });

    /// <reference path="./lib/d3.d.ts"/>
    class Legend {
        constructor(data, handlerFunction) {
            this.margin = {
                left: 10,
                top: 20
            };
            this.height = 0; // INIT ???? 
            this.data = data;
        }
        setClickCallBack(handlerFunction) {
            this.clickCallBack = handlerFunction;
        }
        appendTo(svg) {
            this.legendEntries = d3.select('#legendSvg')
                .selectAll('.legend')
                .data(this.data)
                .enter().append('g')
                .attr('transform', (d, i) => {
                return 'translate(' + this.margin.left + ',' + (this.margin.top + i * 20) + ')';
            });
            this.height = this.margin.top + this.data.length * 20;
            $$1(svg).height(this.height);
            this.legendEntries.append('circle')
                .attr('r', 5)
                .style('opacity', .7)
                .style('fill', function (d) {
                if (d.color)
                    return d.color;
                else
                    return '#000';
            })
                .style('stroke', function (d) {
                if (d.color)
                    return d.color;
                else
                    return '#000';
            })
                .style('stroke-width', 2)
                .on('click', this.clickCallBack);
            this.legendEntries.append('text')
                .text(function (d) {
                return d.name;
            })
                .attr('x', 20)
                .attr('y', 5);
        }
    }

    var legend = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Legend: Legend
    });

    /// <reference path="./lib/d3.d.ts"/>
    class RangeSlider {
        constructor(x, y, width, minValue, maxValue, stepWidth, tickMarks) {
            /* VISUALIZATION PARAMETERS */
            this.BAR_WIDTH = 5;
            this.RADIUS_HANDLE = 4;
            this.LEFT = this.RADIUS_HANDLE;
            this.RIGHT = this.RADIUS_HANDLE;
            this.HEIGHT = 10;
            this.TOP = 0;
            this.isInverted = false;
            this.dragStartXMouse = 0; // BEFORE number;
            this.dragStartXBar = 0; // BEFORE number;
            this.currentBarLength = 0; // BEFORE number;
            this.x = x;
            this.y = y;
            this.width = width;
            this.min = minValue;
            this.max = maxValue;
            this.stepWidth = stepWidth;
            if (tickMarks != undefined)
                this.hasTickmarks = tickMarks;
            else
                this.hasTickmarks = false;
        }
        setDragEndCallBack(fn) {
            this.dragEndCallBackFn = fn;
        }
        appendTo(svg) {
            this.svg = svg;
            //this.rect = this.svg['_groups'][0][0].getBoundingClientRect(); // d3 v4
            this.rect = this.svg[0][0].getBoundingClientRect();
            this.valueRange = d3.scale.linear()
                .domain([0, this.width])
                .range([this.min, this.max]);
            this.drag = d3.behavior.drag()
                .origin(Object)
                .on("dragstart", () => { this.dragStart(); }) // d3 v4 is only "start"
                .on("drag", () => { this.dragMove(); });
            this.svg = svg;
            this.g = svg.append("g")
                .attr("height", this.HEIGHT)
                .attr("width", this.width)
                .attr("transform", "translate(" + this.x + "," + this.y + ")");
            this.g.append("line")
                .attr("x1", this.LEFT)
                .attr("y1", this.TOP)
                .attr("x2", this.width - this.RIGHT - this.LEFT)
                .attr("y2", this.TOP)
                .style("stroke", "#aaa");
            if (this.hasTickmarks) {
                this.val2spaceScale = d3.scale.linear()
                    .domain([this.min, this.max])
                    .range([this.LEFT, this.width - this.RIGHT - this.LEFT]);
                for (var i = this.min; i <= this.max; i += this.stepWidth) {
                    var x = this.val2spaceScale(i);
                    this.g.append("line")
                        .attr('class', 'rangeTick')
                        .attr("x1", x)
                        .attr("y1", this.TOP)
                        .attr("x2", x)
                        .attr("y2", this.TOP + 20)
                        .style('stroke', '#bbb');
                    this.g.append('text')
                        .attr('class', 'rangeTickText')
                        .attr('x', x)
                        .attr('y', this.TOP + 20)
                        .text(i.toFixed(1))
                        .style('opacity', .5)
                        .style('font-family', 'Helvetica')
                        .style('font-weigth', '100')
                        .style('font-size', '7pt');
                }
            }
            if (this.isInverted) {
                this.bar0 = this.g.append('rect')
                    .attr('x', this.LEFT)
                    .attr('y', this.TOP)
                    .attr('height', this.BAR_WIDTH)
                    .attr('width', 0)
                    .style('fill', '#bbb')
                    .call(this.drag)
                    .attr('id', 'bar0');
                this.bar1 = this.g.append('rect')
                    .attr('x', this.RIGHT)
                    .attr('y', this.TOP)
                    .attr('height', this.BAR_WIDTH)
                    .attr('width', 0)
                    .style('fill', '#bbb')
                    .call(this.drag)
                    .attr('id', 'bar1');
            }
            else {
                this.bar0 = this.g.append('rect')
                    .attr('x', this.LEFT)
                    .attr('y', this.TOP)
                    .attr('height', this.BAR_WIDTH)
                    .attr('width', this.width - this.RIGHT - this.LEFT)
                    .style('fill', '#bbb')
                    .call(this.drag)
                    .attr('id', 'bar0');
                this.bar1 = null;
            }
            this.circleMin = this.g.append("circle")
                .attr("id", "sliderKnobMin")
                .attr("r", this.RADIUS_HANDLE)
                .attr("cx", this.LEFT)
                .attr("cy", this.TOP + this.BAR_WIDTH)
                .attr("fill", "#777")
                .attr('onchange', 'trace.event(\'vis_27\',document.location.pathname,\'Time Sliden Min\',\'cx\' + this.getAttribute(\'cx\'))')
                .attr('onmouseup', 'trace.event(\'vis_27\',document.location.pathname,\'Time Sliden Min\',\'cx\' + this.getAttribute(\'cx\'))')
                .call(this.drag);
            this.circleMax = this.g.append("circle")
                .attr("id", "sliderKnobMax")
                .attr("r", this.RADIUS_HANDLE)
                .attr("cx", this.width - this.RIGHT)
                .attr("cy", this.TOP + this.BAR_WIDTH)
                .attr("fill", "#777")
                .attr('onchange', 'trace.event(\'vis_28\',document.location.pathname,\'Time Sliden Max\',\'cx\' + this.getAttribute(\'cx\'))')
                .attr('onmouseup', 'trace.event(\'vis_28\',document.location.pathname,\'Time Sliden Max\',\'cx\' + this.getAttribute(\'cx\'))')
                .call(this.drag);
        }
        dragStart() {
            this.dragStartXMouse = Math.max(this.LEFT, Math.min(this.width - this.RIGHT, this.getRelX()));
            var sourceEvent = (d3.event).sourceEvent; //(d3.event as D3.BaseEvent)
            this.dragObj = sourceEvent ? sourceEvent.target : undefined;
            if (this.isInverted) {
                // determine whether we are left of min, in between, or right of max
                // the startxbar is the left end of whichever segment we are in, 
                // and the barlength is same
                var minPos = parseInt(this.circleMin.attr('cx'));
                var maxPos = parseInt(this.circleMax.attr('cx'));
                if (this.dragStartXMouse < minPos) {
                    this.dragStartXBar = this.LEFT;
                    this.currentBarLength = minPos - this.LEFT;
                }
                else if (this.dragStartXMouse < maxPos) {
                    this.dragStartXBar = minPos;
                    this.currentBarLength = maxPos - minPos;
                }
                else {
                    this.dragStartXBar = maxPos;
                    this.currentBarLength = this.width - this.RIGHT - maxPos;
                }
            }
            else {
                this.dragStartXBar = parseInt(this.bar0.attr('x'));
                this.currentBarLength = parseInt(this.bar0.attr('width'));
            }
        }
        dragMove() {
            // if we are dragging the entire bar
            if (!this.isInverted && this.dragObj.id == this.bar0.attr('id')) {
                var xOffset = Math.max(this.LEFT, Math.min(this.width - this.RIGHT, this.getRelX())) - this.dragStartXMouse;
                var x1 = Math.max(this.LEFT, Math.min(this.width - this.RIGHT - this.currentBarLength, this.dragStartXBar + xOffset));
                this.bar0.attr('x', x1);
                this.circleMin.attr("cx", x1);
                this.circleMax.attr("cx", x1 + this.currentBarLength);
                // or else we are dragging one of the circles.
            }
            else if (this.isInverted
                && (this.dragObj.id == this.bar0.attr('id')
                    || this.dragObj.id == this.bar1.attr('id'))) {
                // when inverted, dragging bars does nothing
                return;
            }
            else {
                d3.select(this.dragObj).attr("cx", Math.max(this.LEFT, Math.min(this.width - this.RIGHT, this.getRelX())));
                if (this.isInverted) {
                    this.bar0
                        .attr('x', this.LEFT)
                        .attr('width', this.circleMin.attr('cx') - this.LEFT);
                    this.bar1
                        .attr('x', this.circleMax.attr('cx'))
                        .attr('width', this.width - (this.RIGHT * 2) - this.circleMax.attr('cx'));
                }
                else {
                    this.bar0.attr('x', this.circleMin.attr('cx'))
                        .attr('width', this.circleMax.attr('cx') - this.circleMin.attr('cx'));
                }
            }
            this.dragEnd();
        }
        dragEnd() {
            this.min = this.valueRange(this.circleMin.attr("cx"));
            this.max = this.valueRange(this.circleMax.attr("cx"));
            this.dragEndCallBackFn(this.min, this.max);
        }
        getRelX() {
            var sourceEvent = (d3.event).sourceEvent; //(d3.event as D3.BaseEvent)
            var pageX = sourceEvent ? (sourceEvent).pageX : 0;
            return pageX - this.LEFT - this.x - this.rect.left;
        }
        set(min, max) {
            // seems like this would make sense, 
            // this.min = min;
            // this.max = max;
            this.circleMin.attr("cx", this.valueRange.invert(min));
            this.circleMax.attr("cx", this.valueRange.invert(max));
            // inverted support
            if (this.isInverted) {
                this.bar0
                    .attr('x', this.LEFT)
                    .attr('width', this.circleMin.attr('cx'));
                this.bar1
                    .attr('x', this.circleMax.attr('cx'))
                    .attr('width', this.width - (this.RIGHT * 2) - this.circleMax.attr('cx'));
            }
            else {
                this.bar0
                    .attr('x', this.circleMin.attr('cx'))
                    .attr('width', this.circleMax.attr('cx') - this.circleMin.attr('cx'));
            }
        }
        setIsInverted(inv) {
            if (inv == this.isInverted)
                return;
            this.isInverted = inv;
            if (this.isInverted) {
                // create bar1, set positions of both
                this.bar1 = this.g.insert('rect', '#bar0')
                    .attr('x', this.RIGHT)
                    .attr('y', this.TOP)
                    .attr('height', this.BAR_WIDTH)
                    .attr('width', 0)
                    .style('fill', '#bbb')
                    .call(this.drag)
                    .attr('id', 'bar1');
            }
            else {
                this.bar1.remove();
            }
            this.set(this.min, this.max);
        }
    }

    var rangeslider = /*#__PURE__*/Object.freeze({
        __proto__: null,
        RangeSlider: RangeSlider
    });

    /// <reference path="./lib/d3.d.ts"/>
    class Slider {
        constructor(x, y, width, minValue, maxValue, stepWidth) {
            /* VISUALIZATION PARAMETERS */
            this.BAR_WIDTH = 5;
            this.RADIUS_HANDLE = 5;
            this.LEFT = this.RADIUS_HANDLE;
            this.RIGHT = this.RADIUS_HANDLE;
            this.HEIGHT = 10;
            this.TOP = 0;
            this.x = x;
            this.y = y;
            this.width = width;
            this.min = minValue;
            this.max = maxValue;
            this.value = this.min;
            this.stepWidth = stepWidth;
        }
        setDragEndCallBack(fn) {
            this.dragEndCallBackFn = fn;
        }
        appendTo(svg) {
            this.svg = svg;
            // this.rect = (this.svg as any)['_groups'][0][0].getBoundingClientRect(); // D3 V4
            this.rect = this.svg[0][0].getBoundingClientRect();
            this.valueRange = d3.scale.linear()
                .domain([0, this.width])
                .range([this.min, this.max]);
            this.drag = d3.behavior.drag()
                .origin(Object)
                .on("dragstart", () => { this.dragStart(); }) // d3 v4 is only "start"
                .on("drag", () => { this.dragMove(); });
            this.svg = svg;
            this.g = svg.append("g")
                .attr("height", this.HEIGHT)
                .attr("width", this.width)
                .attr("transform", "translate(" + this.x + "," + this.y + ")");
            this.g.append("line")
                .attr("x1", this.LEFT)
                .attr("y1", this.TOP)
                .attr("x2", this.width - this.RIGHT - this.LEFT)
                .attr("y2", this.TOP)
                .style("stroke", "#aaa");
            this.knob = this.g.append("circle")
                .attr("id", "#sliderKnob")
                .attr("r", this.RADIUS_HANDLE)
                .attr("cx", this.LEFT)
                .attr("cy", this.TOP)
                .attr("fill", "#777")
                .attr('onchange', 'trace.event(\'vis_4\',document.location.pathname,this.parentElement.previousElementSibling.innerHTML ,\'cx\' + this.getAttribute(\'cx\'))')
                .attr('onmouseup', 'trace.event(\'vis_4\',document.location.pathname,this.parentElement.previousElementSibling.innerHTML ,\'cx\' + this.getAttribute(\'cx\'))')
                .call(this.drag);
        }
        dragStart() {
            this.dragStartXMouse = Math.max(this.LEFT, Math.min(this.width - this.RIGHT, this.getRelX()));
            var sourceEvent = d3.event.sourceEvent; // (d3.event as d3.BaseEvent)
            this.dragObj = sourceEvent ? sourceEvent.target : undefined;
        }
        dragMove() {
            d3.select(this.dragObj).attr("cx", Math.max(this.LEFT, Math.min(this.width - this.RIGHT, this.getRelX())));
            this.dragEnd();
        }
        dragEnd() {
            this.value = this.valueRange(this.knob.attr("cx"));
            this.dragEndCallBackFn(this.value);
        }
        getRelX() {
            var sourceEvent = d3.event.sourceEvent;
            var pageX = sourceEvent ? (sourceEvent).pageX : 0; // <MouseEvent>
            return pageX - this.LEFT - this.x - this.rect.left;
        }
        set(value) {
            this.knob.attr("cx", this.valueRange.invert(value));
        }
    }

    var slider = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Slider: Slider
    });

    /// <reference path="./lib/d3.d.ts"/>
    class SmartSlider {
        constructor(x, y, width, minValue, maxValue, stepWidth, tickMarks) {
            /* VISUALIZATION PARAMETERS */
            this.BAR_WIDTH = 15;
            this.RADIUS_HANDLE = 5;
            // LEFT: number = this.RADIUS_HANDLE;
            // RIGHT: number = this.RADIUS_HANDLE;
            this.LEFT = 0;
            this.RIGHT = 0;
            this.HEIGHT = 10;
            this.TOP = 0;
            this.isInverted = false;
            this.singleTimeStepX = 0;
            this.dragStartXMouse = 0; // BEFORE number;
            this.dragStartXBar = 0; // BEFORE number;
            this.currentBarLength = 0; // BEFORE number;
            this.x = x;
            this.y = y;
            this.width = width;
            this.min = minValue;
            this.max = maxValue;
            this.stepWidth = stepWidth;
            if (tickMarks != undefined)
                this.hasTickmarks = tickMarks;
            else
                this.hasTickmarks = false;
        }
        setDragEndCallBack(fn) {
            this.dragEndCallBackFn = fn;
        }
        appendTo(svg) {
            this.svg = svg;
            //this.rect = this.svg['_groups'][0][0].getBoundingClientRect(); // D3 V4
            this.rect = this.svg[0][0].getBoundingClientRect();
            this.valueRange = d3.scale.linear()
                .domain([0, this.width])
                .range([this.min, this.max]);
            this.svg = svg;
            this.g = svg.append("g")
                .attr("height", this.HEIGHT)
                .attr("width", this.width)
                .attr("transform", "translate(" + this.x + "," + this.y + ")");
            this.drag = d3.behavior.drag()
                .origin(Object)
                .on("dragstart", () => { this.dragStart(); }) // d3 v4 is only "start"
                .on("drag", () => { this.dragMove(); });
            this.g.append("line")
                .attr("x1", this.LEFT)
                .attr("y1", this.TOP)
                .attr("x2", this.width - this.RIGHT - this.LEFT)
                .attr("y2", this.TOP)
                .style("stroke", "#aaa");
            if (this.hasTickmarks) {
                this.val2spaceScale = d3.scale.linear()
                    .domain([this.min, this.max])
                    .range([this.LEFT, this.width - this.RIGHT - this.LEFT]);
                for (var i = this.min; i <= this.max; i += this.stepWidth) {
                    var x = this.val2spaceScale(i);
                    this.g.append("line")
                        .attr('class', 'rangeTick')
                        .attr("x1", x)
                        .attr("y1", this.TOP)
                        .attr("x2", x)
                        .attr("y2", this.TOP + 20)
                        .style('stroke', '#bbb');
                    this.g.append('text')
                        .attr('class', 'rangeTickText')
                        .attr('x', x)
                        .attr('y', this.TOP + 20)
                        .text(i.toFixed(1))
                        .style('opacity', .5)
                        .style('font-family', 'Helvetica')
                        .style('font-weigth', '100')
                        .style('font-size', '7pt');
                }
            }
            if (this.isInverted) {
                this.bar0 = this.g.append('rect')
                    .attr('x', this.LEFT)
                    .attr('y', this.TOP)
                    .attr('height', this.BAR_WIDTH)
                    .attr('width', 0)
                    .style('fill', '#bbb')
                    .call(this.drag)
                    .attr('id', 'bar0')
                    .attr('onmouseup', 'trace.event(\'vis_43\',document.location.pathname,\'Time Slider\',\'x\' + this.getAttribute(\'x\') + \'width\' + this.getAttribute(\'width\'))')
                    .attr('oninput', 'trace.event(\'vis_43\',document.location.pathname,\'Time Slider\',\'x\' + this.getAttribute(\'x\') + \'width\' + this.getAttribute(\'width\'))');
                this.bar1 = this.g.append('rect')
                    .attr('x', this.RIGHT)
                    .attr('y', this.TOP)
                    .attr('height', this.BAR_WIDTH)
                    .attr('width', 0)
                    .style('fill', '#bbb')
                    .call(this.drag)
                    .attr('id', 'bar1')
                    .attr('onmouseup', 'trace.event(\'vis_43\',document.location.pathname,\'Time Slider\',\'x\' + this.getAttribute(\'x\') + \'width\' + this.getAttribute(\'width\'))')
                    .attr('oninput', 'trace.event(\'vis_43\',document.location.pathname,\'Time Slider\',\'x\' + this.getAttribute(\'x\') + \'width\' + this.getAttribute(\'width\'))');
            }
            else {
                this.bar0 = this.g.append('rect')
                    .attr('x', this.LEFT)
                    .attr('y', this.TOP)
                    .attr('height', this.BAR_WIDTH)
                    .attr('width', this.width - this.RIGHT - this.LEFT)
                    .style('fill', '#bbb')
                    .call(this.drag)
                    .attr('id', 'bar0')
                    .attr('onmouseup', 'trace.event(\'vis_43\',document.location.pathname,\'Time Slider\',\'x\' + this.getAttribute(\'x\') + \'width\' + this.getAttribute(\'width\'))')
                    .attr('oninput', 'trace.event(\'vis_43\',document.location.pathname,\'Time Slider\',\'x\' + this.getAttribute(\'x\') + \'width\' + this.getAttribute(\'width\'))');
                this.bar1 = null;
            }
            this.circleMin = this.g.append("circle")
                .attr("id", "sliderKnobMin")
                .attr("r", this.RADIUS_HANDLE)
                .attr("cx", this.LEFT)
                .attr("cy", this.TOP + this.BAR_WIDTH)
                .attr("fill", "#777")
                .attr('onchange', 'trace.event(\'vis_27\',document.location.pathname,\'Time Sliden Min\',\'cx\' + this.getAttribute(\'cx\'))')
                .attr('onmouseup', 'trace.event(\'vis_27\',document.location.pathname,\'Time Sliden Min\',\'cx\' + this.getAttribute(\'cx\'))')
                .attr('oninput', 'trace.event(\'vis_27\',document.location.pathname,\'Time Sliden Min\',\'cx\' + this.getAttribute(\'cx\'))')
                .call(this.drag);
            this.circleMax = this.g.append("circle")
                .attr("id", "sliderKnobMax")
                .attr("r", this.RADIUS_HANDLE)
                .attr("cx", this.width - this.RIGHT)
                .attr("cy", this.TOP + this.BAR_WIDTH)
                .attr("fill", "#777")
                .attr('onchange', 'trace.event(\'vis_28\',document.location.pathname,\'Time Sliden Max\',\'cx\' + this.getAttribute(\'cx\'))')
                .attr('onmouseup', 'trace.event(\'vis_28\',document.location.pathname,\'Time Sliden Max\',\'cx\' + this.getAttribute(\'cx\'))')
                .attr('oninput', 'trace.event(\'vis_28\',document.location.pathname,\'Time Sliden Max\',\'cx\' + this.getAttribute(\'cx\'))')
                .call(this.drag);
            // this.circleSingle = this.g
            //     .append('svg:path')
            //     .attr('d', 'M0,0L4,4L4,15L-4,15L-4,4L0,0')
            //     .attr('fill', '#777')
            //     .attr("id", "sliderKnobSingle")
            //     .call(this.drag);
        }
        dragStart() {
            this.dragStartXMouse = Math.max(this.LEFT, Math.min(this.width - this.RIGHT, this.getRelX()));
            var sourceEvent = (d3.event).sourceEvent; // d3.BaseEvent
            this.dragObj = sourceEvent ? sourceEvent.target : undefined;
            if (this.isInverted) {
                // determine whether we are left of min, in between, or right of max
                // the startxbar is the left end of whichever segment we are in, 
                // and the barlength is same
                var minPos = parseInt(this.circleMin.attr('cx'));
                var maxPos = parseInt(this.circleMax.attr('cx'));
                if (this.dragStartXMouse < minPos) {
                    this.dragStartXBar = this.LEFT;
                    this.currentBarLength = minPos - this.LEFT;
                }
                else if (this.dragStartXMouse < maxPos) {
                    this.dragStartXBar = minPos;
                    this.currentBarLength = maxPos - minPos;
                }
                else {
                    this.dragStartXBar = maxPos;
                    this.currentBarLength = this.width - this.RIGHT - maxPos;
                }
            }
            else {
                this.dragStartXBar = parseInt(this.bar0.attr('x'));
                this.currentBarLength = parseInt(this.bar0.attr('width'));
            }
        }
        dragMove() {
            // if we are dragging the entire bar
            if (!this.isInverted && this.dragObj.id == this.bar0.attr('id')) {
                var xOffset = Math.max(this.LEFT, Math.min(this.width - this.RIGHT, this.getRelX())) - this.dragStartXMouse;
                var x1 = Math.max(this.LEFT, Math.min(this.width - this.RIGHT - this.currentBarLength, this.dragStartXBar + xOffset));
                this.bar0.attr('x', x1);
                this.circleMin.attr("cx", x1);
                this.circleMax.attr("cx", x1 + this.currentBarLength);
                // or else we are dragging one of the circles.
            }
            else if (this.isInverted
                && (this.dragObj.id == this.bar0.attr('id')
                    || this.dragObj.id == this.bar1.attr('id'))) {
                // when inverted, dragging bars does nothing
                return;
            }
            else if (this.dragObj == this.circleSingle) {
                // move the one time steper
                this.singleTimeStepX = Math.max(this.LEFT, Math.min(this.width - this.RIGHT, this.getRelX()));
                d3.select(this.dragObj).attr("transform", 'translate(' + this.singleTimeStepX + ', 0)');
            }
            else {
                d3.select(this.dragObj).attr("cx", Math.max(this.LEFT, Math.min(this.width - this.RIGHT, this.getRelX())));
                if (this.isInverted) {
                    this.bar0
                        .attr('x', this.LEFT)
                        .attr('width', this.circleMin.attr('cx') - this.LEFT);
                    this.bar1
                        .attr('x', this.circleMax.attr('cx'))
                        .attr('width', this.width - (this.RIGHT * 2) - this.circleMax.attr('cx'));
                }
                else {
                    this.bar0.attr('x', this.circleMin.attr('cx'))
                        .attr('width', this.circleMax.attr('cx') - this.circleMin.attr('cx'));
                }
            }
            this.dragEnd();
        }
        dragEnd() {
            this.min = this.valueRange(this.circleMin.attr("cx"));
            this.max = this.valueRange(this.circleMax.attr("cx"));
            this.dragEndCallBackFn(this.min, this.max, this.valueRange(this.singleTimeStepX));
        }
        getRelX() {
            var sourceEvent = (d3.event).sourceEvent;
            var pageX = sourceEvent ? (sourceEvent).pageX : 0;
            return pageX - this.LEFT - this.x - this.rect.left;
        }
        set(min, max) {
            // seems like this would make sense, 
            // this.min = min;
            // this.max = max;
            this.circleMin.attr("cx", this.valueRange.invert(min));
            this.circleMax.attr("cx", this.valueRange.invert(max));
            // inverted support
            if (this.isInverted) {
                this.bar0
                    .attr('x', this.LEFT)
                    .attr('width', this.circleMin.attr('cx'));
                this.bar1
                    .attr('x', this.circleMax.attr('cx'))
                    .attr('width', this.width - (this.RIGHT * 2) - this.circleMax.attr('cx'));
            }
            else {
                this.bar0
                    .attr('x', this.circleMin.attr('cx'))
                    .attr('width', this.circleMax.attr('cx') - this.circleMin.attr('cx'));
            }
        }
        setIsInverted(inv) {
            if (inv == this.isInverted)
                return;
            this.isInverted = inv;
            if (this.isInverted) {
                // create bar1, set positions of both
                this.bar1 = this.g.insert('rect', '#bar0')
                    .attr('x', this.RIGHT)
                    .attr('y', this.TOP)
                    .attr('height', this.BAR_WIDTH)
                    .attr('width', 0)
                    .style('fill', '#bbb')
                    .call(this.drag)
                    .attr('id', 'bar1');
            }
            else {
                this.bar1.remove();
            }
            this.set(this.min, this.max);
        }
    }

    var smartslider = /*#__PURE__*/Object.freeze({
        __proto__: null,
        SmartSlider: SmartSlider
    });

    /// <reference path="./lib/d3.d.ts"/>
    class Timeline {
        constructor(webgl, network, x, y, width, height) {
            this.TICK_MIN_DIST = 13;
            this.LABEL_MIN_DIST = 13;
            this.timeObjects = []; // INIT
            this.tickmarks = new WebGLElementQuery(); // INIT
            this.timeLabels = new WebGLElementQuery(); // INIT
            this.tick_minGran_visible_prev = -1; // INIT
            this.x = x;
            this.y = y;
            this.WIDTH = width;
            this.HEIGHT = height;
            this.webgl = webgl;
            this.network = network;
            this.granules = GRANULARITY;
            this.minGran = this.network.getMinGranularity();
            this.maxGran = this.granules.length - 1;
            this.visualize();
        }
        visualize() {
            /* MOVE TO CONSTRUCTOR */
            var times = this.network.times().toArray();
            // create non-indexed times
            var unix_start = times[0] ? times[0].unixTime() : 0;
            var unix_end = times[times.length - 1] ? times[times.length - 1].unixTime() : 0;
            var start = moment.utc(unix_start + '', 'x').startOf(this.granules[this.minGran]);
            var end = moment.utc(unix_end + '', 'x').startOf(this.granules[this.minGran]);
            var numTimes = Math.ceil(Math.abs(start.diff(end, this.granules[this.minGran]))); // WITHOUT 's'
            this.maxGran = Math.min(this.maxGran, this.granules.length - 1);
            var granularity_levels = ((this.maxGran - this.minGran) + 1);
            var granularity_height = this.HEIGHT / granularity_levels;
            // create all timeObjects (UTC)
            var prev = moment.utc(unix_start + '', 'x');
            var prevprev = moment.utc((unix_start - 86400000) + '', 'x'); // substract one day
            // bb: check why 'substract' is not working:
            // prevprev.substract(1, this.granules[this.minGran] + 's');
            this.timeObjects.push(prev);
            for (var i = 1; i < numTimes; i++) {
                prev = moment.utc(prev); // ???
                prev.add(1, this.granules[this.minGran]); // WITHOUT 's'
                this.timeObjects.push(prev);
            }
            this.timeGranularities = [];
            // set granularity for first time step: 
            var granularitySet;
            var y1, y2;
            var to1, to2;
            for (var i = 0; i < this.timeObjects.length; i++) {
                granularitySet = false;
                if (i == 0)
                    to1 = prevprev;
                else
                    to1 = this.timeObjects[i - 1];
                to2 = this.timeObjects[i];
                for (var gran = this.maxGran; gran >= this.minGran && !granularitySet; gran--) {
                    if (gran > 7) {
                        y1 = to1.get(this.granules[7]) + '';
                        y2 = to2.get(this.granules[7]) + '';
                        // test for millenia
                        if (y1[y1.length - 4] != y2[y2.length - 4]) {
                            this.timeGranularities.push(10);
                            granularitySet = true;
                        }
                        // test for centuries
                        else if (y1[y1.length - 3] != y2[y2.length - 3]) {
                            this.timeGranularities.push(9);
                            granularitySet = true;
                        }
                        // test for decades
                        else if (y1[y1.length - 2] != y2[y2.length - 2]) {
                            this.timeGranularities.push(8);
                            granularitySet = true;
                        }
                    }
                    else if (to1.get(this.granules[gran]) != to2.get(this.granules[gran])) {
                        this.timeGranularities.push(gran);
                        granularitySet = true;
                    }
                }
            }
            // create mapping functions
            this.position_x = d3.scale.linear()
                .domain([0, this.timeGranularities.length - 1])
                .range([this.x + 1, this.x + this.WIDTH - 1]);
            this.position_y = d3.scale.linear()
                .domain([this.minGran - 1, this.maxGran])
                .range([-this.HEIGHT, 0]);
            this.label_opacity = d3.scale.linear()
                .domain([this.minGran - 1, this.maxGran])
                .range([.2, 1]);
            // Draw tickmarks
            this.tickmarks = this.webgl.selectAll()
                .data(this.timeGranularities)
                .append('line')
                .attr('x1', (d, i) => this.position_x(i))
                .attr('x2', (d, i) => this.position_x(i))
                .attr('y1', (d, i) => this.position_y(d))
                .attr('y2', (d, i) => -this.HEIGHT)
                .style('stroke', '#000')
                .style('opacity', .1);
            // create highlight pointer
            this.highlightPointer = this.webgl.selectAll()
                .data([0])
                .append('line')
                .attr('x1', 0)
                .attr('x2', 0)
                .attr('y1', 0)
                .attr('y2', -this.HEIGHT)
                .style('stroke', '#f00')
                .style('opacity', 0);
            this.highlightLabel = this.webgl.selectAll()
                .data([0])
                .append('text')
                .attr('x', 0)
                .attr('y', -6)
                .style('fill', '#f00')
                .style('font-size', 10)
                .style('opacity', 0);
            this.updateWithIds(0, this.timeObjects.length - 1);
        }
        update(startUnix, endUnix) {
            // search for start:
            var startId, endId;
            for (var i = 0; i < this.timeObjects.length; i++) {
                if ((this.timeObjects[i].unix() * 1000) > startUnix) {
                    startId = i - 1;
                    break;
                }
            }
            for (i = startId; i < this.timeObjects.length; i++) {
                if ((this.timeObjects[i].unix() * 1000) > endUnix) {
                    endId = i;
                    break;
                }
            }
            if (endId == undefined) {
                endId = this.timeObjects.length - 1;
            }
            this.updateWithIds(startId, endId);
        }
        updateWithIds(minTimeId, maxTimeId) {
            this.minTimeId = minTimeId;
            this.maxTimeId = maxTimeId;
            // set range function domain
            this.position_x.domain([minTimeId, maxTimeId]);
            var ticksFitting = Math.floor(this.WIDTH / this.TICK_MIN_DIST);
            var minTime = this.timeObjects[this.minTimeId];
            var maxTime = this.timeObjects[this.maxTimeId];
            var requiredTicks = Number.MAX_VALUE; // INIT?
            var t1, t2;
            this.tick_minGran_visible = undefined;
            for (var g = this.minGran; g < this.maxGran && this.tick_minGran_visible == undefined; g++) {
                // calculate how many times of this granularity can fit.
                t1 = moment.utc(minTime).startOf(this.granules[g]);
                t2 = moment.utc(maxTime).startOf(this.granules[g]);
                if (g <= 7) {
                    requiredTicks = moment.duration(t2.diff(t1)).as(this.granules[g]);
                }
                else {
                    if (g == 8)
                        requiredTicks = moment.duration(t2.diff(t1)).as(this.granules[7]) / 10;
                    if (g == 9)
                        requiredTicks = moment.duration(t2.diff(t1)).as(this.granules[7]) / 100;
                    if (g == 10)
                        requiredTicks = moment.duration(t2.diff(t1)).as(this.granules[7]) / 1000;
                }
                if (requiredTicks <= ticksFitting) {
                    this.tick_minGran_visible = g;
                }
            }
            this.label_minGran_visible = this.tick_minGran_visible;
            this.label_opacity
                .domain([this.tick_minGran_visible - 1, this.maxGran]);
            if (this.tick_minGran_visible_prev != this.tick_minGran_visible) {
                console.log('re-create time labels');
                // re-create labels
                if (this.timeLabels != undefined)
                    this.timeLabels.removeAll();
                this.timeLabels = this.webgl.selectAll()
                    .data(this.timeObjects)
                    .filter((d, i) => {
                    var visible = this.timeGranularities[i] >= this.tick_minGran_visible;
                    return visible;
                })
                    .append('text')
                    .attr('x', (d, i) => this.position_x(this.timeObjects.indexOf(d)) + 8)
                    .attr('y', (d, i) => -this.HEIGHT + 17)
                    .text((d, i) => this.formatTime(this.timeObjects.indexOf(d)))
                    .attr('z', 1)
                    .style('fill', '#000')
                    .attr('rotation', 90)
                    .style('font-size', 10)
                    .style('opacity', .1);
                console.log('time labels created:', this.timeLabels.length);
            }
            this.tick_minGran_visible_prev = this.tick_minGran_visible;
            this.tickmarks
                .style('opacity', (d, i) => {
                var visible = i == 0
                    || i >= this.minTimeId
                        && i <= this.maxTimeId
                        && this.timeGranularities[i] >= this.tick_minGran_visible
                    ? this.label_opacity(this.timeGranularities[i])
                    : 0;
                return visible;
            })
                .attr('x1', (d, i) => this.position_x(i))
                .attr('x2', (d, i) => this.position_x(i))
                .style('stroke-width', (d, i) => this.label_opacity(this.timeGranularities[i]) * 4);
            // update labels
            this.timeLabels
                .style('opacity', (d, i) => {
                var globalId = this.timeObjects.indexOf(d);
                var visible = globalId >= this.minTimeId
                    && globalId <= this.maxTimeId
                    && this.timeGranularities[globalId] >= this.label_minGran_visible;
                return visible ? 1 : 0;
            })
                .attr('x', (d, i) => {
                var globalId = this.timeObjects.indexOf(d);
                return this.position_x(globalId) + 8;
            });
            // update highlightPointer
            if (this.highlightId != undefined) {
                this.highlightPointer
                    .attr('x1', this.position_x(this.highlightId))
                    .attr('x2', this.position_x(this.highlightId));
                this.highlightLabel
                    .attr('x', this.position_x(this.highlightId) + 37);
            }
        }
        formatTime(index) {
            var t = this.timeObjects[index];
            var g = Math.min(Math.max(this.tick_minGran_visible, this.timeGranularities[index]), 7);
            return formatAtGranularity(t, g);
        }
        highlight(unixTime) {
            if (unixTime == undefined) {
                this.highlightPointer
                    .style('opacity', 0);
                this.highlightId = undefined;
            }
            for (var i = 0; i < this.timeObjects.length; i++) {
                if (!unixTime || (this.timeObjects[i].unix() * 1000) > unixTime) { // IS CORRECT !unixTime ?? 
                    this.highlightId = i - 1;
                    break;
                }
            }
            if (this.highlightId == undefined) {
                this.highlightId = this.timeObjects.length - 1;
            }
            this.highlightPointer
                .attr('x1', this.position_x(this.highlightId))
                .attr('x2', this.position_x(this.highlightId))
                .style('opacity', 1);
            this.highlightLabel
                .style('opacity', 1)
                .attr('x', this.position_x(this.highlightId) + 37)
                .text(this.timeObjects[this.highlightId].format('DD/MM/YYYY'));
        }
    }

    var timeline = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Timeline: Timeline
    });

    /// <reference path="./lib/d3.d.ts"/>
    function makeSlider(d3parent, // BEFORE d3.Selection<d3.BaseType, {}, HTMLElement, any>, 
    label, width, height, value, min, max, handler) {
        var slider = new Slider(5, height - 5, width, min, max, .01);
        var svg = d3parent.append('svg')
            .attr('width', width + 20)
            .attr('height', height);
        svg.append('text')
            .attr('x', 10)
            .attr('y', height - 15)
            .text(label)
            .attr('class', 'sliderLabel');
        slider.appendTo(svg);
        slider.set(value);
        slider.setDragEndCallBack(handler);
    }
    class RadioButton {
        constructor(color, text) {
            this.checked = false;
            this.text = '';
            this.RADIUS = 7;
            this.color = color;
            if (text)
                this.text = text;
        }
        appendTo(x, y, svg) {
            var g = svg.append('g')
                .attr('transform', 'translate(' + x + ',' + y + ')');
            this.circle = g.append('circle')
                .attr('r', this.RADIUS)
                .attr('fill', '#ffffff')
                .attr('stroke', this.color)
                .attr('stroke-width', 1)
                .attr('cx', this.RADIUS * 2)
                .attr('cy', 0)
                .attr('oninput', 'trace.event(\'vis_4\',document.location.pathname,this.parentElement.previousElementSibling.innerHTML ,\'cx\' + this.getAttribute(\'cx\'))')
                .attr('onmouseup', 'trace.event(\'vis_4\',document.location.pathname,this.parentElement.previousElementSibling.innerHTML ,\'cx\' + this.getAttribute(\'cx\'))');
            if (this.text) {
                this.label = g.append('text')
                    .attr('x', this.RADIUS * 1.4)
                    .attr('y', 5)
                    .style('font-family', 'Helvetica')
                    .style('font-size', '9pt')
                    .style('user-select', 'none')
                    .text(this.text[0])
                    .on('click', () => {
                    this.checked = !this.checked;
                    if (this.checked) {
                        this.circle.attr('fill', this.color);
                        this.label.attr('fill', '#ffffff');
                    }
                    else {
                        this.circle.attr('fill', '#ffffff');
                        this.label.attr('fill', this.color);
                    }
                    if (this.clickHandler) {
                        this.clickHandler();
                    }
                });
            }
        }
        isChecked() {
            return this.checked;
        }
        addClickHandler(f) {
            this.clickHandler = f;
        }
    }
    function makeCheckBox(d3parent, label, callback) {
        d3parent.append('input')
            .attr('type', 'checkbox')
            .on('change', callback);
        d3parent.append('b').attr('class', 'sliderLabel').html(label);
    }
    function makeButton(d3parent, label, callback) {
        d3parent.append('input')
            .attr('type', 'button')
            .attr('value', label)
            .on('click', callback);
    }

    var ui = /*#__PURE__*/Object.freeze({
        __proto__: null,
        makeSlider: makeSlider,
        RadioButton: RadioButton,
        makeCheckBox: makeCheckBox,
        makeButton: makeButton
    });

    /// <reference path="./lib/d3.d.ts"/>
    class TimeSlider {
        constructor(dgraph, width, callBack) {
            /** VISUALIZATION  PARAMETERS */
            this.MARGIN_SLIDER_RIGHT = 30;
            this.MARGIN_SLIDER_LEFT = 10;
            this.TICK_GAP = 2;
            this.TICK_LABEL_GAP = 40;
            this.SLIDER_TOP = 25;
            this.HEIGHT = 200;
            this.callBack = undefined;
            // function that is called when this time slider's time is changed
            this.propagateButton = new RadioButton('#000000');
            this.dgraph = dgraph;
            this.times = dgraph.times().toArray();
            this.widgetWidth = width;
            var timesDummy = new Time(0, this.dgraph);
            this.sliderWidth = width - this.MARGIN_SLIDER_RIGHT + 5 - this.MARGIN_SLIDER_LEFT - 5;
            var lastDummyYear = this.times.length != 0 ? this.times[this.times.length - 1].moment() : timesDummy.moment(); // WHAT HAPPEND??
            var minGran = dgraph.gran_min;
            var minGranName = 'milliseconds';
            switch (minGran) {
                case 1:
                    minGranName = 'milliseconds';
                    break;
                case 2:
                    minGranName = 'seconds';
                    break;
                case 3:
                    minGranName = 'minutes';
                    break;
                case 4:
                    minGranName = 'hours';
                    break;
                case 5:
                    minGranName = 'days';
                    break;
                case 5:
                    minGranName = 'weeks';
                    break;
                case 6:
                    minGranName = 'months';
                    break;
                case 7:
                    minGranName = 'years';
                    break;
                // case 8: minGranName = 'decades'; break;
                // case 9: minGranName = 'centuries'; break;
                // case 10: minGranName = 'millenia'; break;
            }
            if (!lastDummyYear) {
                lastDummyYear = moment.unix(0);
            }
            lastDummyYear.add(1, minGranName);
            let unixTimeSlider = this.times.length != 0 ? this.times[0].unixTime() : 0; // IS IT OK?? 
            this.slider = new SmartSlider(this.MARGIN_SLIDER_LEFT, this.SLIDER_TOP, this.sliderWidth, unixTimeSlider, lastDummyYear.valueOf(), 1);
            if (callBack)
                this.callBack = callBack;
            this.tickScale = d3.time.scale.utc()
                .range([this.MARGIN_SLIDER_LEFT, this.MARGIN_SLIDER_LEFT + this.sliderWidth])
                .domain([unixTimeSlider, lastDummyYear.valueOf()]);
            this.tickHeightFunction = d3.scale.linear()
                .range([4, this.SLIDER_TOP - 10])
                .domain([dgraph.gran_min, dgraph.gran_max]);
        }
        appendTo(svg, x, y) {
            if (!x)
                x = 0;
            if (!y)
                y = 0;
            var g = svg.append('g')
                .attr('transform', 'translate(' + x + ',' + y + ')');
            g.append("g")
                .attr('transform', 'translate(0,' + this.SLIDER_TOP + ')')
                .attr("class", "x axis")
                .call(d3.svg.axis().scale(this.tickScale).orient("top"));
            this.labelStart = g.append('text')
                .attr('y', this.SLIDER_TOP + 20)
                .style('opacity', 0)
                .style('font-family', 'Helvetica')
                .style('font-weigth', '100')
                .style('font-size', '8pt')
                .style('text-anchor', 'end')
                .text('')
                .style('user-select', 'none')
                .style('-webkit-user-select', 'none')
                .style('-khtml-user-select', 'none')
                .style('-moz-user-select', 'none')
                .style('-o-user-select', 'none')
                .style('user-select', 'none');
            this.labelEnd = g.append('text')
                .style('opacity', 0)
                .attr('y', this.SLIDER_TOP + 20)
                .style('font-family', 'Helvetica')
                .style('font-weigth', '100')
                .style('font-size', '8pt')
                .style('text-anchor', 'start')
                .text('')
                .style('user-select', 'none')
                .style('-webkit-user-select', 'none')
                .style('-khtml-user-select', 'none')
                .style('-moz-user-select', 'none')
                .style('-o-user-select', 'none')
                .style('user-select', 'none');
            this.slider.appendTo(g);
            this.slider.setDragEndCallBack((min, max, single) => this.updateTime(min, max, single));
            this.propagateButton = new RadioButton('#000000', 'Syncronize Time');
            this.propagateButton.appendTo(this.sliderWidth + 15, this.SLIDER_TOP + 8, g);
        }
        drawTickmarks(granularity, tickTimes, svg) {
            var displayLabelSpacing = 1; // display every label
            while (Math.floor(this.sliderWidth / this.TICK_LABEL_GAP) < (tickTimes.length / displayLabelSpacing) && displayLabelSpacing < 100) {
                displayLabelSpacing++;
            }
            for (var i = 0; i < tickTimes.length; i++) {
                if ((i % displayLabelSpacing) == 0) {
                    svg.append('text')
                        .attr('x', this.tickScale(tickTimes[i].unixTime()))
                        .attr('y', this.SLIDER_TOP - this.tickHeightFunction(granularity))
                        .text(this.formatAtGranularity(tickTimes[i].time(), granularity))
                        .attr('id', 'timelabel_' + granularity + '_' + i)
                        .attr('class', 'timelabel')
                        .style('opacity', .5)
                        .style('font-family', 'Helvetica')
                        .style('font-weigth', '100')
                        .style('font-size', '7pt');
                    svg.append('line')
                        .attr('x1', this.tickScale(tickTimes[i].unixTime()))
                        .attr('x2', this.tickScale(tickTimes[i].unixTime()))
                        .attr('y1', this.SLIDER_TOP)
                        .attr('y2', this.SLIDER_TOP - this.tickHeightFunction(granularity))
                        .style('stroke', '#bbb');
                }
            }
        }
        formatAtGranularity(time, granualarity) {
            switch (granualarity) {
                case 0: return time.millisecond();
                case 1: return time.second();
                case 2: return time.minute();
                case 3: return time.hour();
                case 4: return time.day();
                case 5: return time.week();
                case 6: return time.month() + 1;
                default: return time.year();
            }
        }
        formatForGranularities(time, gran_min, gran_max) {
            var formatString = '';
            while (gran_max >= gran_min) {
                formatString += this.getGranularityFormattingString(gran_max, (gran_max > gran_min));
                gran_max--;
            }
            return time.format(formatString.trim());
        }
        getGranularityFormattingString(granualarity, separator) {
            switch (granualarity) {
                case 0: return 'SSS';
                case 1: return 'ss' + (separator ? '.' : '');
                case 2: return 'mm' + (separator ? ':' : '');
                case 3: return 'hh' + (separator ? '' : '');
                case 4: return 'DD' + (separator ? ' ' : '');
                case 6: return 'MM' + (separator ? '-' : '');
                default: return 'YYYY' + (separator ? '-' : '');
            }
        }
        updateTime(minUnix, maxUnix, single) {
            // times are still correct here? 
            var format = function (d) { return d.toDateString(); };
            single = Math.round(single);
            this.labelStart
                .attr('x', this.slider.valueRange.invert(minUnix) + 10)
                .style('opacity', 1)
                .text(format(new Date(minUnix)));
            this.labelEnd
                .attr('x', this.slider.valueRange.invert(maxUnix) + 10)
                .style('opacity', 1)
                .text(format(new Date(maxUnix)));
            if (this.callBack != undefined)
                this.callBack(minUnix, maxUnix, this.propagateButton.isChecked());
            else
                timeRange(minUnix, maxUnix, this.times[single], this.propagateButton.isChecked());
        }
        set(startUnix, endUnix) {
            this.slider.set(startUnix, endUnix);
        }
    }

    var timeslider = /*#__PURE__*/Object.freeze({
        __proto__: null,
        TimeSlider: TimeSlider
    });

    exports.BSpline = BSpline$1;
    exports.analytics = analytics;
    exports.colors = colors;
    exports.datamanager = datamanager;
    exports.dynamicgraph = dynamicgraph;
    exports.glutils = glutils;
    exports.importers = importers;
    exports.legend = legend;
    exports.main = main;
    exports.messenger = messenger;
    exports.motifs = motifs;
    exports.ordering = ordering;
    exports.queries = queries;
    exports.rangeslider = rangeslider;
    exports.search = search;
    exports.slider = slider;
    exports.smartslider = smartslider;
    exports.timeline = timeline;
    exports.timeslider = timeslider;
    exports.ui = ui;
    exports.utils = utils;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=vistorian-core.js.map
